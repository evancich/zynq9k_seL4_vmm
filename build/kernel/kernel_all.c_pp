# 1 "kernel_all.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "kernel_all.c"
# 1 "/home/sel4/work/work2/kernel/src/api/faults.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




/* Compile-time configuration parameters. Might be set by the build system. */


# 1 "/home/sel4/work/work2/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * CAmkES project configuration
 * Tue Aug  1 11:39:17 2017
 */
# 18 "/home/sel4/work/work2/kernel/include/config.h" 2


/* size of the initial thread's root CNode (2^x slots, x >= 4) */




/* number of timer ticks until a thread is preempted  */




/* the number of scheduler domains */




/* number of priorities per domain */




/* maximum number of caps that can be created in one retype invocation */




/* chunk size for memory clears during retype, in bits. */




/* maximum number of iterations until we preempt a delete/revoke invocation */




/* address range to flush per preemption work unit */




/* maximum number of untyped caps in bootinfo */
/* WARNING: must match value in libsel4! */
/* CONSTRAINT: (16 * CONFIG_MAX_NUM_BOOTINFO_DEVICE_REGIONS) + (5 * CONFIG_MAX_NUM_BOOTINFO_UNTYPED_CAPS) <= 4036 */




/* length of a timer tick in ms  */




/* maximum number of different tracepoints which can be placed in the kernel */




/* maximum number of IOMMU RMRR entries we can record while ACPI parsing */




/* maximum number of IOAPIC supported */




/* Alias CONFIG_MAX_NUM_NODES > 1 to ENABLE_SMP_SUPPORT */
# 14 "/home/sel4/work/work2/kernel/src/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/basic_types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef signed long long int64_t;
# 15 "/home/sel4/work/work2/kernel/include/basic_types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/assert.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 44 "/home/sel4/work/work2/kernel/include/util.h"
/** MODIFIES: */
void __builtin_unreachable(void);







/* Borrowed from linux/include/linux/compiler.h */







/* need that for compiling with c99 instead of gnu99 */


/* Evaluate a Kconfig-provided configuration setting at compile-time. */






/* Check the existance of a configuration setting, returning one value if it
 * exists and a different one if it does not */





/** MODIFIES:
    FNSPEC
        halt_spec: "\<Gamma> \<turnstile> {} Call halt_'proc {}"
*/
void halt(void) __attribute__((__noreturn__));
void memzero(void *s, unsigned long n);
void *memset(void *s, unsigned long c, unsigned long n) __attribute__((externally_visible));
void *memcpy(void* ptr_dst, const void* ptr_src, unsigned long n) __attribute__((externally_visible));
int __attribute__((__pure__)) strncmp(const char *s1, const char *s2, int n);
long __attribute__((__const__)) char_to_long(char c);
long __attribute__((__pure__)) str_to_long(const char* str);


int __builtin_clzl (unsigned long x);
int __builtin_ctzl (unsigned long x);

/** MODIFIES: */
/** DONT_TRANSLATE */
/** FNSPEC clzl_spec:
  "\<forall>s. \<Gamma> \<turnstile>
    {\<sigma>. s = \<sigma> \<and> x_' s \<noteq> 0 }
      \<acute>ret__long :== PROC clzl(\<acute>x)
    \<lbrace> \<acute>ret__long = of_nat (word_clz (x_' s)) \<rbrace>"
*/
static inline long
__attribute__((__const__)) clzl(unsigned long x)
{
    return __builtin_clzl(x);
}

/** MODIFIES: */
/** DONT_TRANSLATE */
/** FNSPEC ctzl_spec:
  "\<forall>s. \<Gamma> \<turnstile>
    {\<sigma>. s = \<sigma> \<and> x_' s \<noteq> 0 }
      \<acute>ret__long :== PROC ctzl(\<acute>x)
    \<lbrace> \<acute>ret__long = of_nat (word_ctz (x_' s)) \<rbrace>"
*/
static inline long
__attribute__((__const__)) ctzl(unsigned long x)
{
    return __builtin_ctzl(x);
}



int __builtin_popcountl (unsigned long x);

/** DONT_TRANSLATE */
static inline long
__attribute__((__const__)) popcountl(unsigned long mask)
{

    unsigned int count; // c accumulates the total bits set in v
    for (count = 0; mask; count++) {
        mask &= mask - 1; // clear the least significant bit set
    }

    return count;



}
# 16 "/home/sel4/work/work2/kernel/include/assert.h" 2



void _fail(
    const char* str,
    const char* file,
    unsigned int line,
    const char* function
) __attribute__((__noreturn__));



void _assert_fail(
    const char* assertion,
    const char* file,
    unsigned int line,
    const char* function
) __attribute__((__noreturn__));
# 46 "/home/sel4/work/work2/kernel/include/assert.h"
/* Create an assert that will trigger a compile error if it fails. */



/* Sometimes compile asserts contain expressions that the C parser cannot
 * handle. For such expressions unverified_compile_assert should be used. */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 2


typedef int __assert_failed_long_is_32bits[(sizeof(unsigned long) == 4) ? 1 : -1];




typedef unsigned long word_t;
typedef signed long sword_t;
typedef word_t vptr_t;
typedef word_t paddr_t;
typedef word_t pptr_t;
typedef word_t cptr_t;
typedef word_t node_id_t;
typedef word_t cpu_id_t;
typedef word_t dom_t;

typedef uint8_t hw_asid_t;

enum hwASIDConstants {
    hwASIDMax = 255,
    hwASIDBits = 8
};

/* for libsel4 headers that the kernel shares */
typedef word_t seL4_Word;
typedef cptr_t seL4_CPtr;
typedef uint32_t seL4_Uint32;
typedef uint16_t seL4_Uint16;
typedef uint8_t seL4_Uint8;
typedef node_id_t seL4_NodeId;
typedef dom_t seL4_Domain;
typedef paddr_t seL4_PAddr;

typedef struct kernel_frame {
    paddr_t paddr;
    pptr_t pptr;
    int armExecuteNever;
} kernel_frame_t;
# 16 "/home/sel4/work/work2/kernel/include/basic_types.h" 2

enum _bool {
    false = 0,
    true = 1
};
typedef word_t bool_t;

typedef struct region {
    pptr_t start;
    pptr_t end;
} region_t;

typedef struct p_region {
    paddr_t start;
    paddr_t end;
} p_region_t;

typedef struct v_region {
    vptr_t start;
    vptr_t end;
} v_region_t;
# 15 "/home/sel4/work/work2/kernel/include/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/compound_types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/compound_types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/api/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/api/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/api/types.h" 2
# 1 "32/mode/api/shared_types_gen.h" 1



# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 5 "32/mode/api/shared_types_gen.h" 2
# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 6 "32/mode/api/shared_types_gen.h" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 7 "32/mode/api/shared_types_gen.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 8 "32/mode/api/shared_types_gen.h" 2
struct seL4_PrioProps {
    uint32_t words[1];
};
typedef struct seL4_PrioProps seL4_PrioProps_t;

static inline uint32_t __attribute__((__const__))
seL4_PrioProps_get_mcp(seL4_PrioProps_t seL4_PrioProps) {
    uint32_t ret;
    ret = (seL4_PrioProps.words[0] & 0xff00ul) >> 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
seL4_PrioProps_get_prio(seL4_PrioProps_t seL4_PrioProps) {
    uint32_t ret;
    ret = (seL4_PrioProps.words[0] & 0xfful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct seL4_MessageInfo {
    uint32_t words[1];
};
typedef struct seL4_MessageInfo seL4_MessageInfo_t;

static inline seL4_MessageInfo_t __attribute__((__const__))
seL4_MessageInfo_new(uint32_t label, uint32_t capsUnwrapped, uint32_t extraCaps, uint32_t length) {
    seL4_MessageInfo_t seL4_MessageInfo;

    /* fail if user has passed bits that we will override */
    if(!((label & ~0xffffful) == ((0 && (label & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(label & ~0xffffful) == ((0 && (label & (1ul << 31))) ? 0x0 : 0)", "32/mode/api/shared_types_gen.h", 45, __FUNCTION__);
    if(!((capsUnwrapped & ~0x7ul) == ((0 && (capsUnwrapped & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capsUnwrapped & ~0x7ul) == ((0 && (capsUnwrapped & (1ul << 31))) ? 0x0 : 0)", "32/mode/api/shared_types_gen.h", 46, __FUNCTION__);
    if(!((extraCaps & ~0x3ul) == ((0 && (extraCaps & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(extraCaps & ~0x3ul) == ((0 && (extraCaps & (1ul << 31))) ? 0x0 : 0)", "32/mode/api/shared_types_gen.h", 47, __FUNCTION__);
    if(!((length & ~0x7ful) == ((0 && (length & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(length & ~0x7ful) == ((0 && (length & (1ul << 31))) ? 0x0 : 0)", "32/mode/api/shared_types_gen.h", 48, __FUNCTION__);

    seL4_MessageInfo.words[0] = 0
        | (label & 0xffffful) << 12
        | (capsUnwrapped & 0x7ul) << 9
        | (extraCaps & 0x3ul) << 7
        | (length & 0x7ful) << 0;

    return seL4_MessageInfo;
}

static inline uint32_t __attribute__((__const__))
seL4_MessageInfo_get_label(seL4_MessageInfo_t seL4_MessageInfo) {
    uint32_t ret;
    ret = (seL4_MessageInfo.words[0] & 0xfffff000ul) >> 12;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
seL4_MessageInfo_get_capsUnwrapped(seL4_MessageInfo_t seL4_MessageInfo) {
    uint32_t ret;
    ret = (seL4_MessageInfo.words[0] & 0xe00ul) >> 9;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline seL4_MessageInfo_t __attribute__((__const__))
seL4_MessageInfo_set_capsUnwrapped(seL4_MessageInfo_t seL4_MessageInfo, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xe00 >> 9 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xe00 >> 9 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "32/mode/api/shared_types_gen.h", 84, __FUNCTION__);
    seL4_MessageInfo.words[0] &= ~0xe00ul;
    seL4_MessageInfo.words[0] |= (v << 9) & 0xe00ul;
    return seL4_MessageInfo;
}

static inline uint32_t __attribute__((__const__))
seL4_MessageInfo_get_extraCaps(seL4_MessageInfo_t seL4_MessageInfo) {
    uint32_t ret;
    ret = (seL4_MessageInfo.words[0] & 0x180ul) >> 7;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline seL4_MessageInfo_t __attribute__((__const__))
seL4_MessageInfo_set_extraCaps(seL4_MessageInfo_t seL4_MessageInfo, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x180 >> 7 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x180 >> 7 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "32/mode/api/shared_types_gen.h", 104, __FUNCTION__);
    seL4_MessageInfo.words[0] &= ~0x180ul;
    seL4_MessageInfo.words[0] |= (v << 7) & 0x180ul;
    return seL4_MessageInfo;
}

static inline uint32_t __attribute__((__const__))
seL4_MessageInfo_get_length(seL4_MessageInfo_t seL4_MessageInfo) {
    uint32_t ret;
    ret = (seL4_MessageInfo.words[0] & 0x7ful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline seL4_MessageInfo_t __attribute__((__const__))
seL4_MessageInfo_set_length(seL4_MessageInfo_t seL4_MessageInfo, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x7f >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x7f >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "32/mode/api/shared_types_gen.h", 124, __FUNCTION__);
    seL4_MessageInfo.words[0] &= ~0x7ful;
    seL4_MessageInfo.words[0] |= (v << 0) & 0x7ful;
    return seL4_MessageInfo;
}

struct seL4_CapRights {
    uint32_t words[1];
};
typedef struct seL4_CapRights seL4_CapRights_t;

static inline seL4_CapRights_t __attribute__((__const__))
seL4_CapRights_new(uint32_t capAllowGrant, uint32_t capAllowRead, uint32_t capAllowWrite) {
    seL4_CapRights_t seL4_CapRights;

    /* fail if user has passed bits that we will override */
    if(!((capAllowGrant & ~0x1ul) == ((0 && (capAllowGrant & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capAllowGrant & ~0x1ul) == ((0 && (capAllowGrant & (1ul << 31))) ? 0x0 : 0)", "32/mode/api/shared_types_gen.h", 140, __FUNCTION__);
    if(!((capAllowRead & ~0x1ul) == ((0 && (capAllowRead & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capAllowRead & ~0x1ul) == ((0 && (capAllowRead & (1ul << 31))) ? 0x0 : 0)", "32/mode/api/shared_types_gen.h", 141, __FUNCTION__);
    if(!((capAllowWrite & ~0x1ul) == ((0 && (capAllowWrite & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capAllowWrite & ~0x1ul) == ((0 && (capAllowWrite & (1ul << 31))) ? 0x0 : 0)", "32/mode/api/shared_types_gen.h", 142, __FUNCTION__);

    seL4_CapRights.words[0] = 0
        | (capAllowGrant & 0x1ul) << 2
        | (capAllowRead & 0x1ul) << 1
        | (capAllowWrite & 0x1ul) << 0;

    return seL4_CapRights;
}

static inline uint32_t __attribute__((__const__))
seL4_CapRights_get_capAllowGrant(seL4_CapRights_t seL4_CapRights) {
    uint32_t ret;
    ret = (seL4_CapRights.words[0] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
seL4_CapRights_get_capAllowRead(seL4_CapRights_t seL4_CapRights) {
    uint32_t ret;
    ret = (seL4_CapRights.words[0] & 0x2ul) >> 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
seL4_CapRights_get_capAllowWrite(seL4_CapRights_t seL4_CapRights) {
    uint32_t ret;
    ret = (seL4_CapRights.words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}
# 18 "/home/sel4/work/work2/kernel/include/api/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/api/objecttype.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */




typedef enum api_object {
    seL4_UntypedObject,
    seL4_TCBObject,
    seL4_EndpointObject,
    seL4_NotificationObject,
    seL4_CapTableObject,
    seL4_NonArchObjectTypeCount,
} seL4_ObjectType;

__attribute__((deprecated("use seL4_NotificationObject"))) static const seL4_ObjectType seL4_AsyncEndpointObject = seL4_NotificationObject;

typedef seL4_Word api_object_t;
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/api/objecttype.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */




typedef enum _mode_object {
    seL4_ModeObjectTypeCount = seL4_NonArchObjectTypeCount,
} seL4_ModeObjectType;
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/objecttype.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */





# 1 "/home/sel4/work/work2/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * CAmkES project configuration
 * Tue Aug  1 11:39:17 2017
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/objecttype.h" 2


typedef enum _object {
    seL4_ARM_SmallPageObject = seL4_ModeObjectTypeCount,
    seL4_ARM_LargePageObject,

    seL4_ARM_SectionObject,
    seL4_ARM_SuperSectionObject,

    seL4_ARM_PageTableObject,
    seL4_ARM_PageDirectoryObject,

    seL4_ARM_VCPUObject,




    seL4_ObjectTypeCount
} seL4_ArchObjectType;

typedef seL4_Word object_t;
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/types.h" 2



enum asidConstants {
    asidInvalid = 0
};



typedef word_t asid_t;
# 19 "/home/sel4/work/work2/kernel/include/api/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/include/api/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/macros.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */




# 1 "/home/sel4/work/work2/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * CAmkES project configuration
 * Tue Aug  1 11:39:17 2017
 */
# 17 "/home/sel4/work/work2/kernel/include/api/macros.h" 2

/*
 * Some compilers attempt to pack enums into the smallest possible type.
 * For ABI compatability with the kernel, we need to ensure they remain
 * the same size as a 'long'.
 */
# 21 "/home/sel4/work/work2/kernel/include/api/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/constants.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */





# 1 "/home/sel4/work/work2/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * CAmkES project configuration
 * Tue Aug  1 11:39:17 2017
 */
# 18 "/home/sel4/work/work2/kernel/include/api/constants.h" 2
# 52 "/home/sel4/work/work2/kernel/include/api/constants.h"
enum priorityConstants {
    seL4_InvalidPrio = -1,
    seL4_MinPrio = 0,
    seL4_MaxPrio = 256 - 1
};

/* seL4_MessageInfo_t defined in api/shared_types.bf */

enum seL4_MsgLimits {
    seL4_MsgLengthBits = 7,
    seL4_MsgExtraCapBits = 2
};

enum {
    seL4_MsgMaxLength = 120,
};


typedef enum {
    seL4_NoFailure = 0,
    seL4_InvalidRoot,
    seL4_MissingCapability,
    seL4_DepthMismatch,
    seL4_GuardMismatch,
    _enum_pad_seL4_LookupFailureType = (1ULL << ((sizeof(long)*8) - 1)) - 1,
} seL4_LookupFailureType;
# 22 "/home/sel4/work/work2/kernel/include/api/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/shared_types.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */




/* this file is shared between the kernel and libsel4 */

typedef struct seL4_IPCBuffer_ {
    seL4_MessageInfo_t tag;
    seL4_Word msg[seL4_MsgMaxLength];
    seL4_Word userData;
    seL4_Word caps_or_badges[((1ul<<(seL4_MsgExtraCapBits))-1)];
    seL4_CPtr receiveCNode;
    seL4_CPtr receiveIndex;
    seL4_Word receiveDepth;
} seL4_IPCBuffer __attribute__ ((__aligned__ (sizeof(struct seL4_IPCBuffer_))));

enum {
    seL4_CapFault_IP,
    seL4_CapFault_Addr,
    seL4_CapFault_InRecvPhase,
    seL4_CapFault_LookupFailureType,
    seL4_CapFault_BitsLeft,
    seL4_CapFault_DepthMismatch_BitsFound,
    seL4_CapFault_GuardMismatch_GuardFound = seL4_CapFault_DepthMismatch_BitsFound,
    seL4_CapFault_GuardMismatch_BitsFound,
    _enum_pad_seL4_CapFault_Msg = (1ULL << ((sizeof(long)*8) - 1)) - 1,
} seL4_CapFault_Msg;
# 23 "/home/sel4/work/work2/kernel/include/api/types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/machine/io.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/machine/io.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/machine/io.h" 2





/* most arm platforms just call this for putConsoleChar, so
 * prototype it here */
void putDebugChar(unsigned char c);



/* io for dumping capdl */
unsigned char getDebugChar(void);



/* printf will result in output */
void putConsoleChar(unsigned char c);
void putchar(char c);

word_t kprintf(const char *format, ...) __attribute__((externally_visible)) __attribute__((format(printf, 1, 2)));
word_t puts(const char *s) __attribute__((externally_visible));
word_t print_unsigned_long(unsigned long x, word_t ui_base) __attribute__((externally_visible));
# 24 "/home/sel4/work/work2/kernel/include/api/types.h" 2

/* seL4_CapRights_t defined in mode/api/shared_types.bf */

typedef word_t prio_t;

enum domainConstants {
    minDom = 0,
    maxDom = 1 - 1
};

struct cap_transfer {
    cptr_t ctReceiveRoot;
    cptr_t ctReceiveIndex;
    word_t ctReceiveDepth;
};
typedef struct cap_transfer cap_transfer_t;

enum ctLimits {
    capTransferDataSize = 3
};

static inline seL4_CapRights_t __attribute__((__const__))
rightsFromWord(word_t w)
{
    seL4_CapRights_t seL4_CapRights;

    seL4_CapRights.words[0] = w;
    return seL4_CapRights;
}

static inline word_t __attribute__((__const__))
wordFromRights(seL4_CapRights_t seL4_CapRights)
{
    return seL4_CapRights.words[0] & ((1ul << (3))-1ul);
}

static inline cap_transfer_t __attribute__((__pure__))
capTransferFromWords(word_t *wptr)
{
    cap_transfer_t transfer;

    transfer.ctReceiveRoot = (cptr_t)wptr[0];
    transfer.ctReceiveIndex = (cptr_t)wptr[1];
    transfer.ctReceiveDepth = wptr[2];
    return transfer;
}

static inline seL4_MessageInfo_t __attribute__((__const__))
messageInfoFromWord_raw(word_t w)
{
    seL4_MessageInfo_t mi;

    mi.words[0] = w;
    return mi;
}

static inline seL4_MessageInfo_t __attribute__((__const__))
messageInfoFromWord(word_t w)
{
    seL4_MessageInfo_t mi;
    word_t len;

    mi.words[0] = w;

    len = seL4_MessageInfo_get_length(mi);
    if (len > seL4_MsgMaxLength) {
        mi = seL4_MessageInfo_set_length(mi, seL4_MsgMaxLength);
    }

    return mi;
}

static inline word_t __attribute__((__const__))
wordFromMessageInfo(seL4_MessageInfo_t mi)
{
    return mi.words[0];
}

static inline seL4_PrioProps_t __attribute__((__const__))
prioPropsFromWord(word_t w)
{
    seL4_PrioProps_t pp;
    pp.words[0] = w;

    return pp;
}
# 122 "/home/sel4/work/work2/kernel/include/api/types.h"
/*
 * thread name is only available if the kernel is built in debug mode.
 */






/*
 * Print to serial a message helping userspace programmers to determine why the
 * kernel is not performing their requested operation.
 */
# 16 "/home/sel4/work/work2/kernel/include/compound_types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/object/structures.h" 2
# 1 "./arch/object/structures_gen.h" 1



# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 5 "./arch/object/structures_gen.h" 2
# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 6 "./arch/object/structures_gen.h" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 7 "./arch/object/structures_gen.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 8 "./arch/object/structures_gen.h" 2
struct stored_hw_asid {
    uint32_t words[1];
};
typedef struct stored_hw_asid stored_hw_asid_t;

struct thread_state {
    uint32_t words[3];
};
typedef struct thread_state thread_state_t;

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_blockingIPCBadge(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[2] & 0xfffffff0ul) >> 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_blockingIPCBadge(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff0 >> 4) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff0 >> 4) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 32, __FUNCTION__);
    thread_state_ptr->words[2] &= ~0xfffffff0ul;
    thread_state_ptr->words[2] |= (v << 4) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_blockingIPCCanGrant(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[2] & 0x8ul) >> 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_blockingIPCCanGrant(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x8 >> 3) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x8 >> 3) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 51, __FUNCTION__);
    thread_state_ptr->words[2] &= ~0x8ul;
    thread_state_ptr->words[2] |= (v << 3) & 0x8;
}

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_blockingIPCIsCall(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[2] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_blockingIPCIsCall(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x4 >> 2) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x4 >> 2) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 70, __FUNCTION__);
    thread_state_ptr->words[2] &= ~0x4ul;
    thread_state_ptr->words[2] |= (v << 2) & 0x4;
}

static inline uint32_t __attribute__((__const__))
thread_state_get_tcbQueued(thread_state_t thread_state) {
    uint32_t ret;
    ret = (thread_state.words[1] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_tcbQueued(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x1 >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x1 >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 89, __FUNCTION__);
    thread_state_ptr->words[1] &= ~0x1ul;
    thread_state_ptr->words[1] |= (v << 0) & 0x1;
}

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_blockingObject(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_blockingObject(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 108, __FUNCTION__);
    thread_state_ptr->words[0] &= ~0xfffffff0ul;
    thread_state_ptr->words[0] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__const__))
thread_state_get_tsType(thread_state_t thread_state) {
    uint32_t ret;
    ret = (thread_state.words[0] & 0xful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
thread_state_ptr_get_tsType(thread_state_t *thread_state_ptr) {
    uint32_t ret;
    ret = (thread_state_ptr->words[0] & 0xful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
thread_state_ptr_set_tsType(thread_state_t *thread_state_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xf >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xf >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 138, __FUNCTION__);
    thread_state_ptr->words[0] &= ~0xful;
    thread_state_ptr->words[0] |= (v << 0) & 0xf;
}

struct notification {
    uint32_t words[4];
};
typedef struct notification notification_t;

static inline uint32_t __attribute__((__pure__))
notification_ptr_get_ntfnBoundTCB(notification_t *notification_ptr) {
    uint32_t ret;
    ret = (notification_ptr->words[3] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
notification_ptr_set_ntfnBoundTCB(notification_t *notification_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 162, __FUNCTION__);
    notification_ptr->words[3] &= ~0xfffffff0ul;
    notification_ptr->words[3] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
notification_ptr_get_ntfnMsgIdentifier(notification_t *notification_ptr) {
    uint32_t ret;
    ret = (notification_ptr->words[2] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
notification_ptr_set_ntfnMsgIdentifier(notification_t *notification_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xffffffff >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xffffffff >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 181, __FUNCTION__);
    notification_ptr->words[2] &= ~0xfffffffful;
    notification_ptr->words[2] |= (v << 0) & 0xffffffff;
}

static inline uint32_t __attribute__((__pure__))
notification_ptr_get_ntfnQueue_head(notification_t *notification_ptr) {
    uint32_t ret;
    ret = (notification_ptr->words[1] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
notification_ptr_set_ntfnQueue_head(notification_t *notification_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 200, __FUNCTION__);
    notification_ptr->words[1] &= ~0xfffffff0ul;
    notification_ptr->words[1] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
notification_ptr_get_ntfnQueue_tail(notification_t *notification_ptr) {
    uint32_t ret;
    ret = (notification_ptr->words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
notification_ptr_set_ntfnQueue_tail(notification_t *notification_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 219, __FUNCTION__);
    notification_ptr->words[0] &= ~0xfffffff0ul;
    notification_ptr->words[0] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
notification_ptr_get_state(notification_t *notification_ptr) {
    uint32_t ret;
    ret = (notification_ptr->words[0] & 0x3ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
notification_ptr_set_state(notification_t *notification_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x3 >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x3 >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 238, __FUNCTION__);
    notification_ptr->words[0] &= ~0x3ul;
    notification_ptr->words[0] |= (v << 0) & 0x3;
}

struct mdb_node {
    uint32_t words[2];
};
typedef struct mdb_node mdb_node_t;

static inline mdb_node_t __attribute__((__const__))
mdb_node_new(uint32_t mdbNext, uint32_t mdbRevocable, uint32_t mdbFirstBadged, uint32_t mdbPrev) {
    mdb_node_t mdb_node;

    /* fail if user has passed bits that we will override */
    if(!((mdbNext & ~0xfffffff8ul) == ((0 && (mdbNext & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(mdbNext & ~0xfffffff8ul) == ((0 && (mdbNext & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 253, __FUNCTION__);
    if(!((mdbRevocable & ~0x1ul) == ((0 && (mdbRevocable & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(mdbRevocable & ~0x1ul) == ((0 && (mdbRevocable & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 254, __FUNCTION__);
    if(!((mdbFirstBadged & ~0x1ul) == ((0 && (mdbFirstBadged & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(mdbFirstBadged & ~0x1ul) == ((0 && (mdbFirstBadged & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 255, __FUNCTION__);
    if(!((mdbPrev & ~0xfffffff8ul) == ((0 && (mdbPrev & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(mdbPrev & ~0xfffffff8ul) == ((0 && (mdbPrev & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 256, __FUNCTION__);

    mdb_node.words[0] = 0
        | (mdbPrev & 0xfffffff8ul) >> 0;
    mdb_node.words[1] = 0
        | (mdbNext & 0xfffffff8ul) >> 0
        | (mdbRevocable & 0x1ul) << 1
        | (mdbFirstBadged & 0x1ul) << 0;

    return mdb_node;
}

static inline uint32_t __attribute__((__const__))
mdb_node_get_mdbNext(mdb_node_t mdb_node) {
    uint32_t ret;
    ret = (mdb_node.words[1] & 0xfffffff8ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
mdb_node_ptr_set_mdbNext(mdb_node_t *mdb_node_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff8 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff8 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 282, __FUNCTION__);
    mdb_node_ptr->words[1] &= ~0xfffffff8ul;
    mdb_node_ptr->words[1] |= (v >> 0) & 0xfffffff8;
}

static inline uint32_t __attribute__((__const__))
mdb_node_get_mdbRevocable(mdb_node_t mdb_node) {
    uint32_t ret;
    ret = (mdb_node.words[1] & 0x2ul) >> 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline mdb_node_t __attribute__((__const__))
mdb_node_set_mdbRevocable(mdb_node_t mdb_node, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x2 >> 1 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x2 >> 1 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 301, __FUNCTION__);
    mdb_node.words[1] &= ~0x2ul;
    mdb_node.words[1] |= (v << 1) & 0x2ul;
    return mdb_node;
}

static inline void
mdb_node_ptr_set_mdbRevocable(mdb_node_t *mdb_node_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x2 >> 1) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x2 >> 1) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 310, __FUNCTION__);
    mdb_node_ptr->words[1] &= ~0x2ul;
    mdb_node_ptr->words[1] |= (v << 1) & 0x2;
}

static inline uint32_t __attribute__((__const__))
mdb_node_get_mdbFirstBadged(mdb_node_t mdb_node) {
    uint32_t ret;
    ret = (mdb_node.words[1] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline mdb_node_t __attribute__((__const__))
mdb_node_set_mdbFirstBadged(mdb_node_t mdb_node, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x1 >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x1 >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 329, __FUNCTION__);
    mdb_node.words[1] &= ~0x1ul;
    mdb_node.words[1] |= (v << 0) & 0x1ul;
    return mdb_node;
}

static inline void
mdb_node_ptr_set_mdbFirstBadged(mdb_node_t *mdb_node_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x1 >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x1 >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 338, __FUNCTION__);
    mdb_node_ptr->words[1] &= ~0x1ul;
    mdb_node_ptr->words[1] |= (v << 0) & 0x1;
}

static inline uint32_t __attribute__((__const__))
mdb_node_get_mdbPrev(mdb_node_t mdb_node) {
    uint32_t ret;
    ret = (mdb_node.words[0] & 0xfffffff8ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline mdb_node_t __attribute__((__const__))
mdb_node_set_mdbPrev(mdb_node_t mdb_node, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff8 << 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff8 << 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 357, __FUNCTION__);
    mdb_node.words[0] &= ~0xfffffff8ul;
    mdb_node.words[0] |= (v >> 0) & 0xfffffff8ul;
    return mdb_node;
}

static inline void
mdb_node_ptr_set_mdbPrev(mdb_node_t *mdb_node_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff8 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff8 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 366, __FUNCTION__);
    mdb_node_ptr->words[0] &= ~0xfffffff8ul;
    mdb_node_ptr->words[0] |= (v >> 0) & 0xfffffff8;
}

struct cnode_capdata {
    uint32_t words[1];
};
typedef struct cnode_capdata cnode_capdata_t;

static inline uint32_t __attribute__((__const__))
cnode_capdata_get_guard(cnode_capdata_t cnode_capdata) {
    uint32_t ret;
    ret = (cnode_capdata.words[0] & 0x3ffff00ul) >> 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cnode_capdata_get_guardSize(cnode_capdata_t cnode_capdata) {
    uint32_t ret;
    ret = (cnode_capdata.words[0] & 0xf8ul) >> 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct vm_attributes {
    uint32_t words[1];
};
typedef struct vm_attributes vm_attributes_t;

static inline vm_attributes_t __attribute__((__const__))
vm_attributes_new(uint32_t armExecuteNever, uint32_t armParityEnabled, uint32_t armPageCacheable) {
    vm_attributes_t vm_attributes;

    /* fail if user has passed bits that we will override */
    if(!((armExecuteNever & ~0x1ul) == ((0 && (armExecuteNever & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(armExecuteNever & ~0x1ul) == ((0 && (armExecuteNever & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 408, __FUNCTION__);
    if(!((armParityEnabled & ~0x1ul) == ((0 && (armParityEnabled & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(armParityEnabled & ~0x1ul) == ((0 && (armParityEnabled & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 409, __FUNCTION__);
    if(!((armPageCacheable & ~0x1ul) == ((0 && (armPageCacheable & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(armPageCacheable & ~0x1ul) == ((0 && (armPageCacheable & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 410, __FUNCTION__);

    vm_attributes.words[0] = 0
        | (armExecuteNever & 0x1ul) << 2
        | (armParityEnabled & 0x1ul) << 1
        | (armPageCacheable & 0x1ul) << 0;

    return vm_attributes;
}

static inline uint32_t __attribute__((__const__))
vm_attributes_get_armExecuteNever(vm_attributes_t vm_attributes) {
    uint32_t ret;
    ret = (vm_attributes.words[0] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
vm_attributes_get_armParityEnabled(vm_attributes_t vm_attributes) {
    uint32_t ret;
    ret = (vm_attributes.words[0] & 0x2ul) >> 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
vm_attributes_get_armPageCacheable(vm_attributes_t vm_attributes) {
    uint32_t ret;
    ret = (vm_attributes.words[0] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct endpoint {
    uint32_t words[4];
};
typedef struct endpoint endpoint_t;

static inline uint32_t __attribute__((__pure__))
endpoint_ptr_get_epQueue_head(endpoint_t *endpoint_ptr) {
    uint32_t ret;
    ret = (endpoint_ptr->words[1] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
endpoint_ptr_set_epQueue_head(endpoint_t *endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 472, __FUNCTION__);
    endpoint_ptr->words[1] &= ~0xfffffff0ul;
    endpoint_ptr->words[1] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
endpoint_ptr_get_epQueue_tail(endpoint_t *endpoint_ptr) {
    uint32_t ret;
    ret = (endpoint_ptr->words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
endpoint_ptr_set_epQueue_tail(endpoint_t *endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff0 << 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 491, __FUNCTION__);
    endpoint_ptr->words[0] &= ~0xfffffff0ul;
    endpoint_ptr->words[0] |= (v >> 0) & 0xfffffff0;
}

static inline uint32_t __attribute__((__pure__))
endpoint_ptr_get_state(endpoint_t *endpoint_ptr) {
    uint32_t ret;
    ret = (endpoint_ptr->words[0] & 0x3ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
endpoint_ptr_set_state(endpoint_t *endpoint_ptr, uint32_t v) {
    /* fail if user has passed bits that we will override */
    if(!((((~0x3 >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x3 >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 510, __FUNCTION__);
    endpoint_ptr->words[0] &= ~0x3ul;
    endpoint_ptr->words[0] |= (v << 0) & 0x3;
}

struct lookup_fault {
    uint32_t words[2];
};
typedef struct lookup_fault lookup_fault_t;

enum lookup_fault_tag {
    lookup_fault_invalid_root = 0,
    lookup_fault_missing_capability = 1,
    lookup_fault_depth_mismatch = 2,
    lookup_fault_guard_mismatch = 3
};
typedef enum lookup_fault_tag lookup_fault_tag_t;

static inline uint32_t __attribute__((__const__))
lookup_fault_get_lufType(lookup_fault_t lookup_fault) {
    return (lookup_fault.words[0] >> 0) & 0x3ul;
}

static inline lookup_fault_t __attribute__((__const__))
lookup_fault_invalid_root_new(void) {
    lookup_fault_t lookup_fault;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)lookup_fault_invalid_root & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_invalid_root & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)lookup_fault_invalid_root & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_invalid_root & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 538, __FUNCTION__);

    lookup_fault.words[0] = 0
        | ((uint32_t)lookup_fault_invalid_root & 0x3ul) << 0;
    lookup_fault.words[1] = 0;

    return lookup_fault;
}

static inline lookup_fault_t __attribute__((__const__))
lookup_fault_missing_capability_new(uint32_t bitsLeft) {
    lookup_fault_t lookup_fault;

    /* fail if user has passed bits that we will override */
    if(!((bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 552, __FUNCTION__);
    if(!(((uint32_t)lookup_fault_missing_capability & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_missing_capability & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)lookup_fault_missing_capability & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_missing_capability & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 553, __FUNCTION__);

    lookup_fault.words[0] = 0
        | (bitsLeft & 0x3ful) << 2
        | ((uint32_t)lookup_fault_missing_capability & 0x3ul) << 0;
    lookup_fault.words[1] = 0;

    return lookup_fault;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_missing_capability_get_bitsLeft(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_missing_capability)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_missing_capability",
                                          "./arch/object/structures_gen.h"
# 566 "./arch/object/structures_gen.h"
    ,
                                          567
# 566 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                           ;

    ret = (lookup_fault.words[0] & 0xfcul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline lookup_fault_t __attribute__((__const__))
lookup_fault_depth_mismatch_new(uint32_t bitsFound, uint32_t bitsLeft) {
    lookup_fault_t lookup_fault;

    /* fail if user has passed bits that we will override */
    if(!((bitsFound & ~0x3ful) == ((0 && (bitsFound & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(bitsFound & ~0x3ful) == ((0 && (bitsFound & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 582, __FUNCTION__);
    if(!((bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 583, __FUNCTION__);
    if(!(((uint32_t)lookup_fault_depth_mismatch & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_depth_mismatch & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)lookup_fault_depth_mismatch & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_depth_mismatch & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 584, __FUNCTION__);

    lookup_fault.words[0] = 0
        | (bitsFound & 0x3ful) << 8
        | (bitsLeft & 0x3ful) << 2
        | ((uint32_t)lookup_fault_depth_mismatch & 0x3ul) << 0;
    lookup_fault.words[1] = 0;

    return lookup_fault;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_depth_mismatch_get_bitsFound(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_depth_mismatch)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_depth_mismatch",
                                      "./arch/object/structures_gen.h"
# 598 "./arch/object/structures_gen.h"
    ,
                                      599
# 598 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                       ;

    ret = (lookup_fault.words[0] & 0x3f00ul) >> 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_depth_mismatch_get_bitsLeft(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_depth_mismatch)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_depth_mismatch",
                                      "./arch/object/structures_gen.h"
# 612 "./arch/object/structures_gen.h"
    ,
                                      613
# 612 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                       ;

    ret = (lookup_fault.words[0] & 0xfcul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline lookup_fault_t __attribute__((__const__))
lookup_fault_guard_mismatch_new(uint32_t guardFound, uint32_t bitsLeft, uint32_t bitsFound) {
    lookup_fault_t lookup_fault;

    /* fail if user has passed bits that we will override */
    if(!((bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(bitsLeft & ~0x3ful) == ((0 && (bitsLeft & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 628, __FUNCTION__);
    if(!((bitsFound & ~0x3ful) == ((0 && (bitsFound & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(bitsFound & ~0x3ful) == ((0 && (bitsFound & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 629, __FUNCTION__);
    if(!(((uint32_t)lookup_fault_guard_mismatch & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_guard_mismatch & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)lookup_fault_guard_mismatch & ~0x3ul) == ((0 && ((uint32_t)lookup_fault_guard_mismatch & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 630, __FUNCTION__);

    lookup_fault.words[0] = 0
        | (bitsLeft & 0x3ful) << 8
        | (bitsFound & 0x3ful) << 2
        | ((uint32_t)lookup_fault_guard_mismatch & 0x3ul) << 0;
    lookup_fault.words[1] = 0
        | guardFound << 0;

    return lookup_fault;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_guard_mismatch_get_guardFound(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch",
                                      "./arch/object/structures_gen.h"
# 645 "./arch/object/structures_gen.h"
    ,
                                      646
# 645 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                       ;

    ret = (lookup_fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_guard_mismatch_get_bitsLeft(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch",
                                      "./arch/object/structures_gen.h"
# 659 "./arch/object/structures_gen.h"
    ,
                                      660
# 659 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                       ;

    ret = (lookup_fault.words[0] & 0x3f00ul) >> 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
lookup_fault_guard_mismatch_get_bitsFound(lookup_fault_t lookup_fault) {
    uint32_t ret;
    if(!(((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch)) _assert_fail("((lookup_fault.words[0] >> 0) & 0x3) == lookup_fault_guard_mismatch",
                                      "./arch/object/structures_gen.h"
# 673 "./arch/object/structures_gen.h"
    ,
                                      674
# 673 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                       ;

    ret = (lookup_fault.words[0] & 0xfcul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct pteS1 {
    uint32_t words[2];
};
typedef struct pteS1 pteS1_t;

enum pteS1_tag {
    pteS1_pteS1_invalid = 0,
    pteS1_pteS1_small = 3
};
typedef enum pteS1_tag pteS1_tag_t;

static inline pteS1_t __attribute__((__const__))
pteS1_pteS1_small_new(uint32_t XN, uint32_t PXN, uint32_t contiguous_hint, uint32_t address, uint32_t nG, uint32_t AF, uint32_t SH, uint32_t AP, uint32_t NS, uint32_t AttrIndx) {
    pteS1_t pteS1;

    /* fail if user has passed bits that we will override */
    if(!((XN & ~0x1ul) == ((0 && (XN & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(XN & ~0x1ul) == ((0 && (XN & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 700, __FUNCTION__);
    if(!((PXN & ~0x1ul) == ((0 && (PXN & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(PXN & ~0x1ul) == ((0 && (PXN & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 701, __FUNCTION__);
    if(!((contiguous_hint & ~0x1ul) == ((0 && (contiguous_hint & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(contiguous_hint & ~0x1ul) == ((0 && (contiguous_hint & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 702, __FUNCTION__);
    if(!((address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 703, __FUNCTION__);
    if(!((nG & ~0x1ul) == ((0 && (nG & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(nG & ~0x1ul) == ((0 && (nG & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 704, __FUNCTION__);
    if(!((AF & ~0x1ul) == ((0 && (AF & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(AF & ~0x1ul) == ((0 && (AF & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 705, __FUNCTION__);
    if(!((SH & ~0x3ul) == ((0 && (SH & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(SH & ~0x3ul) == ((0 && (SH & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 706, __FUNCTION__);
    if(!((AP & ~0x3ul) == ((0 && (AP & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(AP & ~0x3ul) == ((0 && (AP & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 707, __FUNCTION__);
    if(!((NS & ~0x1ul) == ((0 && (NS & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(NS & ~0x1ul) == ((0 && (NS & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 708, __FUNCTION__);
    if(!((AttrIndx & ~0x7ul) == ((0 && (AttrIndx & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(AttrIndx & ~0x7ul) == ((0 && (AttrIndx & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 709, __FUNCTION__);
    if(!(((uint32_t)pteS1_pteS1_small & ~0x3ul) == ((0 && ((uint32_t)pteS1_pteS1_small & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pteS1_pteS1_small & ~0x3ul) == ((0 && ((uint32_t)pteS1_pteS1_small & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 710, __FUNCTION__);

    pteS1.words[0] = 0
        | (address & 0xfffff000ul) >> 0
        | (nG & 0x1ul) << 11
        | (AF & 0x1ul) << 10
        | (SH & 0x3ul) << 8
        | (AP & 0x3ul) << 6
        | (NS & 0x1ul) << 5
        | (AttrIndx & 0x7ul) << 2
        | ((uint32_t)pteS1_pteS1_small & 0x3ul) << 0;
    pteS1.words[1] = 0
        | (XN & 0x1ul) << 22
        | (PXN & 0x1ul) << 21
        | (contiguous_hint & 0x1ul) << 20;

    return pteS1;
}

struct pte {
    uint32_t words[2];
};
typedef struct pte pte_t;

enum pte_tag {
    pte_pte_invalid = 0,
    pte_pte_small = 3
};
typedef enum pte_tag pte_tag_t;

static inline uint32_t __attribute__((__const__))
pte_get_pteType(pte_t pte) {
    return (pte.words[0] >> 0) & 0x3ul;
}

static inline uint32_t __attribute__((__pure__))
pte_ptr_get_pteType(pte_t *pte_ptr) {
    return (pte_ptr->words[0] >> 0) & 0x3ul;
}

static inline pte_t __attribute__((__const__))
pte_pte_invalid_new(void) {
    pte_t pte;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)pte_pte_invalid & ~0x3ul) == ((0 && ((uint32_t)pte_pte_invalid & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pte_pte_invalid & ~0x3ul) == ((0 && ((uint32_t)pte_pte_invalid & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 755, __FUNCTION__);

    pte.words[0] = 0
        | ((uint32_t)pte_pte_invalid & 0x3ul) << 0;
    pte.words[1] = 0;

    return pte;
}

static inline pte_t __attribute__((__const__))
pte_pte_small_new(uint32_t XN, uint32_t contiguous_hint, uint32_t address, uint32_t AF, uint32_t SH, uint32_t HAP, uint32_t MemAttr) {
    pte_t pte;

    /* fail if user has passed bits that we will override */
    if(!((XN & ~0x1ul) == ((0 && (XN & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(XN & ~0x1ul) == ((0 && (XN & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 769, __FUNCTION__);
    if(!((contiguous_hint & ~0x1ul) == ((0 && (contiguous_hint & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(contiguous_hint & ~0x1ul) == ((0 && (contiguous_hint & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 770, __FUNCTION__);
    if(!((address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 771, __FUNCTION__);
    if(!((AF & ~0x1ul) == ((0 && (AF & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(AF & ~0x1ul) == ((0 && (AF & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 772, __FUNCTION__);
    if(!((SH & ~0x3ul) == ((0 && (SH & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(SH & ~0x3ul) == ((0 && (SH & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 773, __FUNCTION__);
    if(!((HAP & ~0x3ul) == ((0 && (HAP & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(HAP & ~0x3ul) == ((0 && (HAP & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 774, __FUNCTION__);
    if(!((MemAttr & ~0xful) == ((0 && (MemAttr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(MemAttr & ~0xful) == ((0 && (MemAttr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 775, __FUNCTION__);
    if(!(((uint32_t)pte_pte_small & ~0x3ul) == ((0 && ((uint32_t)pte_pte_small & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pte_pte_small & ~0x3ul) == ((0 && ((uint32_t)pte_pte_small & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 776, __FUNCTION__);

    pte.words[0] = 0
        | (address & 0xfffff000ul) >> 0
        | (AF & 0x1ul) << 10
        | (SH & 0x3ul) << 8
        | (HAP & 0x3ul) << 6
        | (MemAttr & 0xful) << 2
        | ((uint32_t)pte_pte_small & 0x3ul) << 0;
    pte.words[1] = 0
        | (XN & 0x1ul) << 22
        | (contiguous_hint & 0x1ul) << 20;

    return pte;
}

static inline uint32_t __attribute__((__const__))
pte_pte_small_get_contiguous_hint(pte_t pte) {
    uint32_t ret;
    if(!(((pte.words[0] >> 0) & 0x3) == pte_pte_small)) _assert_fail("((pte.words[0] >> 0) & 0x3) == pte_pte_small",
                        "./arch/object/structures_gen.h"
# 795 "./arch/object/structures_gen.h"
    ,
                        796
# 795 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pte.words[1] & 0x100000ul) >> 20;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pte_pte_small_ptr_get_contiguous_hint(pte_t *pte_ptr) {
    uint32_t ret;
    if(!(((pte_ptr->words[0] >> 0) & 0x3) == pte_pte_small)) _assert_fail("((pte_ptr->words[0] >> 0) & 0x3) == pte_pte_small",
                        "./arch/object/structures_gen.h"
# 809 "./arch/object/structures_gen.h"
    ,
                        810
# 809 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pte_ptr->words[1] & 0x100000ul) >> 20;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pte_pte_small_get_address(pte_t pte) {
    uint32_t ret;
    if(!(((pte.words[0] >> 0) & 0x3) == pte_pte_small)) _assert_fail("((pte.words[0] >> 0) & 0x3) == pte_pte_small",
                        "./arch/object/structures_gen.h"
# 823 "./arch/object/structures_gen.h"
    ,
                        824
# 823 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pte.words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline pte_t __attribute__((__const__))
pte_pte_small_set_address(pte_t pte, uint32_t v) {
    if(!(((pte.words[0] >> 0) & 0x3) == pte_pte_small)) _assert_fail("((pte.words[0] >> 0) & 0x3) == pte_pte_small",
                        "./arch/object/structures_gen.h"
# 836 "./arch/object/structures_gen.h"
    ,
                        837
# 836 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffff000ul << 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffff000ul << 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 839, __FUNCTION__);

    pte.words[0] &= ~0xfffff000ul;
    pte.words[0] |= (v >> 0) & 0xfffff000ul;
    return pte;
}

static inline uint32_t __attribute__((__pure__))
pte_pte_small_ptr_get_address(pte_t *pte_ptr) {
    uint32_t ret;
    if(!(((pte_ptr->words[0] >> 0) & 0x3) == pte_pte_small)) _assert_fail("((pte_ptr->words[0] >> 0) & 0x3) == pte_pte_small",
                        "./arch/object/structures_gen.h"
# 849 "./arch/object/structures_gen.h"
    ,
                        850
# 849 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pte_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pte_pte_small_get_HAP(pte_t pte) {
    uint32_t ret;
    if(!(((pte.words[0] >> 0) & 0x3) == pte_pte_small)) _assert_fail("((pte.words[0] >> 0) & 0x3) == pte_pte_small",
                        "./arch/object/structures_gen.h"
# 863 "./arch/object/structures_gen.h"
    ,
                        864
# 863 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (pte.words[0] & 0xc0ul) >> 6;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct cap {
    uint32_t words[2];
};
typedef struct cap cap_t;

enum cap_tag {
    cap_null_cap = 0,
    cap_untyped_cap = 2,
    cap_endpoint_cap = 4,
    cap_notification_cap = 6,
    cap_reply_cap = 8,
    cap_cnode_cap = 10,
    cap_thread_cap = 12,
    cap_small_frame_cap = 1,
    cap_frame_cap = 3,
    cap_asid_pool_cap = 5,
    cap_page_table_cap = 7,
    cap_page_directory_cap = 9,
    cap_asid_control_cap = 11,
    cap_irq_control_cap = 14,
    cap_irq_handler_cap = 30,
    cap_zombie_cap = 46,
    cap_domain_cap = 62,
    cap_vcpu_cap = 15
};
typedef enum cap_tag cap_tag_t;

static inline uint32_t __attribute__((__const__))
cap_get_capType(cap_t cap) {
    if ((cap.words[0] & 0xe) != 0xe)
        return (cap.words[0] >> 0) & 0xful;
    return (cap.words[0] >> 0) & 0xfful;
}

static inline int __attribute__((__const__))
cap_capType_equals(cap_t cap, uint32_t cap_type_tag) {
    if ((cap_type_tag & 0xe) != 0xe)
        return ((cap.words[0] >> 0) & 0xful) == cap_type_tag;
    return ((cap.words[0] >> 0) & 0xfful) == cap_type_tag;
}

static inline cap_t __attribute__((__const__))
cap_null_cap_new(void) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_null_cap & ~0xful) == ((0 && ((uint32_t)cap_null_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_null_cap & ~0xful) == ((0 && ((uint32_t)cap_null_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 920, __FUNCTION__);

    cap.words[0] = 0
        | ((uint32_t)cap_null_cap & 0xful) << 0;
    cap.words[1] = 0;

    return cap;
}

static inline cap_t __attribute__((__const__))
cap_untyped_cap_new(uint32_t capFreeIndex, uint32_t capIsDevice, uint32_t capBlockSize, uint32_t capPtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capFreeIndex & ~0x3fffffful) == ((0 && (capFreeIndex & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFreeIndex & ~0x3fffffful) == ((0 && (capFreeIndex & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 934, __FUNCTION__);
    if(!((capIsDevice & ~0x1ul) == ((0 && (capIsDevice & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capIsDevice & ~0x1ul) == ((0 && (capIsDevice & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 935, __FUNCTION__);
    if(!((capBlockSize & ~0x1ful) == ((0 && (capBlockSize & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capBlockSize & ~0x1ful) == ((0 && (capBlockSize & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 936, __FUNCTION__);
    if(!((capPtr & ~0xfffffff0ul) == ((0 && (capPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPtr & ~0xfffffff0ul) == ((0 && (capPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 937, __FUNCTION__);
    if(!(((uint32_t)cap_untyped_cap & ~0xful) == ((0 && ((uint32_t)cap_untyped_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_untyped_cap & ~0xful) == ((0 && ((uint32_t)cap_untyped_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 938, __FUNCTION__);

    cap.words[0] = 0
        | (capPtr & 0xfffffff0ul) >> 0
        | ((uint32_t)cap_untyped_cap & 0xful) << 0;
    cap.words[1] = 0
        | (capFreeIndex & 0x3fffffful) << 6
        | (capIsDevice & 0x1ul) << 5
        | (capBlockSize & 0x1ful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_untyped_cap_get_capFreeIndex(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_untyped_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_untyped_cap",
                          "./arch/object/structures_gen.h"
# 954 "./arch/object/structures_gen.h"
    ,
                          955
# 954 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (cap.words[1] & 0xffffffc0ul) >> 6;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_untyped_cap_set_capFreeIndex(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_untyped_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_untyped_cap",
                          "./arch/object/structures_gen.h"
# 967 "./arch/object/structures_gen.h"
    ,
                          968
# 967 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;
    /* fail if user has passed bits that we will override */
    if(!((((~0xffffffc0ul >> 6 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xffffffc0ul >> 6 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 970, __FUNCTION__);

    cap.words[1] &= ~0xffffffc0ul;
    cap.words[1] |= (v << 6) & 0xffffffc0ul;
    return cap;
}

static inline void
cap_untyped_cap_ptr_set_capFreeIndex(cap_t *cap_ptr,
                                      uint32_t v) {
    if(!(((cap_ptr->words[0] >> 0) & 0xf) == cap_untyped_cap)) _assert_fail("((cap_ptr->words[0] >> 0) & 0xf) == cap_untyped_cap",
                          "./arch/object/structures_gen.h"
# 980 "./arch/object/structures_gen.h"
    ,
                          981
# 980 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    /* fail if user has passed bits that we will override */
    if(!((((~0xffffffc0ul >> 6) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xffffffc0ul >> 6) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 984, __FUNCTION__);

    cap_ptr->words[1] &= ~0xffffffc0ul;
    cap_ptr->words[1] |= (v << 6) & 0xffffffc0ul;
}

static inline uint32_t __attribute__((__const__))
cap_untyped_cap_get_capIsDevice(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_untyped_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_untyped_cap",
                          "./arch/object/structures_gen.h"
# 993 "./arch/object/structures_gen.h"
    ,
                          994
# 993 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (cap.words[1] & 0x20ul) >> 5;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_untyped_cap_get_capBlockSize(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_untyped_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_untyped_cap",
                          "./arch/object/structures_gen.h"
# 1007 "./arch/object/structures_gen.h"
    ,
                          1008
# 1007 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (cap.words[1] & 0x1ful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_untyped_cap_get_capPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_untyped_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_untyped_cap",
                          "./arch/object/structures_gen.h"
# 1021 "./arch/object/structures_gen.h"
    ,
                          1022
# 1021 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (cap.words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_endpoint_cap_new(uint32_t capEPBadge, uint32_t capCanGrant, uint32_t capCanSend, uint32_t capCanReceive, uint32_t capEPPtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capEPBadge & ~0xffffffful) == ((0 && (capEPBadge & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capEPBadge & ~0xffffffful) == ((0 && (capEPBadge & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1037, __FUNCTION__);
    if(!((capCanGrant & ~0x1ul) == ((0 && (capCanGrant & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCanGrant & ~0x1ul) == ((0 && (capCanGrant & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1038, __FUNCTION__);
    if(!((capCanSend & ~0x1ul) == ((0 && (capCanSend & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCanSend & ~0x1ul) == ((0 && (capCanSend & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1039, __FUNCTION__);
    if(!((capCanReceive & ~0x1ul) == ((0 && (capCanReceive & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCanReceive & ~0x1ul) == ((0 && (capCanReceive & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1040, __FUNCTION__);
    if(!((capEPPtr & ~0xfffffff0ul) == ((0 && (capEPPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capEPPtr & ~0xfffffff0ul) == ((0 && (capEPPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1041, __FUNCTION__);
    if(!(((uint32_t)cap_endpoint_cap & ~0xful) == ((0 && ((uint32_t)cap_endpoint_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_endpoint_cap & ~0xful) == ((0 && ((uint32_t)cap_endpoint_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1042, __FUNCTION__);

    cap.words[0] = 0
        | (capEPBadge & 0xffffffful) << 4
        | ((uint32_t)cap_endpoint_cap & 0xful) << 0;
    cap.words[1] = 0
        | (capCanGrant & 0x1ul) << 2
        | (capCanSend & 0x1ul) << 0
        | (capCanReceive & 0x1ul) << 1
        | (capEPPtr & 0xfffffff0ul) >> 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_endpoint_cap_get_capEPPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
                           "./arch/object/structures_gen.h"
# 1059 "./arch/object/structures_gen.h"
    ,
                           1060
# 1059 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[1] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_endpoint_cap_get_capCanGrant(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
                           "./arch/object/structures_gen.h"
# 1073 "./arch/object/structures_gen.h"
    ,
                           1074
# 1073 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[1] & 0x4ul) >> 2;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_endpoint_cap_set_capCanGrant(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
                           "./arch/object/structures_gen.h"
# 1086 "./arch/object/structures_gen.h"
    ,
                           1087
# 1086 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x4ul >> 2 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x4ul >> 2 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1089, __FUNCTION__);

    cap.words[1] &= ~0x4ul;
    cap.words[1] |= (v << 2) & 0x4ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_endpoint_cap_get_capCanReceive(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
                           "./arch/object/structures_gen.h"
# 1099 "./arch/object/structures_gen.h"
    ,
                           1100
# 1099 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[1] & 0x2ul) >> 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_endpoint_cap_set_capCanReceive(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
                           "./arch/object/structures_gen.h"
# 1112 "./arch/object/structures_gen.h"
    ,
                           1113
# 1112 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x2ul >> 1 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x2ul >> 1 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1115, __FUNCTION__);

    cap.words[1] &= ~0x2ul;
    cap.words[1] |= (v << 1) & 0x2ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_endpoint_cap_get_capCanSend(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
                           "./arch/object/structures_gen.h"
# 1125 "./arch/object/structures_gen.h"
    ,
                           1126
# 1125 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[1] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_endpoint_cap_set_capCanSend(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
                           "./arch/object/structures_gen.h"
# 1138 "./arch/object/structures_gen.h"
    ,
                           1139
# 1138 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x1ul >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x1ul >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1141, __FUNCTION__);

    cap.words[1] &= ~0x1ul;
    cap.words[1] |= (v << 0) & 0x1ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_endpoint_cap_get_capEPBadge(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
                           "./arch/object/structures_gen.h"
# 1151 "./arch/object/structures_gen.h"
    ,
                           1152
# 1151 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;

    ret = (cap.words[0] & 0xfffffff0ul) >> 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_endpoint_cap_set_capEPBadge(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_endpoint_cap",
                           "./arch/object/structures_gen.h"
# 1164 "./arch/object/structures_gen.h"
    ,
                           1165
# 1164 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff0ul >> 4 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff0ul >> 4 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1167, __FUNCTION__);

    cap.words[0] &= ~0xfffffff0ul;
    cap.words[0] |= (v << 4) & 0xfffffff0ul;
    return cap;
}

static inline cap_t __attribute__((__const__))
cap_notification_cap_new(uint32_t capNtfnBadge, uint32_t capNtfnCanReceive, uint32_t capNtfnCanSend, uint32_t capNtfnPtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capNtfnBadge & ~0xffffffful) == ((0 && (capNtfnBadge & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capNtfnBadge & ~0xffffffful) == ((0 && (capNtfnBadge & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1179, __FUNCTION__);
    if(!((capNtfnCanReceive & ~0x1ul) == ((0 && (capNtfnCanReceive & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capNtfnCanReceive & ~0x1ul) == ((0 && (capNtfnCanReceive & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1180, __FUNCTION__);
    if(!((capNtfnCanSend & ~0x1ul) == ((0 && (capNtfnCanSend & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capNtfnCanSend & ~0x1ul) == ((0 && (capNtfnCanSend & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1181, __FUNCTION__);
    if(!((capNtfnPtr & ~0xfffffff0ul) == ((0 && (capNtfnPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capNtfnPtr & ~0xfffffff0ul) == ((0 && (capNtfnPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1182, __FUNCTION__);
    if(!(((uint32_t)cap_notification_cap & ~0xful) == ((0 && ((uint32_t)cap_notification_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_notification_cap & ~0xful) == ((0 && ((uint32_t)cap_notification_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1183, __FUNCTION__);

    cap.words[0] = 0
        | (capNtfnPtr & 0xfffffff0ul) >> 0
        | ((uint32_t)cap_notification_cap & 0xful) << 0;
    cap.words[1] = 0
        | (capNtfnBadge & 0xffffffful) << 4
        | (capNtfnCanReceive & 0x1ul) << 1
        | (capNtfnCanSend & 0x1ul) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_notification_cap_get_capNtfnBadge(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_notification_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_notification_cap",
                               "./arch/object/structures_gen.h"
# 1199 "./arch/object/structures_gen.h"
    ,
                               1200
# 1199 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                ;

    ret = (cap.words[1] & 0xfffffff0ul) >> 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_notification_cap_set_capNtfnBadge(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_notification_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_notification_cap",
                               "./arch/object/structures_gen.h"
# 1212 "./arch/object/structures_gen.h"
    ,
                               1213
# 1212 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                ;
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffff0ul >> 4 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffff0ul >> 4 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1215, __FUNCTION__);

    cap.words[1] &= ~0xfffffff0ul;
    cap.words[1] |= (v << 4) & 0xfffffff0ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_notification_cap_get_capNtfnCanReceive(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_notification_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_notification_cap",
                               "./arch/object/structures_gen.h"
# 1225 "./arch/object/structures_gen.h"
    ,
                               1226
# 1225 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                ;

    ret = (cap.words[1] & 0x2ul) >> 1;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_notification_cap_set_capNtfnCanReceive(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_notification_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_notification_cap",
                               "./arch/object/structures_gen.h"
# 1238 "./arch/object/structures_gen.h"
    ,
                               1239
# 1238 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x2ul >> 1 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x2ul >> 1 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1241, __FUNCTION__);

    cap.words[1] &= ~0x2ul;
    cap.words[1] |= (v << 1) & 0x2ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_notification_cap_get_capNtfnCanSend(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_notification_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_notification_cap",
                               "./arch/object/structures_gen.h"
# 1251 "./arch/object/structures_gen.h"
    ,
                               1252
# 1251 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                ;

    ret = (cap.words[1] & 0x1ul) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_notification_cap_set_capNtfnCanSend(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_notification_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_notification_cap",
                               "./arch/object/structures_gen.h"
# 1264 "./arch/object/structures_gen.h"
    ,
                               1265
# 1264 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x1ul >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x1ul >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1267, __FUNCTION__);

    cap.words[1] &= ~0x1ul;
    cap.words[1] |= (v << 0) & 0x1ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_notification_cap_get_capNtfnPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_notification_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_notification_cap",
                               "./arch/object/structures_gen.h"
# 1277 "./arch/object/structures_gen.h"
    ,
                               1278
# 1277 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                ;

    ret = (cap.words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_reply_cap_new(uint32_t capReplyMaster, uint32_t capTCBPtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capReplyMaster & ~0x1ul) == ((0 && (capReplyMaster & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capReplyMaster & ~0x1ul) == ((0 && (capReplyMaster & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1293, __FUNCTION__);
    if(!((capTCBPtr & ~0xffffffe0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capTCBPtr & ~0xffffffe0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1294, __FUNCTION__);
    if(!(((uint32_t)cap_reply_cap & ~0xful) == ((0 && ((uint32_t)cap_reply_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_reply_cap & ~0xful) == ((0 && ((uint32_t)cap_reply_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1295, __FUNCTION__);

    cap.words[0] = 0
        | (capReplyMaster & 0x1ul) << 4
        | (capTCBPtr & 0xffffffe0ul) >> 0
        | ((uint32_t)cap_reply_cap & 0xful) << 0;
    cap.words[1] = 0;

    return cap;
}

static inline void
cap_reply_cap_ptr_new(cap_t *cap_ptr, uint32_t capReplyMaster, uint32_t capTCBPtr) {
    /* fail if user has passed bits that we will override */
    if(!((capReplyMaster & ~0x1ul) == ((0 && (capReplyMaster & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capReplyMaster & ~0x1ul) == ((0 && (capReplyMaster & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1309, __FUNCTION__);
    if(!((capTCBPtr & ~0xffffffe0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capTCBPtr & ~0xffffffe0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1310, __FUNCTION__);
    if(!(((uint32_t)cap_reply_cap & ~0xful) == ((0 && ((uint32_t)cap_reply_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_reply_cap & ~0xful) == ((0 && ((uint32_t)cap_reply_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1311, __FUNCTION__);

    cap_ptr->words[0] = 0
        | (capReplyMaster & 0x1ul) << 4
        | (capTCBPtr & 0xffffffe0ul) >> 0
        | ((uint32_t)cap_reply_cap & 0xful) << 0;
    cap_ptr->words[1] = 0;
}

static inline uint32_t __attribute__((__const__))
cap_reply_cap_get_capTCBPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_reply_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_reply_cap",
                        "./arch/object/structures_gen.h"
# 1323 "./arch/object/structures_gen.h"
    ,
                        1324
# 1323 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0xffffffe0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_reply_cap_get_capReplyMaster(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_reply_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_reply_cap",
                        "./arch/object/structures_gen.h"
# 1337 "./arch/object/structures_gen.h"
    ,
                        1338
# 1337 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0x10ul) >> 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_cnode_cap_new(uint32_t capCNodeRadix, uint32_t capCNodeGuardSize, uint32_t capCNodeGuard, uint32_t capCNodePtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capCNodeRadix & ~0x1ful) == ((0 && (capCNodeRadix & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCNodeRadix & ~0x1ful) == ((0 && (capCNodeRadix & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1353, __FUNCTION__);
    if(!((capCNodeGuardSize & ~0x1ful) == ((0 && (capCNodeGuardSize & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCNodeGuardSize & ~0x1ful) == ((0 && (capCNodeGuardSize & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1354, __FUNCTION__);
    if(!((capCNodeGuard & ~0x3fffful) == ((0 && (capCNodeGuard & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCNodeGuard & ~0x3fffful) == ((0 && (capCNodeGuard & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1355, __FUNCTION__);
    if(!((capCNodePtr & ~0xffffffe0ul) == ((0 && (capCNodePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capCNodePtr & ~0xffffffe0ul) == ((0 && (capCNodePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1356, __FUNCTION__);
    if(!(((uint32_t)cap_cnode_cap & ~0xful) == ((0 && ((uint32_t)cap_cnode_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_cnode_cap & ~0xful) == ((0 && ((uint32_t)cap_cnode_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1357, __FUNCTION__);

    cap.words[0] = 0
        | (capCNodePtr & 0xffffffe0ul) >> 0
        | ((uint32_t)cap_cnode_cap & 0xful) << 0;
    cap.words[1] = 0
        | (capCNodeRadix & 0x1ful) << 18
        | (capCNodeGuardSize & 0x1ful) << 23
        | (capCNodeGuard & 0x3fffful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_cnode_cap_get_capCNodeGuardSize(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
                        "./arch/object/structures_gen.h"
# 1373 "./arch/object/structures_gen.h"
    ,
                        1374
# 1373 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0xf800000ul) >> 23;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_cnode_cap_set_capCNodeGuardSize(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
                        "./arch/object/structures_gen.h"
# 1386 "./arch/object/structures_gen.h"
    ,
                        1387
# 1386 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!((((~0xf800000ul >> 23 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xf800000ul >> 23 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1389, __FUNCTION__);

    cap.words[1] &= ~0xf800000ul;
    cap.words[1] |= (v << 23) & 0xf800000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_cnode_cap_get_capCNodeRadix(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
                        "./arch/object/structures_gen.h"
# 1399 "./arch/object/structures_gen.h"
    ,
                        1400
# 1399 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0x7c0000ul) >> 18;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_cnode_cap_get_capCNodeGuard(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
                        "./arch/object/structures_gen.h"
# 1413 "./arch/object/structures_gen.h"
    ,
                        1414
# 1413 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0x3fffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_cnode_cap_set_capCNodeGuard(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
                        "./arch/object/structures_gen.h"
# 1426 "./arch/object/structures_gen.h"
    ,
                        1427
# 1426 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x3fffful >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x3fffful >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1429, __FUNCTION__);

    cap.words[1] &= ~0x3fffful;
    cap.words[1] |= (v << 0) & 0x3fffful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_cnode_cap_get_capCNodePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_cnode_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_cnode_cap",
                        "./arch/object/structures_gen.h"
# 1439 "./arch/object/structures_gen.h"
    ,
                        1440
# 1439 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0xffffffe0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_thread_cap_new(uint32_t capTCBPtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capTCBPtr & ~0xfffffff0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capTCBPtr & ~0xfffffff0ul) == ((0 && (capTCBPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1455, __FUNCTION__);
    if(!(((uint32_t)cap_thread_cap & ~0xful) == ((0 && ((uint32_t)cap_thread_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_thread_cap & ~0xful) == ((0 && ((uint32_t)cap_thread_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1456, __FUNCTION__);

    cap.words[0] = 0
        | (capTCBPtr & 0xfffffff0ul) >> 0
        | ((uint32_t)cap_thread_cap & 0xful) << 0;
    cap.words[1] = 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_thread_cap_get_capTCBPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_thread_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_thread_cap",
                         "./arch/object/structures_gen.h"
# 1469 "./arch/object/structures_gen.h"
    ,
                         1470
# 1469 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (cap.words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_small_frame_cap_new(uint32_t capFMappedASIDLow, uint32_t capFVMRights, uint32_t capFMappedAddress, uint32_t capFIsDevice, uint32_t capFMappedASIDHigh, uint32_t capFBasePtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capFMappedASIDLow & ~0x3fful) == ((0 && (capFMappedASIDLow & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFMappedASIDLow & ~0x3fful) == ((0 && (capFMappedASIDLow & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1485, __FUNCTION__);
    if(!((capFVMRights & ~0x3ul) == ((0 && (capFVMRights & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFVMRights & ~0x3ul) == ((0 && (capFVMRights & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1486, __FUNCTION__);
    if(!((capFMappedAddress & ~0xfffff000ul) == ((0 && (capFMappedAddress & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFMappedAddress & ~0xfffff000ul) == ((0 && (capFMappedAddress & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1487, __FUNCTION__);
    if(!((capFIsDevice & ~0x1ul) == ((0 && (capFIsDevice & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFIsDevice & ~0x1ul) == ((0 && (capFIsDevice & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1488, __FUNCTION__);
    if(!((capFMappedASIDHigh & ~0x7ful) == ((0 && (capFMappedASIDHigh & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFMappedASIDHigh & ~0x7ful) == ((0 && (capFMappedASIDHigh & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1489, __FUNCTION__);
    if(!((capFBasePtr & ~0xfffff000ul) == ((0 && (capFBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFBasePtr & ~0xfffff000ul) == ((0 && (capFBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1490, __FUNCTION__);
    if(!(((uint32_t)cap_small_frame_cap & ~0xful) == ((0 && ((uint32_t)cap_small_frame_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_small_frame_cap & ~0xful) == ((0 && ((uint32_t)cap_small_frame_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1491, __FUNCTION__);

    cap.words[0] = 0
        | (capFIsDevice & 0x1ul) << 31
        | (capFMappedASIDHigh & 0x7ful) << 24
        | (capFBasePtr & 0xfffff000ul) >> 8
        | ((uint32_t)cap_small_frame_cap & 0xful) << 0;
    cap.words[1] = 0
        | (capFMappedASIDLow & 0x3fful) << 22
        | (capFVMRights & 0x3ul) << 20
        | (capFMappedAddress & 0xfffff000ul) >> 12;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_small_frame_cap_get_capFMappedASIDLow(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap",
                              "./arch/object/structures_gen.h"
# 1509 "./arch/object/structures_gen.h"
    ,
                              1510
# 1509 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;

    ret = (cap.words[1] & 0xffc00000ul) >> 22;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_small_frame_cap_set_capFMappedASIDLow(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap",
                              "./arch/object/structures_gen.h"
# 1522 "./arch/object/structures_gen.h"
    ,
                              1523
# 1522 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;
    /* fail if user has passed bits that we will override */
    if(!((((~0xffc00000ul >> 22 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xffc00000ul >> 22 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1525, __FUNCTION__);

    cap.words[1] &= ~0xffc00000ul;
    cap.words[1] |= (v << 22) & 0xffc00000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_small_frame_cap_get_capFVMRights(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap",
                              "./arch/object/structures_gen.h"
# 1535 "./arch/object/structures_gen.h"
    ,
                              1536
# 1535 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;

    ret = (cap.words[1] & 0x300000ul) >> 20;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_small_frame_cap_set_capFVMRights(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap",
                              "./arch/object/structures_gen.h"
# 1548 "./arch/object/structures_gen.h"
    ,
                              1549
# 1548 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x300000ul >> 20 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x300000ul >> 20 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1551, __FUNCTION__);

    cap.words[1] &= ~0x300000ul;
    cap.words[1] |= (v << 20) & 0x300000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_small_frame_cap_get_capFMappedAddress(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap",
                              "./arch/object/structures_gen.h"
# 1561 "./arch/object/structures_gen.h"
    ,
                              1562
# 1561 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;

    ret = (cap.words[1] & 0xffffful) << 12;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_small_frame_cap_set_capFMappedAddress(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap",
                              "./arch/object/structures_gen.h"
# 1574 "./arch/object/structures_gen.h"
    ,
                              1575
# 1574 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;
    /* fail if user has passed bits that we will override */
    if(!((((~0xffffful << 12 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xffffful << 12 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1577, __FUNCTION__);

    cap.words[1] &= ~0xffffful;
    cap.words[1] |= (v >> 12) & 0xffffful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_small_frame_cap_get_capFIsDevice(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap",
                              "./arch/object/structures_gen.h"
# 1587 "./arch/object/structures_gen.h"
    ,
                              1588
# 1587 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;

    ret = (cap.words[0] & 0x80000000ul) >> 31;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_small_frame_cap_get_capFMappedASIDHigh(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap",
                              "./arch/object/structures_gen.h"
# 1601 "./arch/object/structures_gen.h"
    ,
                              1602
# 1601 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;

    ret = (cap.words[0] & 0x7f000000ul) >> 24;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_small_frame_cap_set_capFMappedASIDHigh(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap",
                              "./arch/object/structures_gen.h"
# 1614 "./arch/object/structures_gen.h"
    ,
                              1615
# 1614 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x7f000000ul >> 24 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x7f000000ul >> 24 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1617, __FUNCTION__);

    cap.words[0] &= ~0x7f000000ul;
    cap.words[0] |= (v << 24) & 0x7f000000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_small_frame_cap_get_capFBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_small_frame_cap",
                              "./arch/object/structures_gen.h"
# 1627 "./arch/object/structures_gen.h"
    ,
                              1628
# 1627 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;

    ret = (cap.words[0] & 0xfffff0ul) << 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_new(uint32_t capFSize, uint32_t capFMappedASIDLow, uint32_t capFVMRights, uint32_t capFMappedAddress, uint32_t capFIsDevice, uint32_t capFMappedASIDHigh, uint32_t capFBasePtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capFSize & ~0x3ul) == ((0 && (capFSize & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFSize & ~0x3ul) == ((0 && (capFSize & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1643, __FUNCTION__);
    if(!((capFMappedASIDLow & ~0x3fful) == ((0 && (capFMappedASIDLow & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFMappedASIDLow & ~0x3fful) == ((0 && (capFMappedASIDLow & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1644, __FUNCTION__);
    if(!((capFVMRights & ~0x3ul) == ((0 && (capFVMRights & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFVMRights & ~0x3ul) == ((0 && (capFVMRights & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1645, __FUNCTION__);
    if(!((capFMappedAddress & ~0xffffc000ul) == ((0 && (capFMappedAddress & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFMappedAddress & ~0xffffc000ul) == ((0 && (capFMappedAddress & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1646, __FUNCTION__);
    if(!((capFIsDevice & ~0x1ul) == ((0 && (capFIsDevice & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFIsDevice & ~0x1ul) == ((0 && (capFIsDevice & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1647, __FUNCTION__);
    if(!((capFMappedASIDHigh & ~0x7ful) == ((0 && (capFMappedASIDHigh & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFMappedASIDHigh & ~0x7ful) == ((0 && (capFMappedASIDHigh & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1648, __FUNCTION__);
    if(!((capFBasePtr & ~0xffffc000ul) == ((0 && (capFBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capFBasePtr & ~0xffffc000ul) == ((0 && (capFBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1649, __FUNCTION__);
    if(!(((uint32_t)cap_frame_cap & ~0xful) == ((0 && ((uint32_t)cap_frame_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_frame_cap & ~0xful) == ((0 && ((uint32_t)cap_frame_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1650, __FUNCTION__);

    cap.words[0] = 0
        | (capFIsDevice & 0x1ul) << 29
        | (capFMappedASIDHigh & 0x7ful) << 22
        | (capFBasePtr & 0xffffc000ul) >> 10
        | ((uint32_t)cap_frame_cap & 0xful) << 0;
    cap.words[1] = 0
        | (capFSize & 0x3ul) << 30
        | (capFMappedASIDLow & 0x3fful) << 20
        | (capFVMRights & 0x3ul) << 18
        | (capFMappedAddress & 0xffffc000ul) >> 14;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFSize(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1669 "./arch/object/structures_gen.h"
    ,
                        1670
# 1669 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0xc0000000ul) >> 30;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFMappedASIDLow(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1683 "./arch/object/structures_gen.h"
    ,
                        1684
# 1683 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0x3ff00000ul) >> 20;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_set_capFMappedASIDLow(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1696 "./arch/object/structures_gen.h"
    ,
                        1697
# 1696 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x3ff00000ul >> 20 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x3ff00000ul >> 20 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1699, __FUNCTION__);

    cap.words[1] &= ~0x3ff00000ul;
    cap.words[1] |= (v << 20) & 0x3ff00000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFVMRights(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1709 "./arch/object/structures_gen.h"
    ,
                        1710
# 1709 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0xc0000ul) >> 18;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_set_capFVMRights(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1722 "./arch/object/structures_gen.h"
    ,
                        1723
# 1722 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!((((~0xc0000ul >> 18 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xc0000ul >> 18 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1725, __FUNCTION__);

    cap.words[1] &= ~0xc0000ul;
    cap.words[1] |= (v << 18) & 0xc0000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFMappedAddress(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1735 "./arch/object/structures_gen.h"
    ,
                        1736
# 1735 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[1] & 0x3fffful) << 14;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_set_capFMappedAddress(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1748 "./arch/object/structures_gen.h"
    ,
                        1749
# 1748 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x3fffful << 14 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x3fffful << 14 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1751, __FUNCTION__);

    cap.words[1] &= ~0x3fffful;
    cap.words[1] |= (v >> 14) & 0x3fffful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFIsDevice(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1761 "./arch/object/structures_gen.h"
    ,
                        1762
# 1761 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0x20000000ul) >> 29;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFMappedASIDHigh(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1775 "./arch/object/structures_gen.h"
    ,
                        1776
# 1775 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0x1fc00000ul) >> 22;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_set_capFMappedASIDHigh(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1788 "./arch/object/structures_gen.h"
    ,
                        1789
# 1788 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x1fc00000ul >> 22 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x1fc00000ul >> 22 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1791, __FUNCTION__);

    cap.words[0] &= ~0x1fc00000ul;
    cap.words[0] |= (v << 22) & 0x1fc00000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_frame_cap_get_capFBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_frame_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_frame_cap",
                        "./arch/object/structures_gen.h"
# 1801 "./arch/object/structures_gen.h"
    ,
                        1802
# 1801 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                         ;

    ret = (cap.words[0] & 0x3ffff0ul) << 10;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_asid_pool_cap_new(uint32_t capASIDBase, uint32_t capASIDPool) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capASIDBase & ~0x1fffful) == ((0 && (capASIDBase & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capASIDBase & ~0x1fffful) == ((0 && (capASIDBase & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1817, __FUNCTION__);
    if(!((capASIDPool & ~0xfffffff0ul) == ((0 && (capASIDPool & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capASIDPool & ~0xfffffff0ul) == ((0 && (capASIDPool & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1818, __FUNCTION__);
    if(!(((uint32_t)cap_asid_pool_cap & ~0xful) == ((0 && ((uint32_t)cap_asid_pool_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_asid_pool_cap & ~0xful) == ((0 && ((uint32_t)cap_asid_pool_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1819, __FUNCTION__);

    cap.words[0] = 0
        | (capASIDPool & 0xfffffff0ul) >> 0
        | ((uint32_t)cap_asid_pool_cap & 0xful) << 0;
    cap.words[1] = 0
        | (capASIDBase & 0x1fffful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_asid_pool_cap_get_capASIDBase(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_asid_pool_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_asid_pool_cap",
                            "./arch/object/structures_gen.h"
# 1833 "./arch/object/structures_gen.h"
    ,
                            1834
# 1833 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                             ;

    ret = (cap.words[1] & 0x1fffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_asid_pool_cap_get_capASIDPool(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_asid_pool_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_asid_pool_cap",
                            "./arch/object/structures_gen.h"
# 1847 "./arch/object/structures_gen.h"
    ,
                            1848
# 1847 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                             ;

    ret = (cap.words[0] & 0xfffffff0ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_table_cap_new(uint32_t capPTIsMapped, uint32_t capPTMappedASID, uint32_t capPTMappedAddress, uint32_t capPTBasePtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capPTIsMapped & ~0x1ul) == ((0 && (capPTIsMapped & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPTIsMapped & ~0x1ul) == ((0 && (capPTIsMapped & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1863, __FUNCTION__);
    if(!((capPTMappedASID & ~0x1fffful) == ((0 && (capPTMappedASID & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPTMappedASID & ~0x1fffful) == ((0 && (capPTMappedASID & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1864, __FUNCTION__);
    if(!((capPTMappedAddress & ~0xffe00000ul) == ((0 && (capPTMappedAddress & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPTMappedAddress & ~0xffe00000ul) == ((0 && (capPTMappedAddress & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1865, __FUNCTION__);
    if(!((capPTBasePtr & ~0xfffffc00ul) == ((0 && (capPTBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPTBasePtr & ~0xfffffc00ul) == ((0 && (capPTBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1866, __FUNCTION__);
    if(!(((uint32_t)cap_page_table_cap & ~0xful) == ((0 && ((uint32_t)cap_page_table_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_page_table_cap & ~0xful) == ((0 && ((uint32_t)cap_page_table_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1867, __FUNCTION__);

    cap.words[0] = 0
        | (capPTBasePtr & 0xfffffc00ul) >> 0
        | ((uint32_t)cap_page_table_cap & 0xful) << 0;
    cap.words[1] = 0
        | (capPTIsMapped & 0x1ul) << 29
        | (capPTMappedASID & 0x1fffful) << 12
        | (capPTMappedAddress & 0xffe00000ul) >> 21;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_page_table_cap_get_capPTIsMapped(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
                             "./arch/object/structures_gen.h"
# 1883 "./arch/object/structures_gen.h"
    ,
                             1884
# 1883 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (cap.words[1] & 0x20000000ul) >> 29;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_table_cap_set_capPTIsMapped(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
                             "./arch/object/structures_gen.h"
# 1896 "./arch/object/structures_gen.h"
    ,
                             1897
# 1896 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x20000000ul >> 29 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x20000000ul >> 29 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1899, __FUNCTION__);

    cap.words[1] &= ~0x20000000ul;
    cap.words[1] |= (v << 29) & 0x20000000ul;
    return cap;
}

static inline void
cap_page_table_cap_ptr_set_capPTIsMapped(cap_t *cap_ptr,
                                      uint32_t v) {
    if(!(((cap_ptr->words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap_ptr->words[0] >> 0) & 0xf) == cap_page_table_cap",
                             "./arch/object/structures_gen.h"
# 1909 "./arch/object/structures_gen.h"
    ,
                             1910
# 1909 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    /* fail if user has passed bits that we will override */
    if(!((((~0x20000000ul >> 29) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x20000000ul >> 29) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1913, __FUNCTION__);

    cap_ptr->words[1] &= ~0x20000000ul;
    cap_ptr->words[1] |= (v << 29) & 0x20000000ul;
}

static inline uint32_t __attribute__((__const__))
cap_page_table_cap_get_capPTMappedASID(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
                             "./arch/object/structures_gen.h"
# 1922 "./arch/object/structures_gen.h"
    ,
                             1923
# 1922 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (cap.words[1] & 0x1ffff000ul) >> 12;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_table_cap_set_capPTMappedASID(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
                             "./arch/object/structures_gen.h"
# 1935 "./arch/object/structures_gen.h"
    ,
                             1936
# 1935 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x1ffff000ul >> 12 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x1ffff000ul >> 12 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1938, __FUNCTION__);

    cap.words[1] &= ~0x1ffff000ul;
    cap.words[1] |= (v << 12) & 0x1ffff000ul;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_page_table_cap_get_capPTMappedAddress(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
                             "./arch/object/structures_gen.h"
# 1948 "./arch/object/structures_gen.h"
    ,
                             1949
# 1948 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (cap.words[1] & 0x7fful) << 21;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_table_cap_set_capPTMappedAddress(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
                             "./arch/object/structures_gen.h"
# 1961 "./arch/object/structures_gen.h"
    ,
                             1962
# 1961 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x7fful << 21 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x7fful << 21 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1964, __FUNCTION__);

    cap.words[1] &= ~0x7fful;
    cap.words[1] |= (v >> 21) & 0x7fful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_page_table_cap_get_capPTBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_table_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_table_cap",
                             "./arch/object/structures_gen.h"
# 1974 "./arch/object/structures_gen.h"
    ,
                             1975
# 1974 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (cap.words[0] & 0xfffffc00ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_page_directory_cap_new(uint32_t capPDMappedASID, uint32_t capPDIsMapped, uint32_t capPDBasePtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capPDMappedASID & ~0x1fffful) == ((0 && (capPDMappedASID & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDMappedASID & ~0x1fffful) == ((0 && (capPDMappedASID & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1990, __FUNCTION__);
    if(!((capPDIsMapped & ~0x1ul) == ((0 && (capPDIsMapped & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDIsMapped & ~0x1ul) == ((0 && (capPDIsMapped & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1991, __FUNCTION__);
    if(!((capPDBasePtr & ~0xffffc000ul) == ((0 && (capPDBasePtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capPDBasePtr & ~0xffffc000ul) == ((0 && (capPDBasePtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1992, __FUNCTION__);
    if(!(((uint32_t)cap_page_directory_cap & ~0xful) == ((0 && ((uint32_t)cap_page_directory_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_page_directory_cap & ~0xful) == ((0 && ((uint32_t)cap_page_directory_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 1993, __FUNCTION__);

    cap.words[0] = 0
        | (capPDIsMapped & 0x1ul) << 4
        | (capPDBasePtr & 0xffffc000ul) >> 0
        | ((uint32_t)cap_page_directory_cap & 0xful) << 0;
    cap.words[1] = 0
        | (capPDMappedASID & 0x1fffful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_page_directory_cap_get_capPDMappedASID(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap",
                                 "./arch/object/structures_gen.h"
# 2008 "./arch/object/structures_gen.h"
    ,
                                 2009
# 2008 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[1] & 0x1fffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
cap_page_directory_cap_ptr_set_capPDMappedASID(cap_t *cap_ptr,
                                      uint32_t v) {
    if(!(((cap_ptr->words[0] >> 0) & 0xf) == cap_page_directory_cap)) _assert_fail("((cap_ptr->words[0] >> 0) & 0xf) == cap_page_directory_cap",
                                 "./arch/object/structures_gen.h"
# 2022 "./arch/object/structures_gen.h"
    ,
                                 2023
# 2022 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    /* fail if user has passed bits that we will override */
    if(!((((~0x1fffful >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x1fffful >> 0) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2026, __FUNCTION__);

    cap_ptr->words[1] &= ~0x1fffful;
    cap_ptr->words[1] |= (v << 0) & 0x1fffful;
}

static inline uint32_t __attribute__((__const__))
cap_page_directory_cap_get_capPDBasePtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap",
                                 "./arch/object/structures_gen.h"
# 2035 "./arch/object/structures_gen.h"
    ,
                                 2036
# 2035 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[0] & 0xffffc000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
cap_page_directory_cap_get_capPDIsMapped(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap)) _assert_fail("((cap.words[0] >> 0) & 0xf) == cap_page_directory_cap",
                                 "./arch/object/structures_gen.h"
# 2049 "./arch/object/structures_gen.h"
    ,
                                 2050
# 2049 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    ret = (cap.words[0] & 0x10ul) >> 4;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline void
cap_page_directory_cap_ptr_set_capPDIsMapped(cap_t *cap_ptr,
                                      uint32_t v) {
    if(!(((cap_ptr->words[0] >> 0) & 0xf) == cap_page_directory_cap)) _assert_fail("((cap_ptr->words[0] >> 0) & 0xf) == cap_page_directory_cap",
                                 "./arch/object/structures_gen.h"
# 2063 "./arch/object/structures_gen.h"
    ,
                                 2064
# 2063 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                  ;

    /* fail if user has passed bits that we will override */
    if(!((((~0x10ul >> 4) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x10ul >> 4) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2067, __FUNCTION__);

    cap_ptr->words[0] &= ~0x10ul;
    cap_ptr->words[0] |= (v << 4) & 0x10ul;
}

static inline cap_t __attribute__((__const__))
cap_asid_control_cap_new(void) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_asid_control_cap & ~0xful) == ((0 && ((uint32_t)cap_asid_control_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_asid_control_cap & ~0xful) == ((0 && ((uint32_t)cap_asid_control_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2078, __FUNCTION__);

    cap.words[0] = 0
        | ((uint32_t)cap_asid_control_cap & 0xful) << 0;
    cap.words[1] = 0;

    return cap;
}

static inline cap_t __attribute__((__const__))
cap_irq_control_cap_new(void) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_irq_control_cap & ~0xfful) == ((0 && ((uint32_t)cap_irq_control_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_irq_control_cap & ~0xfful) == ((0 && ((uint32_t)cap_irq_control_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2092, __FUNCTION__);

    cap.words[0] = 0
        | ((uint32_t)cap_irq_control_cap & 0xfful) << 0;
    cap.words[1] = 0;

    return cap;
}

static inline cap_t __attribute__((__const__))
cap_irq_handler_cap_new(uint32_t capIRQ) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capIRQ & ~0xfful) == ((0 && (capIRQ & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capIRQ & ~0xfful) == ((0 && (capIRQ & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2106, __FUNCTION__);
    if(!(((uint32_t)cap_irq_handler_cap & ~0xfful) == ((0 && ((uint32_t)cap_irq_handler_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_irq_handler_cap & ~0xfful) == ((0 && ((uint32_t)cap_irq_handler_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2107, __FUNCTION__);

    cap.words[0] = 0
        | ((uint32_t)cap_irq_handler_cap & 0xfful) << 0;
    cap.words[1] = 0
        | (capIRQ & 0xfful) << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_irq_handler_cap_get_capIRQ(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_irq_handler_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_irq_handler_cap",
                              "./arch/object/structures_gen.h"
# 2120 "./arch/object/structures_gen.h"
    ,
                              2121
# 2120 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;

    ret = (cap.words[1] & 0xfful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_zombie_cap_new(uint32_t capZombieID, uint32_t capZombieType) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capZombieType & ~0x3ful) == ((0 && (capZombieType & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capZombieType & ~0x3ful) == ((0 && (capZombieType & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2136, __FUNCTION__);
    if(!(((uint32_t)cap_zombie_cap & ~0xfful) == ((0 && ((uint32_t)cap_zombie_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_zombie_cap & ~0xfful) == ((0 && ((uint32_t)cap_zombie_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2137, __FUNCTION__);

    cap.words[0] = 0
        | (capZombieType & 0x3ful) << 8
        | ((uint32_t)cap_zombie_cap & 0xfful) << 0;
    cap.words[1] = 0
        | capZombieID << 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_zombie_cap_get_capZombieID(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_zombie_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_zombie_cap",
                         "./arch/object/structures_gen.h"
# 2151 "./arch/object/structures_gen.h"
    ,
                         2152
# 2151 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (cap.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_zombie_cap_set_capZombieID(cap_t cap, uint32_t v) {
    if(!(((cap.words[0] >> 0) & 0xff) == cap_zombie_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_zombie_cap",
                         "./arch/object/structures_gen.h"
# 2164 "./arch/object/structures_gen.h"
    ,
                         2165
# 2164 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffffffful >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffffffful >> 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2167, __FUNCTION__);

    cap.words[1] &= ~0xfffffffful;
    cap.words[1] |= (v << 0) & 0xfffffffful;
    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_zombie_cap_get_capZombieType(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_zombie_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_zombie_cap",
                         "./arch/object/structures_gen.h"
# 2177 "./arch/object/structures_gen.h"
    ,
                         2178
# 2177 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (cap.words[0] & 0x3f00ul) >> 8;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline cap_t __attribute__((__const__))
cap_domain_cap_new(void) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)cap_domain_cap & ~0xfful) == ((0 && ((uint32_t)cap_domain_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_domain_cap & ~0xfful) == ((0 && ((uint32_t)cap_domain_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2193, __FUNCTION__);

    cap.words[0] = 0
        | ((uint32_t)cap_domain_cap & 0xfful) << 0;
    cap.words[1] = 0;

    return cap;
}

static inline cap_t __attribute__((__const__))
cap_vcpu_cap_new(uint32_t capVCPUPtr) {
    cap_t cap;

    /* fail if user has passed bits that we will override */
    if(!((capVCPUPtr & ~0xffffff00ul) == ((0 && (capVCPUPtr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(capVCPUPtr & ~0xffffff00ul) == ((0 && (capVCPUPtr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2207, __FUNCTION__);
    if(!(((uint32_t)cap_vcpu_cap & ~0xfful) == ((0 && ((uint32_t)cap_vcpu_cap & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)cap_vcpu_cap & ~0xfful) == ((0 && ((uint32_t)cap_vcpu_cap & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2208, __FUNCTION__);

    cap.words[0] = 0
        | (capVCPUPtr & 0xffffff00ul) >> 0
        | ((uint32_t)cap_vcpu_cap & 0xfful) << 0;
    cap.words[1] = 0;

    return cap;
}

static inline uint32_t __attribute__((__const__))
cap_vcpu_cap_get_capVCPUPtr(cap_t cap) {
    uint32_t ret;
    if(!(((cap.words[0] >> 0) & 0xff) == cap_vcpu_cap)) _assert_fail("((cap.words[0] >> 0) & 0xff) == cap_vcpu_cap",
                       "./arch/object/structures_gen.h"
# 2221 "./arch/object/structures_gen.h"
    ,
                       2222
# 2221 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                        ;

    ret = (cap.words[0] & 0xffffff00ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct virq {
    uint32_t words[1];
};
typedef struct virq virq_t;

enum virq_tag {
    virq_virq_invalid = 0,
    virq_virq_pending = 1,
    virq_virq_active = 2
};
typedef enum virq_tag virq_tag_t;

static inline uint32_t __attribute__((__const__))
virq_get_virqType(virq_t virq) {
    return (virq.words[0] >> 28) & 0x3ul;
}

static inline virq_t __attribute__((__const__))
virq_virq_invalid_set_virqEOIIRQEN(virq_t virq, uint32_t v) {
    if(!(((virq.words[0] >> 28) & 0x3) == virq_virq_invalid)) _assert_fail("((virq.words[0] >> 28) & 0x3) == virq_virq_invalid",
                            "./arch/object/structures_gen.h"
# 2251 "./arch/object/structures_gen.h"
    ,
                            2252
# 2251 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                             ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x80000ul >> 19 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x80000ul >> 19 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2254, __FUNCTION__);

    virq.words[0] &= ~0x80000ul;
    virq.words[0] |= (v << 19) & 0x80000ul;
    return virq;
}

static inline virq_t __attribute__((__const__))
virq_virq_pending_new(uint32_t virqGroup, uint32_t virqPriority, uint32_t virqEOIIRQEN, uint32_t virqIRQ) {
    virq_t virq;

    /* fail if user has passed bits that we will override */
    if(!((virqGroup & ~0x1ul) == ((0 && (virqGroup & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(virqGroup & ~0x1ul) == ((0 && (virqGroup & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2266, __FUNCTION__);
    if(!(((uint32_t)virq_virq_pending & ~0x3ul) == ((0 && ((uint32_t)virq_virq_pending & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)virq_virq_pending & ~0x3ul) == ((0 && ((uint32_t)virq_virq_pending & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2267, __FUNCTION__);
    if(!((virqPriority & ~0x1ful) == ((0 && (virqPriority & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(virqPriority & ~0x1ful) == ((0 && (virqPriority & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2268, __FUNCTION__);
    if(!((virqEOIIRQEN & ~0x1ul) == ((0 && (virqEOIIRQEN & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(virqEOIIRQEN & ~0x1ul) == ((0 && (virqEOIIRQEN & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2269, __FUNCTION__);
    if(!((virqIRQ & ~0x3fful) == ((0 && (virqIRQ & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(virqIRQ & ~0x3fful) == ((0 && (virqIRQ & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2270, __FUNCTION__);

    virq.words[0] = 0
        | (virqGroup & 0x1ul) << 30
        | ((uint32_t)virq_virq_pending & 0x3ul) << 28
        | (virqPriority & 0x1ful) << 23
        | (virqEOIIRQEN & 0x1ul) << 19
        | (virqIRQ & 0x3fful) << 0;

    return virq;
}

static inline virq_t __attribute__((__const__))
virq_virq_pending_set_virqEOIIRQEN(virq_t virq, uint32_t v) {
    if(!(((virq.words[0] >> 28) & 0x3) == virq_virq_pending)) _assert_fail("((virq.words[0] >> 28) & 0x3) == virq_virq_pending",
                            "./arch/object/structures_gen.h"
# 2284 "./arch/object/structures_gen.h"
    ,
                            2285
# 2284 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                             ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x80000ul >> 19 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x80000ul >> 19 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2287, __FUNCTION__);

    virq.words[0] &= ~0x80000ul;
    virq.words[0] |= (v << 19) & 0x80000ul;
    return virq;
}

static inline virq_t __attribute__((__const__))
virq_virq_active_set_virqEOIIRQEN(virq_t virq, uint32_t v) {
    if(!(((virq.words[0] >> 28) & 0x3) == virq_virq_active)) _assert_fail("((virq.words[0] >> 28) & 0x3) == virq_virq_active",
                           "./arch/object/structures_gen.h"
# 2296 "./arch/object/structures_gen.h"
    ,
                           2297
# 2296 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                            ;
    /* fail if user has passed bits that we will override */
    if(!((((~0x80000ul >> 19 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0x80000ul >> 19 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2299, __FUNCTION__);

    virq.words[0] &= ~0x80000ul;
    virq.words[0] |= (v << 19) & 0x80000ul;
    return virq;
}

struct pde {
    uint32_t words[2];
};
typedef struct pde pde_t;

enum pde_tag {
    pde_pde_invalid = 0,
    pde_pde_section = 1,
    pde_pde_coarse = 3
};
typedef enum pde_tag pde_tag_t;

static inline uint32_t __attribute__((__const__))
pde_get_pdeType(pde_t pde) {
    return (pde.words[0] >> 0) & 0x3ul;
}

static inline uint32_t __attribute__((__pure__))
pde_ptr_get_pdeType(pde_t *pde_ptr) {
    return (pde_ptr->words[0] >> 0) & 0x3ul;
}

static inline pde_t __attribute__((__const__))
pde_pde_invalid_new(uint32_t stored_hw_asid, uint32_t stored_asid_valid) {
    pde_t pde;

    /* fail if user has passed bits that we will override */
    if(!((stored_hw_asid & ~0xfful) == ((0 && (stored_hw_asid & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(stored_hw_asid & ~0xfful) == ((0 && (stored_hw_asid & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2333, __FUNCTION__);
    if(!((stored_asid_valid & ~0x1ul) == ((0 && (stored_asid_valid & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(stored_asid_valid & ~0x1ul) == ((0 && (stored_asid_valid & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2334, __FUNCTION__);
    if(!(((uint32_t)pde_pde_invalid & ~0x3ul) == ((0 && ((uint32_t)pde_pde_invalid & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pde_pde_invalid & ~0x3ul) == ((0 && ((uint32_t)pde_pde_invalid & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2335, __FUNCTION__);

    pde.words[0] = 0
        | (stored_hw_asid & 0xfful) << 24
        | (stored_asid_valid & 0x1ul) << 23
        | ((uint32_t)pde_pde_invalid & 0x3ul) << 0;
    pde.words[1] = 0;

    return pde;
}

static inline uint32_t __attribute__((__const__))
pde_pde_invalid_get_stored_hw_asid(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 0) & 0x3) == pde_pde_invalid)) _assert_fail("((pde.words[0] >> 0) & 0x3) == pde_pde_invalid",
                          "./arch/object/structures_gen.h"
# 2349 "./arch/object/structures_gen.h"
    ,
                          2350
# 2349 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (pde.words[0] & 0xff000000ul) >> 24;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pde_pde_invalid_get_stored_asid_valid(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 0) & 0x3) == pde_pde_invalid)) _assert_fail("((pde.words[0] >> 0) & 0x3) == pde_pde_invalid",
                          "./arch/object/structures_gen.h"
# 2363 "./arch/object/structures_gen.h"
    ,
                          2364
# 2363 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (pde.words[0] & 0x800000ul) >> 23;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline pde_t __attribute__((__const__))
pde_pde_section_new(uint32_t XN, uint32_t contiguous_hint, uint32_t address, uint32_t AF, uint32_t SH, uint32_t HAP, uint32_t MemAttr) {
    pde_t pde;

    /* fail if user has passed bits that we will override */
    if(!((XN & ~0x1ul) == ((0 && (XN & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(XN & ~0x1ul) == ((0 && (XN & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2379, __FUNCTION__);
    if(!((contiguous_hint & ~0x1ul) == ((0 && (contiguous_hint & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(contiguous_hint & ~0x1ul) == ((0 && (contiguous_hint & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2380, __FUNCTION__);
    if(!((address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2381, __FUNCTION__);
    if(!((AF & ~0x1ul) == ((0 && (AF & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(AF & ~0x1ul) == ((0 && (AF & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2382, __FUNCTION__);
    if(!((SH & ~0x3ul) == ((0 && (SH & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(SH & ~0x3ul) == ((0 && (SH & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2383, __FUNCTION__);
    if(!((HAP & ~0x3ul) == ((0 && (HAP & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(HAP & ~0x3ul) == ((0 && (HAP & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2384, __FUNCTION__);
    if(!((MemAttr & ~0xful) == ((0 && (MemAttr & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(MemAttr & ~0xful) == ((0 && (MemAttr & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2385, __FUNCTION__);
    if(!(((uint32_t)pde_pde_section & ~0x3ul) == ((0 && ((uint32_t)pde_pde_section & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pde_pde_section & ~0x3ul) == ((0 && ((uint32_t)pde_pde_section & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2386, __FUNCTION__);

    pde.words[0] = 0
        | (address & 0xfffff000ul) >> 0
        | (AF & 0x1ul) << 10
        | (SH & 0x3ul) << 8
        | (HAP & 0x3ul) << 6
        | (MemAttr & 0xful) << 2
        | ((uint32_t)pde_pde_section & 0x3ul) << 0;
    pde.words[1] = 0
        | (XN & 0x1ul) << 22
        | (contiguous_hint & 0x1ul) << 20;

    return pde;
}

static inline uint32_t __attribute__((__const__))
pde_pde_section_get_contiguous_hint(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 0) & 0x3) == pde_pde_section)) _assert_fail("((pde.words[0] >> 0) & 0x3) == pde_pde_section",
                          "./arch/object/structures_gen.h"
# 2405 "./arch/object/structures_gen.h"
    ,
                          2406
# 2405 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (pde.words[1] & 0x100000ul) >> 20;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pde_pde_section_ptr_get_contiguous_hint(pde_t *pde_ptr) {
    uint32_t ret;
    if(!(((pde_ptr->words[0] >> 0) & 0x3) == pde_pde_section)) _assert_fail("((pde_ptr->words[0] >> 0) & 0x3) == pde_pde_section",
                          "./arch/object/structures_gen.h"
# 2419 "./arch/object/structures_gen.h"
    ,
                          2420
# 2419 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (pde_ptr->words[1] & 0x100000ul) >> 20;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pde_pde_section_get_address(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 0) & 0x3) == pde_pde_section)) _assert_fail("((pde.words[0] >> 0) & 0x3) == pde_pde_section",
                          "./arch/object/structures_gen.h"
# 2433 "./arch/object/structures_gen.h"
    ,
                          2434
# 2433 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (pde.words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline pde_t __attribute__((__const__))
pde_pde_section_set_address(pde_t pde, uint32_t v) {
    if(!(((pde.words[0] >> 0) & 0x3) == pde_pde_section)) _assert_fail("((pde.words[0] >> 0) & 0x3) == pde_pde_section",
                          "./arch/object/structures_gen.h"
# 2446 "./arch/object/structures_gen.h"
    ,
                          2447
# 2446 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;
    /* fail if user has passed bits that we will override */
    if(!((((~0xfffff000ul << 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0))) _assert_fail("(((~0xfffff000ul << 0 ) | 0x0) & v) == ((0 && (v & (1ul << (31)))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2449, __FUNCTION__);

    pde.words[0] &= ~0xfffff000ul;
    pde.words[0] |= (v >> 0) & 0xfffff000ul;
    return pde;
}

static inline uint32_t __attribute__((__pure__))
pde_pde_section_ptr_get_address(pde_t *pde_ptr) {
    uint32_t ret;
    if(!(((pde_ptr->words[0] >> 0) & 0x3) == pde_pde_section)) _assert_fail("((pde_ptr->words[0] >> 0) & 0x3) == pde_pde_section",
                          "./arch/object/structures_gen.h"
# 2459 "./arch/object/structures_gen.h"
    ,
                          2460
# 2459 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (pde_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
pde_pde_section_get_HAP(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 0) & 0x3) == pde_pde_section)) _assert_fail("((pde.words[0] >> 0) & 0x3) == pde_pde_section",
                          "./arch/object/structures_gen.h"
# 2473 "./arch/object/structures_gen.h"
    ,
                          2474
# 2473 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                           ;

    ret = (pde.words[0] & 0xc0ul) >> 6;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline pde_t __attribute__((__const__))
pde_pde_coarse_new(uint32_t address) {
    pde_t pde;

    /* fail if user has passed bits that we will override */
    if(!((address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2489, __FUNCTION__);
    if(!(((uint32_t)pde_pde_coarse & ~0x3ul) == ((0 && ((uint32_t)pde_pde_coarse & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pde_pde_coarse & ~0x3ul) == ((0 && ((uint32_t)pde_pde_coarse & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2490, __FUNCTION__);

    pde.words[0] = 0
        | (address & 0xfffff000ul) >> 0
        | ((uint32_t)pde_pde_coarse & 0x3ul) << 0;
    pde.words[1] = 0;

    return pde;
}

static inline uint32_t __attribute__((__const__))
pde_pde_coarse_get_address(pde_t pde) {
    uint32_t ret;
    if(!(((pde.words[0] >> 0) & 0x3) == pde_pde_coarse)) _assert_fail("((pde.words[0] >> 0) & 0x3) == pde_pde_coarse",
                         "./arch/object/structures_gen.h"
# 2503 "./arch/object/structures_gen.h"
    ,
                         2504
# 2503 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (pde.words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__pure__))
pde_pde_coarse_ptr_get_address(pde_t *pde_ptr) {
    uint32_t ret;
    if(!(((pde_ptr->words[0] >> 0) & 0x3) == pde_pde_coarse)) _assert_fail("((pde_ptr->words[0] >> 0) & 0x3) == pde_pde_coarse",
                         "./arch/object/structures_gen.h"
# 2517 "./arch/object/structures_gen.h"
    ,
                         2518
# 2517 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                          ;

    ret = (pde_ptr->words[0] & 0xfffff000ul) << 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct seL4_Fault {
    uint32_t words[2];
};
typedef struct seL4_Fault seL4_Fault_t;

enum seL4_Fault_tag {
    seL4_Fault_NullFault = 0,
    seL4_Fault_CapFault = 1,
    seL4_Fault_UnknownSyscall = 2,
    seL4_Fault_UserException = 3,
    seL4_Fault_VMFault = 5,
    seL4_Fault_VGICMaintenance = 6,
    seL4_Fault_VCPUFault = 7
};
typedef enum seL4_Fault_tag seL4_Fault_tag_t;

static inline uint32_t __attribute__((__const__))
seL4_Fault_get_seL4_FaultType(seL4_Fault_t seL4_Fault) {
    return (seL4_Fault.words[0] >> 0) & 0x7ul;
}

static inline uint32_t __attribute__((__pure__))
seL4_Fault_ptr_get_seL4_FaultType(seL4_Fault_t *seL4_Fault_ptr) {
    return (seL4_Fault_ptr->words[0] >> 0) & 0x7ul;
}

static inline seL4_Fault_t __attribute__((__const__))
seL4_Fault_NullFault_new(void) {
    seL4_Fault_t seL4_Fault;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)seL4_Fault_NullFault & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_NullFault & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)seL4_Fault_NullFault & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_NullFault & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2559, __FUNCTION__);

    seL4_Fault.words[0] = 0
        | ((uint32_t)seL4_Fault_NullFault & 0x7ul) << 0;
    seL4_Fault.words[1] = 0;

    return seL4_Fault;
}

static inline seL4_Fault_t __attribute__((__const__))
seL4_Fault_CapFault_new(uint32_t address, uint32_t inReceivePhase) {
    seL4_Fault_t seL4_Fault;

    /* fail if user has passed bits that we will override */
    if(!((inReceivePhase & ~0x1ul) == ((0 && (inReceivePhase & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(inReceivePhase & ~0x1ul) == ((0 && (inReceivePhase & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2573, __FUNCTION__);
    if(!(((uint32_t)seL4_Fault_CapFault & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_CapFault & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)seL4_Fault_CapFault & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_CapFault & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2574, __FUNCTION__);

    seL4_Fault.words[0] = 0
        | (inReceivePhase & 0x1ul) << 31
        | ((uint32_t)seL4_Fault_CapFault & 0x7ul) << 0;
    seL4_Fault.words[1] = 0
        | address << 0;

    return seL4_Fault;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_CapFault_get_address(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_CapFault)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_CapFault",
                              "./arch/object/structures_gen.h"
# 2588 "./arch/object/structures_gen.h"
    ,
                              2589
# 2588 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;

    ret = (seL4_Fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_CapFault_get_inReceivePhase(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_CapFault)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_CapFault",
                              "./arch/object/structures_gen.h"
# 2602 "./arch/object/structures_gen.h"
    ,
                              2603
# 2602 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                               ;

    ret = (seL4_Fault.words[0] & 0x80000000ul) >> 31;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline seL4_Fault_t __attribute__((__const__))
seL4_Fault_UnknownSyscall_new(uint32_t syscallNumber) {
    seL4_Fault_t seL4_Fault;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)seL4_Fault_UnknownSyscall & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_UnknownSyscall & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)seL4_Fault_UnknownSyscall & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_UnknownSyscall & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2618, __FUNCTION__);

    seL4_Fault.words[0] = 0
        | ((uint32_t)seL4_Fault_UnknownSyscall & 0x7ul) << 0;
    seL4_Fault.words[1] = 0
        | syscallNumber << 0;

    return seL4_Fault;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_UnknownSyscall_get_syscallNumber(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_UnknownSyscall)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_UnknownSyscall",
                                    "./arch/object/structures_gen.h"
# 2631 "./arch/object/structures_gen.h"
    ,
                                    2632
# 2631 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                     ;

    ret = (seL4_Fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline seL4_Fault_t __attribute__((__const__))
seL4_Fault_UserException_new(uint32_t number, uint32_t code) {
    seL4_Fault_t seL4_Fault;

    /* fail if user has passed bits that we will override */
    if(!((code & ~0x1ffffffful) == ((0 && (code & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(code & ~0x1ffffffful) == ((0 && (code & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2647, __FUNCTION__);
    if(!(((uint32_t)seL4_Fault_UserException & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_UserException & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)seL4_Fault_UserException & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_UserException & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2648, __FUNCTION__);

    seL4_Fault.words[0] = 0
        | (code & 0x1ffffffful) << 3
        | ((uint32_t)seL4_Fault_UserException & 0x7ul) << 0;
    seL4_Fault.words[1] = 0
        | number << 0;

    return seL4_Fault;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_UserException_get_number(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_UserException)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_UserException",
                                   "./arch/object/structures_gen.h"
# 2662 "./arch/object/structures_gen.h"
    ,
                                   2663
# 2662 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                    ;

    ret = (seL4_Fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_UserException_get_code(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_UserException)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_UserException",
                                   "./arch/object/structures_gen.h"
# 2676 "./arch/object/structures_gen.h"
    ,
                                   2677
# 2676 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                    ;

    ret = (seL4_Fault.words[0] & 0xfffffff8ul) >> 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline seL4_Fault_t __attribute__((__const__))
seL4_Fault_VMFault_new(uint32_t address, uint32_t FSR, uint32_t instructionFault) {
    seL4_Fault_t seL4_Fault;

    /* fail if user has passed bits that we will override */
    if(!((FSR & ~0x3fffffful) == ((0 && (FSR & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(FSR & ~0x3fffffful) == ((0 && (FSR & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2692, __FUNCTION__);
    if(!((instructionFault & ~0x1ul) == ((0 && (instructionFault & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(instructionFault & ~0x1ul) == ((0 && (instructionFault & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2693, __FUNCTION__);
    if(!(((uint32_t)seL4_Fault_VMFault & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_VMFault & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)seL4_Fault_VMFault & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_VMFault & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2694, __FUNCTION__);

    seL4_Fault.words[0] = 0
        | (FSR & 0x3fffffful) << 6
        | (instructionFault & 0x1ul) << 3
        | ((uint32_t)seL4_Fault_VMFault & 0x7ul) << 0;
    seL4_Fault.words[1] = 0
        | address << 0;

    return seL4_Fault;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_VMFault_get_address(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VMFault)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VMFault",
                             "./arch/object/structures_gen.h"
# 2709 "./arch/object/structures_gen.h"
    ,
                             2710
# 2709 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (seL4_Fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_VMFault_get_FSR(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VMFault)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VMFault",
                             "./arch/object/structures_gen.h"
# 2723 "./arch/object/structures_gen.h"
    ,
                             2724
# 2723 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (seL4_Fault.words[0] & 0xffffffc0ul) >> 6;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_VMFault_get_instructionFault(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VMFault)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VMFault",
                             "./arch/object/structures_gen.h"
# 2737 "./arch/object/structures_gen.h"
    ,
                             2738
# 2737 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                              ;

    ret = (seL4_Fault.words[0] & 0x8ul) >> 3;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline seL4_Fault_t __attribute__((__const__))
seL4_Fault_VGICMaintenance_new(uint32_t idx, uint32_t idxValid) {
    seL4_Fault_t seL4_Fault;

    /* fail if user has passed bits that we will override */
    if(!((idx & ~0x3ful) == ((0 && (idx & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(idx & ~0x3ful) == ((0 && (idx & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2753, __FUNCTION__);
    if(!((idxValid & ~0x1ul) == ((0 && (idxValid & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(idxValid & ~0x1ul) == ((0 && (idxValid & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2754, __FUNCTION__);
    if(!(((uint32_t)seL4_Fault_VGICMaintenance & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_VGICMaintenance & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)seL4_Fault_VGICMaintenance & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_VGICMaintenance & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2755, __FUNCTION__);

    seL4_Fault.words[0] = 0
        | ((uint32_t)seL4_Fault_VGICMaintenance & 0x7ul) << 0;
    seL4_Fault.words[1] = 0
        | (idx & 0x3ful) << 26
        | (idxValid & 0x1ul) << 25;

    return seL4_Fault;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_VGICMaintenance_get_idx(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VGICMaintenance)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VGICMaintenance",
                                     "./arch/object/structures_gen.h"
# 2769 "./arch/object/structures_gen.h"
    ,
                                     2770
# 2769 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                      ;

    ret = (seL4_Fault.words[1] & 0xfc000000ul) >> 26;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_VGICMaintenance_get_idxValid(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VGICMaintenance)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VGICMaintenance",
                                     "./arch/object/structures_gen.h"
# 2783 "./arch/object/structures_gen.h"
    ,
                                     2784
# 2783 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                      ;

    ret = (seL4_Fault.words[1] & 0x2000000ul) >> 25;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

static inline seL4_Fault_t __attribute__((__const__))
seL4_Fault_VCPUFault_new(uint32_t hsr) {
    seL4_Fault_t seL4_Fault;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)seL4_Fault_VCPUFault & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_VCPUFault & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)seL4_Fault_VCPUFault & ~0x7ul) == ((0 && ((uint32_t)seL4_Fault_VCPUFault & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2799, __FUNCTION__);

    seL4_Fault.words[0] = 0
        | ((uint32_t)seL4_Fault_VCPUFault & 0x7ul) << 0;
    seL4_Fault.words[1] = 0
        | hsr << 0;

    return seL4_Fault;
}

static inline uint32_t __attribute__((__const__))
seL4_Fault_VCPUFault_get_hsr(seL4_Fault_t seL4_Fault) {
    uint32_t ret;
    if(!(((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VCPUFault)) _assert_fail("((seL4_Fault.words[0] >> 0) & 0x7) == seL4_Fault_VCPUFault",
                               "./arch/object/structures_gen.h"
# 2812 "./arch/object/structures_gen.h"
    ,
                               2813
# 2812 "./arch/object/structures_gen.h"
    , __FUNCTION__)
                                ;

    ret = (seL4_Fault.words[1] & 0xfffffffful) >> 0;
    /* Possibly sign extend */
    if (0 && (ret & (1ul << (31)))) {
        ret |= 0x0;
    }
    return ret;
}

struct pdeS1 {
    uint32_t words[2];
};
typedef struct pdeS1 pdeS1_t;

enum pdeS1_tag {
    pdeS1_pdeS1_invalid = 0,
    pdeS1_pdeS1_section = 1,
    pdeS1_pdeS1_coarse = 3
};
typedef enum pdeS1_tag pdeS1_tag_t;

static inline pdeS1_t __attribute__((__const__))
pdeS1_pdeS1_invalid_new(void) {
    pdeS1_t pdeS1;

    /* fail if user has passed bits that we will override */
    if(!(((uint32_t)pdeS1_pdeS1_invalid & ~0x3ul) == ((0 && ((uint32_t)pdeS1_pdeS1_invalid & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pdeS1_pdeS1_invalid & ~0x3ul) == ((0 && ((uint32_t)pdeS1_pdeS1_invalid & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2840, __FUNCTION__);

    pdeS1.words[0] = 0
        | ((uint32_t)pdeS1_pdeS1_invalid & 0x3ul) << 0;
    pdeS1.words[1] = 0;

    return pdeS1;
}

static inline pdeS1_t __attribute__((__const__))
pdeS1_pdeS1_section_new(uint32_t XN, uint32_t PXN, uint32_t contiguous_hint, uint32_t address, uint32_t nG, uint32_t AF, uint32_t SH, uint32_t AP, uint32_t NS, uint32_t AttrIndx) {
    pdeS1_t pdeS1;

    /* fail if user has passed bits that we will override */
    if(!((XN & ~0x1ul) == ((0 && (XN & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(XN & ~0x1ul) == ((0 && (XN & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2854, __FUNCTION__);
    if(!((PXN & ~0x1ul) == ((0 && (PXN & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(PXN & ~0x1ul) == ((0 && (PXN & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2855, __FUNCTION__);
    if(!((contiguous_hint & ~0x1ul) == ((0 && (contiguous_hint & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(contiguous_hint & ~0x1ul) == ((0 && (contiguous_hint & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2856, __FUNCTION__);
    if(!((address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2857, __FUNCTION__);
    if(!((nG & ~0x1ul) == ((0 && (nG & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(nG & ~0x1ul) == ((0 && (nG & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2858, __FUNCTION__);
    if(!((AF & ~0x1ul) == ((0 && (AF & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(AF & ~0x1ul) == ((0 && (AF & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2859, __FUNCTION__);
    if(!((SH & ~0x3ul) == ((0 && (SH & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(SH & ~0x3ul) == ((0 && (SH & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2860, __FUNCTION__);
    if(!((AP & ~0x3ul) == ((0 && (AP & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(AP & ~0x3ul) == ((0 && (AP & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2861, __FUNCTION__);
    if(!((NS & ~0x1ul) == ((0 && (NS & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(NS & ~0x1ul) == ((0 && (NS & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2862, __FUNCTION__);
    if(!((AttrIndx & ~0x7ul) == ((0 && (AttrIndx & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(AttrIndx & ~0x7ul) == ((0 && (AttrIndx & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2863, __FUNCTION__);
    if(!(((uint32_t)pdeS1_pdeS1_section & ~0x3ul) == ((0 && ((uint32_t)pdeS1_pdeS1_section & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pdeS1_pdeS1_section & ~0x3ul) == ((0 && ((uint32_t)pdeS1_pdeS1_section & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2864, __FUNCTION__);

    pdeS1.words[0] = 0
        | (address & 0xfffff000ul) >> 0
        | (nG & 0x1ul) << 11
        | (AF & 0x1ul) << 10
        | (SH & 0x3ul) << 8
        | (AP & 0x3ul) << 6
        | (NS & 0x1ul) << 5
        | (AttrIndx & 0x7ul) << 2
        | ((uint32_t)pdeS1_pdeS1_section & 0x3ul) << 0;
    pdeS1.words[1] = 0
        | (XN & 0x1ul) << 22
        | (PXN & 0x1ul) << 21
        | (contiguous_hint & 0x1ul) << 20;

    return pdeS1;
}

static inline pdeS1_t __attribute__((__const__))
pdeS1_pdeS1_coarse_new(uint32_t NSTable, uint32_t APTable, uint32_t XNTable, uint32_t PXNTable, uint32_t address) {
    pdeS1_t pdeS1;

    /* fail if user has passed bits that we will override */
    if(!((NSTable & ~0x1ul) == ((0 && (NSTable & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(NSTable & ~0x1ul) == ((0 && (NSTable & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2888, __FUNCTION__);
    if(!((APTable & ~0x3ul) == ((0 && (APTable & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(APTable & ~0x3ul) == ((0 && (APTable & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2889, __FUNCTION__);
    if(!((XNTable & ~0x1ul) == ((0 && (XNTable & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(XNTable & ~0x1ul) == ((0 && (XNTable & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2890, __FUNCTION__);
    if(!((PXNTable & ~0x1ul) == ((0 && (PXNTable & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(PXNTable & ~0x1ul) == ((0 && (PXNTable & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2891, __FUNCTION__);
    if(!((address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0))) _assert_fail("(address & ~0xfffff000ul) == ((0 && (address & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2892, __FUNCTION__);
    if(!(((uint32_t)pdeS1_pdeS1_coarse & ~0x3ul) == ((0 && ((uint32_t)pdeS1_pdeS1_coarse & (1ul << 31))) ? 0x0 : 0))) _assert_fail("((uint32_t)pdeS1_pdeS1_coarse & ~0x3ul) == ((0 && ((uint32_t)pdeS1_pdeS1_coarse & (1ul << 31))) ? 0x0 : 0)", "./arch/object/structures_gen.h", 2893, __FUNCTION__);

    pdeS1.words[0] = 0
        | (address & 0xfffff000ul) >> 0
        | ((uint32_t)pdeS1_pdeS1_coarse & 0x3ul) << 0;
    pdeS1.words[1] = 0
        | (NSTable & 0x1ul) << 31
        | (APTable & 0x3ul) << 29
        | (XNTable & 0x1ul) << 28
        | (PXNTable & 0x1ul) << 27;

    return pdeS1;
}
# 18 "/home/sel4/work/work2/kernel/include/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/macros.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */
# 19 "/home/sel4/work/work2/kernel/include/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/constants.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */
# 20 "/home/sel4/work/work2/kernel/include/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation_.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation_.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/benchmark.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/benchmark.h" 2
# 18 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation_.h" 2
# 21 "/home/sel4/work/work2/kernel/include/object/structures.h" 2

enum irq_state {
    IRQInactive = 0,
    IRQSignal = 1,
    IRQTimer = 2,



    IRQReserved
};
typedef word_t irq_state_t;

typedef struct dschedule {
    dom_t domain;
    word_t length;
} dschedule_t;

/* Arch-independent object types */
enum endpoint_state {
    EPState_Idle = 0,
    EPState_Send = 1,
    EPState_Recv = 2
};
typedef word_t endpoint_state_t;

enum notification_state {
    NtfnState_Idle = 0,
    NtfnState_Waiting = 1,
    NtfnState_Active = 2
};
typedef word_t notification_state_t;
# 70 "/home/sel4/work/work2/kernel/include/object/structures.h"
/* Generate a tcb_t or cte_t pointer from a tcb block reference */




/* Generate a cte_t pointer from a tcb_t pointer */
# 85 "/home/sel4/work/work2/kernel/include/object/structures.h"
static inline cap_t __attribute__((__const__))
Zombie_new(word_t number, word_t type, word_t ptr)
{
    word_t mask;

    if (type == (1ul << (5))) {
        mask = ((1ul << (4 + 1))-1ul);
    } else {
        mask = ((1ul << (type + 1))-1ul);
    }

    return cap_zombie_cap_new((ptr & ~mask) | (number & mask), type);
}

static inline word_t __attribute__((__const__))
cap_zombie_cap_get_capZombieBits(cap_t cap)
{
    word_t type = cap_zombie_cap_get_capZombieType(cap);
    if (type == (1ul << (5))) {
        return 4;
    }
    return ((type) & ((1ul << (5))-1ul)); /* cnode radix */
}

static inline word_t __attribute__((__const__))
cap_zombie_cap_get_capZombieNumber(cap_t cap)
{
    word_t radix = cap_zombie_cap_get_capZombieBits(cap);
    return cap_zombie_cap_get_capZombieID(cap) & ((1ul << (radix + 1))-1ul);
}

static inline word_t __attribute__((__const__))
cap_zombie_cap_get_capZombiePtr(cap_t cap)
{
    word_t radix = cap_zombie_cap_get_capZombieBits(cap);
    return cap_zombie_cap_get_capZombieID(cap) & ~((1ul << (radix + 1))-1ul);
}

static inline cap_t __attribute__((__const__))
cap_zombie_cap_set_capZombieNumber(cap_t cap, word_t n)
{
    word_t radix = cap_zombie_cap_get_capZombieBits(cap);
    word_t ptr = cap_zombie_cap_get_capZombieID(cap) & ~((1ul << (radix + 1))-1ul);
    return cap_zombie_cap_set_capZombieID(cap, ptr | (n & ((1ul << (radix + 1))-1ul)));
}

/* Capability table entry (CTE) */
struct cte {
    cap_t cap;
    mdb_node_t cteMDBNode;
};
typedef struct cte cte_t;



/* Thread state */
enum _thread_state {
    ThreadState_Inactive = 0,
    ThreadState_Running,
    ThreadState_Restart,
    ThreadState_BlockedOnReceive,
    ThreadState_BlockedOnSend,
    ThreadState_BlockedOnReply,
    ThreadState_BlockedOnNotification,



    ThreadState_IdleThreadState
};
typedef word_t _thread_state_t;

/* A TCB CNode and a TCB are always allocated together, and adjacently.
 * The CNode comes first. */
enum tcb_cnode_index {
    /* CSpace root */
    tcbCTable = 0,

    /* VSpace root */
    tcbVTable = 1,

    /* Reply cap slot */
    tcbReply = 2,

    /* TCB of most recent IPC sender */
    tcbCaller = 3,

    /* IPC buffer cap slot */
    tcbBuffer = 4,

    tcbCNodeEntries
};
typedef word_t tcb_cnode_index_t;

# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/macros.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h" 2

# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/hardware.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/hardware.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/api/constants.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */





# 1 "/home/sel4/work/work2/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * CAmkES project configuration
 * Tue Aug  1 11:39:17 2017
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/api/constants.h" 2
# 27 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/api/constants.h"
/* format of an unknown syscall message */
enum {
    seL4_UnknownSyscall_R0,
    seL4_UnknownSyscall_R1,
    seL4_UnknownSyscall_R2,
    seL4_UnknownSyscall_R3,
    seL4_UnknownSyscall_R4,
    seL4_UnknownSyscall_R5,
    seL4_UnknownSyscall_R6,
    seL4_UnknownSyscall_R7,
    seL4_UnknownSyscall_FaultIP,
    seL4_UnknownSyscall_SP,
    seL4_UnknownSyscall_LR,
    seL4_UnknownSyscall_CPSR,
    seL4_UnknownSyscall_Syscall,
    /* length of an unknown syscall message */
    seL4_UnknownSyscall_Length,
    _enum_pad_seL4_UnknownSyscall_Msg = (1ULL << ((sizeof(long)*8) - 1)) - 1,
} seL4_UnknownSyscall_Msg;

/* format of a user exception message */
enum {
    seL4_UserException_FaultIP,
    seL4_UserException_SP,
    seL4_UserException_CPSR,
    seL4_UserException_Number,
    seL4_UserException_Code,
    /* length of a user exception */
    seL4_UserException_Length,
    _enum_pad_seL4_UserException_Msg = (1ULL << ((sizeof(long)*8) - 1)) - 1,
} seL4_UserException_Msg;

/* format of a vm fault message */
enum {
    seL4_VMFault_IP,
    seL4_VMFault_Addr,
    seL4_VMFault_PrefetchFault,
    seL4_VMFault_FSR,
    seL4_VMFault_Length,
    _enum_pad_seL4_VMFault_Msg = (1ULL << ((sizeof(long)*8) - 1)) - 1,
} seL4_VMFault_Msg;


enum {
    seL4_VGICMaintenance_IDX,
    seL4_VGICMaintenance_Length,
    _enum_pad_seL4_VGICMaintenance_Msg = (1ULL << ((sizeof(long)*8) - 1)) - 1,
} seL4_VGICMaintenance_Msg;

enum {
    seL4_VCPUFault_HSR,
    seL4_VCPUFault_Length,
    _enum_pad_seL4_VCPUFault_Msg = (1ULL << ((sizeof(long)*8) - 1)) - 1,
} seL4_VCPUFault_Msg;

enum {
    seL4_VCPUReg_SCTLR = 0,
    seL4_VCPUReg_LRsvc,
    seL4_VCPUReg_SPsvc,
    seL4_VCPUReg_LRabt,
    seL4_VCPUReg_SPabt,
    seL4_VCPUReg_LRund,
    seL4_VCPUReg_SPund,
    seL4_VCPUReg_LRirq,
    seL4_VCPUReg_SPirq,
    seL4_VCPUReg_LRfiq,
    seL4_VCPUReg_SPfiq,
    seL4_VCPUReg_R8fiq,
    seL4_VCPUReg_R9fiq,
    seL4_VCPUReg_R10fiq,
    seL4_VCPUReg_R11fiq,
    seL4_VCPUReg_R12fiq,
    seL4_VCPUReg_Num,
} seL4_VCPUReg;






/* object sizes - 2^n */
# 150 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/api/constants.h"
/* bits in a word */

/* log 2 bits in a word */



typedef int __assert_failed_seL4_PageTableEntryBitsseL4_PageTableIndexBitsseL4_PageTableBits[(3 + 9 == 12) ? 1 : -1];;
typedef int __assert_failed_seL4_PageDirEntryBitsseL4_PageDirIndexBitsseL4_PageDirBits[(3 + 11 == 14) ? 1 : -1];;
typedef int __assert_failed_seL4_WordSizeBitsseL4_ASIDPoolIndexBitsseL4_ASIDPoolBits[(2 + 10 == 12) ? 1 : -1];;


/* Untyped size limits */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/hardware.h" 2
# 46 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/hardware.h"
/* Processor ID used to check if errata work arounds need to be performed */


/* Control register fields */
# 103 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/hardware.h"
/* Processor mode encodings (for CPS etc.) */
# 112 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/hardware.h"
/* Processor exception mask bits */




/* Kernel operating mode */
# 128 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/hardware.h"
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 129 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/hardware.h" 2

enum vm_page_size {
    ARMSmallPage,
    ARMLargePage,
    ARMSection,
    ARMSuperSection
};
typedef word_t vm_page_size_t;

enum frameSizeConstants {
    ARMSmallPageBits = 12,
    ARMLargePageBits = 16,
    ARMSectionBits = 21,
    ARMSuperSectionBits = 25
};

static inline word_t __attribute__((__const__))
pageBitsForSize(vm_page_size_t pagesize)
{
    switch (pagesize) {
    case ARMSmallPage:
        return ARMSmallPageBits;

    case ARMLargePage:
        return ARMLargePageBits;

    case ARMSection:
        return ARMSectionBits;

    case ARMSuperSection:
        return ARMSuperSectionBits;

    default:
        _fail("Invalid page size", "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/hardware.h", 162, __func__);
    }
}
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/hardware.h" 2


enum vm_fault_type {
    ARMDataAbort = 0,
    ARMPrefetchAbort = 1
};
typedef word_t vm_fault_type_t;
# 22 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 2

/*
 * We cannot allow async aborts in the verified kernel, but
 * they are useful in identifying invalid memory access bugs
 * so we enable them in debug mode.
 */
# 40 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h"
/* Offsets within the user context, these need to match the order in
 * register_t below */
# 51 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h"
# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 52 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 53 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 2
# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 54 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 55 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 56 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug_conf.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug_conf.h" 2

/* These are used to force specific outcomes for various combinations of
 * settings for the state of CONFIG_ARM_HYPERVISOR_SUPPORT,
 * CONFIG_ARM_HYP_ENABLE_VCPU_CP14_SAVE_AND_RESTORE and
 * CONFIG_HARDWARE_DEBUG_API.
 */
# 33 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug_conf.h"
/* When this is enabled, the ARM-hyp kernel will enable
 * CP14 save and restore whenever it is running a VCPU thread. When it's
 * disabled, the hyp kernel will intercept accesses to the CP14
 * coprocessor and deliver them as fault messages to the VCPU's fault
 * handler.
 */
# 57 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/api/constants.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */





# 1 "/home/sel4/work/work2/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * CAmkES project configuration
 * Tue Aug  1 11:39:17 2017
 */
# 18 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/api/constants.h" 2


/* Cortex a15 manual, section 10.2.2 */
# 58 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 2

/* These are the indices of the registers in the
 * saved thread context.  The values are determined
 * by the order in which they're saved in the trap
 * handler. */
enum _register {
    R0 = 0,
    capRegister = 0,
    badgeRegister = 0,

    R1 = 1,
    msgInfoRegister = 1,

    R2 = 2,
    R3 = 3,
    R4 = 4,
    R5 = 5,
    R6 = 6,
    R7 = 7,
    R8 = 8,
    R9 = 9,
    R10 = 10,
    R11 = 11,
    R12 = 12,

    R13 = 13,
    SP = 13,

    R14 = 14,
    LR = 14,

    /* End of GP registers, the following are additional kernel-saved state. */

    LR_svc = 15,

    ELR_hyp = 15,

    CPSR = 16,

    FaultInstruction = 17,

    /* user readable/writable thread ID register.
     * name comes from the ARM manual */
    TPIDRURW = 18,
    n_contextRegisters = 19,



};

typedef int __assert_failed_sp_offset_correct[(SP * sizeof(word_t) == (13 * 4)) ? 1 : -1];
typedef int __assert_failed_lr_svc_offset_correct[(LR_svc * sizeof(word_t) == (15 * 4)) ? 1 : -1];

typedef int __assert_failed_elr_hyp_offset_correct[(ELR_hyp * sizeof(word_t) == (15 * 4)) ? 1 : -1];

typedef int __assert_failed_faultinstruction_offset_correct[(FaultInstruction * sizeof(word_t) == (17 * 4)) ? 1 : -1];
typedef int __assert_failed_r8_offset_correct[(R8 * sizeof(word_t) == (8 * 4)) ? 1 : -1];

typedef word_t register_t;

enum messageSizes {
    n_msgRegisters = 4,
    n_frameRegisters = 10,
    n_gpRegisters = 7,
    n_exceptionMessage = 3,
    n_syscallMessage = 12,
};
# 149 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h"
extern const register_t msgRegisters[];
extern const register_t frameRegisters[];
extern const register_t gpRegisters[];


typedef struct debug_register_pair {
    word_t cr, vr;
} debug_register_pair_t;

typedef struct user_breakpoint_state {
    /* We don't use context comparisons. */
    debug_register_pair_t breakpoint[(6)],
                          watchpoint[(4)];
    uint32_t used_breakpoints_bf;
    word_t n_instructions;
    bool_t single_step_enabled;
    uint16_t single_step_hw_bp_num;
} user_breakpoint_state_t;



typedef struct user_fpu_state {
    uint64_t fpregs[32];
    uint32_t fpexc;
    uint32_t fpscr;
} user_fpu_state_t;


/* ARM user-code context: size = 72 bytes
 * Or with hardware debug support built in:
 *      72 + sizeof(word_t) * (NUM_BPS + NUM_WPS) * 2
 *
 * The "word_t registers" member of this struct must come first, because in
 * head.S, we assume that an "ldr %0, =ksCurThread" will point to the beginning
 * of the current thread's registers. The assert below should help.
 */
struct user_context {
    word_t registers[n_contextRegisters];

    user_breakpoint_state_t breakpointState;


    user_fpu_state_t fpuState;

};
typedef struct user_context user_context_t;

typedef int __assert_failed_registers_are_first_member_of_user_context[(__builtin_offsetof(user_context_t, registers) == 0) ? 1 : -1];



void Arch_initBreakpointContext(user_context_t *context);


static inline void Arch_initContext(user_context_t* context)
{
    context->registers[CPSR] = ( (1 << 6) | 0x10 | 0 );

    Arch_initBreakpointContext(context);

}
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/registerset.h" 2
# 23 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h" 2

typedef struct arch_tcb {
    /* saved user-level context of thread (72 bytes) */
    user_context_t tcbContext;

    /* Pointer to associated VCPU. NULL if not associated.
     * tcb->tcbVCPU->vcpuTCB == tcb. */
    struct vcpu* tcbVCPU;

} arch_tcb_t;

enum vm_rights {
    VMNoAccess = 0,
    VMKernelOnly = 1,
    VMReadOnly = 2,
    VMReadWrite = 3
};
typedef word_t vm_rights_t;

typedef pde_t vspace_root_t;
# 52 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
/* Generate a vcpu_t pointer from a vcpu block reference */
# 64 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
/* Page directory entries (PDEs) */
enum pde_type {
    PDEInvalid = 0,
    PDECoarse = 1,
    PDEMapping = 2
};
typedef word_t pde_type_t;







/* LPAE */
# 92 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
struct user_data {
    word_t words[(1ul << (ARMSmallPageBits)) / sizeof(word_t)];
};

typedef struct user_data user_data_t;

struct user_data_device {
    word_t words[(1ul << (ARMSmallPageBits)) / sizeof(word_t)];
};

typedef struct user_data user_data_device_t;

enum asidSizeConstants {



    asidHighBits = 7,

    asidLowBits = 10
};

struct asid_pool {
    pde_t* array[(1ul << (asidLowBits))];
};

typedef struct asid_pool asid_pool_t;
# 132 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
static inline cap_t __attribute__((__const__))
cap_small_frame_cap_set_capFMappedASID(cap_t cap, word_t asid)
{
    cap = cap_small_frame_cap_set_capFMappedASIDLow(cap,
                                                    asid & ((1ul << (asidLowBits))-1ul));
    return cap_small_frame_cap_set_capFMappedASIDHigh(cap,
                                                      (asid >> asidLowBits) & ((1ul << (asidHighBits))-1ul));
}

static inline word_t __attribute__((__const__))
cap_small_frame_cap_get_capFMappedASID(cap_t cap)
{
    return (cap_small_frame_cap_get_capFMappedASIDHigh(cap) << asidLowBits) +
           cap_small_frame_cap_get_capFMappedASIDLow(cap);
}

static inline cap_t __attribute__((__const__))
cap_frame_cap_set_capFMappedASID(cap_t cap, word_t asid)
{
    cap = cap_frame_cap_set_capFMappedASIDLow(cap,
                                              asid & ((1ul << (asidLowBits))-1ul));
    return cap_frame_cap_set_capFMappedASIDHigh(cap,
                                                (asid >> asidLowBits) & ((1ul << (asidHighBits))-1ul));
}

static inline word_t __attribute__((__const__))
cap_frame_cap_get_capFMappedASID(cap_t cap)
{
    return (cap_frame_cap_get_capFMappedASIDHigh(cap) << asidLowBits) +
           cap_frame_cap_get_capFMappedASIDLow(cap);
}

static inline word_t __attribute__((__const__))
generic_frame_cap_get_capFMappedASID(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    if(!(ctag == cap_small_frame_cap || ctag == cap_frame_cap)) _assert_fail("ctag == cap_small_frame_cap || ctag == cap_frame_cap",
                                "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
# 171 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    ,
                                172
# 171 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    , __FUNCTION__)
                                 ;

    if (ctag == cap_small_frame_cap) {
        return cap_small_frame_cap_get_capFMappedASID(cap);
    } else {
        return cap_frame_cap_get_capFMappedASID(cap);
    }
}

static inline cap_t __attribute__((__const__))
generic_frame_cap_set_capFMappedAddress(cap_t cap, word_t asid, word_t addr)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);
    if(!(ctag == cap_small_frame_cap || ctag == cap_frame_cap)) _assert_fail("ctag == cap_small_frame_cap || ctag == cap_frame_cap",
                                "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
# 187 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    ,
                                188
# 187 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    , __FUNCTION__)
                                 ;

    if (ctag == cap_small_frame_cap) {
        cap = cap_small_frame_cap_set_capFMappedASID(cap, asid);
        cap = cap_small_frame_cap_set_capFMappedAddress(cap, addr);
        return cap;
    } else {
        cap = cap_frame_cap_set_capFMappedASID(cap, asid);
        cap = cap_frame_cap_set_capFMappedAddress(cap, addr);
        return cap;
    }
}

static inline void
generic_frame_cap_ptr_set_capFMappedAddress(cap_t *cap_ptr, word_t asid,
                                            word_t addr)
{
    *cap_ptr = generic_frame_cap_set_capFMappedAddress(*cap_ptr, asid, addr);
}

static inline vm_rights_t __attribute__((__const__))
generic_frame_cap_get_capFVMRights(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);
    if(!(ctag == cap_small_frame_cap || ctag == cap_frame_cap)) _assert_fail("ctag == cap_small_frame_cap || ctag == cap_frame_cap",
                                "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
# 214 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    ,
                                215
# 214 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    , __FUNCTION__)
                                 ;

    switch (ctag) {
    case cap_small_frame_cap:
        return cap_small_frame_cap_get_capFVMRights(cap);

    case cap_frame_cap:
        return cap_frame_cap_get_capFVMRights(cap);

    default:
        return VMNoAccess;
    }
}

static inline word_t __attribute__((__const__))
generic_frame_cap_get_capFBasePtr(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);
    if(!(ctag == cap_small_frame_cap || ctag == cap_frame_cap)) _assert_fail("ctag == cap_small_frame_cap || ctag == cap_frame_cap",
                                "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
# 235 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    ,
                                236
# 235 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    , __FUNCTION__)
                                 ;

    switch (ctag) {
    case cap_small_frame_cap:
        return cap_small_frame_cap_get_capFBasePtr(cap);

    case cap_frame_cap:
        return cap_frame_cap_get_capFBasePtr(cap);

    default:
        return 0;
    }
}

static inline word_t __attribute__((__const__))
generic_frame_cap_get_capFSize(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);
    if(!(ctag == cap_small_frame_cap || ctag == cap_frame_cap)) _assert_fail("ctag == cap_small_frame_cap || ctag == cap_frame_cap",
                                "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
# 256 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    ,
                                257
# 256 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    , __FUNCTION__)
                                 ;

    switch (ctag) {
    case cap_small_frame_cap:
        return ARMSmallPage;

    case cap_frame_cap:
        return cap_frame_cap_get_capFSize(cap);

    default:
        return 0;
    }
}

static inline word_t __attribute__((__const__))
generic_frame_cap_get_capFIsMapped(cap_t cap)
{
    return generic_frame_cap_get_capFMappedASID(cap) != 0;
}

static inline word_t __attribute__((__const__))
generic_frame_cap_get_capFMappedAddress(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);
    if(!(ctag == cap_small_frame_cap || ctag == cap_frame_cap)) _assert_fail("ctag == cap_small_frame_cap || ctag == cap_frame_cap",
                                "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
# 283 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    ,
                                284
# 283 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    , __FUNCTION__)
                                 ;

    if (ctag == cap_small_frame_cap) {
        return cap_small_frame_cap_get_capFMappedAddress(cap);
    } else {
        return cap_frame_cap_get_capFMappedAddress(cap);
    }
}

static inline word_t __attribute__((__const__))
generic_frame_cap_get_capFIsDevice(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);
    if(!(ctag == cap_small_frame_cap || ctag == cap_frame_cap)) _assert_fail("ctag == cap_small_frame_cap || ctag == cap_frame_cap",
                                "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
# 299 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    ,
                                300
# 299 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/object/structures.h"
    , __FUNCTION__)
                                 ;

    if (ctag == cap_small_frame_cap) {
        return cap_small_frame_cap_get_capFIsDevice(cap);
    } else {
        return cap_frame_cap_get_capFIsDevice(cap);
    }
}

static inline word_t __attribute__((__const__))
cap_get_archCapSizeBits(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    switch (ctag) {
    case cap_small_frame_cap:
    case cap_frame_cap:
        return pageBitsForSize(generic_frame_cap_get_capFSize(cap));

    case cap_page_table_cap:
        return 12;

    case cap_page_directory_cap:
        return 14;

    case cap_asid_pool_cap:
        return 12;

    case cap_asid_control_cap:
        return 0;


    case cap_vcpu_cap:
        return 12;






    default:
        /* Unreachable, but GCC can't figure that out */
        return 0;
    }
}

static inline bool_t __attribute__((__const__))
cap_get_archCapIsPhysical(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    switch (ctag) {

    case cap_small_frame_cap:
        return true;

    case cap_frame_cap:
        return true;

    case cap_page_table_cap:
        return true;

    case cap_page_directory_cap:
        return true;

    case cap_asid_pool_cap:
        return true;

    case cap_asid_control_cap:
        return false;


    case cap_vcpu_cap:
        return true;







    default:
        /* Unreachable, but GCC can't figure that out */
        return false;
    }
}

static inline void * __attribute__((__const__))
cap_get_archCapPtr(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    switch (ctag) {

    case cap_small_frame_cap:
    case cap_frame_cap:
        return (void *)(generic_frame_cap_get_capFBasePtr(cap));

    case cap_page_table_cap:
        return ((pte_t *)cap_page_table_cap_get_capPTBasePtr(cap));

    case cap_page_directory_cap:
        return ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(cap)));

    case cap_asid_pool_cap:
        return ((asid_pool_t *)cap_asid_pool_cap_get_capASIDPool(cap));

    case cap_asid_control_cap:
        return ((void *)0);


    case cap_vcpu_cap:
        return ((struct vcpu *)(cap_vcpu_cap_get_capVCPUPtr(cap)));







    default:
        /* Unreachable, but GCC can't figure that out */
        return ((void *)0);
    }
}
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/structures.h" 2
# 179 "/home/sel4/work/work2/kernel/include/object/structures.h" 2

static inline word_t __attribute__((__const__))
wordFromVMRights(vm_rights_t vm_rights)
{
    return (word_t)vm_rights;
}

static inline vm_rights_t __attribute__((__const__))
vmRightsFromWord(word_t w)
{
    return (vm_rights_t)w;
}

static inline vm_attributes_t __attribute__((__const__))
vmAttributesFromWord(word_t w)
{
    vm_attributes_t attr;

    attr.words[0] = w;
    return attr;
}

/* TCB: size 64 bytes + sizeof(arch_tcb_t) (aligned to nearest power of 2) */
struct tcb {
    /* arch specific tcb state (including context)*/
    arch_tcb_t tcbArch;

    /* Thread state, 12 bytes */
    thread_state_t tcbState;

    /* Notification that this TCB is bound to. If this is set, when this TCB waits on
     * any sync endpoint, it may receive a signal from a Notification object.
     * 4 bytes*/
    notification_t *tcbBoundNotification;

    /* Current fault, 8 bytes */
    seL4_Fault_t tcbFault;

    /* Current lookup failure, 8 bytes */
    lookup_fault_t tcbLookupFailure;

    /* Domain, 1 byte (packed to 4) */
    dom_t tcbDomain;

    /*  maximum controlled priorioty, 1 byte (packed to 4) */
    prio_t tcbMCP;

    /* Priority, 1 byte (packed to 4) */
    prio_t tcbPriority;

    /* Timeslice remaining, 4 bytes */
    word_t tcbTimeSlice;

    /* Capability pointer to thread fault handler, 4 bytes */
    cptr_t tcbFaultHandler;

    /* userland virtual address of thread IPC buffer, 4 bytes */
    word_t tcbIPCBuffer;






    /* Previous and next pointers for scheduler queues , 8 bytes */
    struct tcb* tcbSchedNext;
    struct tcb* tcbSchedPrev;
    /* Preivous and next pointers for endpoint and notification queues, 8 bytes */
    struct tcb* tcbEPNext;
    struct tcb* tcbEPPrev;






    /* Pointers for list of all tcbs that is maintained
     * when CONFIG_DEBUG_BUILD is enabled */
    struct tcb *tcbDebugNext;
    struct tcb *tcbDebugPrev;
    /* Use any remaining space for a thread name */
    char tcbName[];

};
typedef struct tcb tcb_t;

/* Ensure object sizes are sane */
typedef int __assert_failed_cte_size_sane[(sizeof(cte_t) <= (1ul << (4))) ? 1 : -1];
typedef int __assert_failed_tcb_size_sane[((1ul << ((4 + 4))) + sizeof(tcb_t) <= (1ul << (10))) ? 1 : -1];

typedef int __assert_failed_ep_size_sane[(sizeof(endpoint_t) <= (1ul << (4))) ? 1 : -1];
typedef int __assert_failed_notification_size_sane[(sizeof(notification_t) <= (1ul << (4))) ? 1 : -1];


/* helper functions */

static inline word_t __attribute__((__const__))
isArchCap(cap_t cap)
{
    return (cap_get_capType(cap) % 2);
}

static inline word_t __attribute__((__const__))
cap_get_capSizeBits(cap_t cap)
{

    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    switch (ctag) {
    case cap_untyped_cap:
        return cap_untyped_cap_get_capBlockSize(cap);

    case cap_endpoint_cap:
        return 4;

    case cap_notification_cap:
        return 4;

    case cap_cnode_cap:
        return cap_cnode_cap_get_capCNodeRadix(cap) + 4;

    case cap_thread_cap:
        return 10;

    case cap_zombie_cap: {
        word_t type = cap_zombie_cap_get_capZombieType(cap);
        if (type == (1ul << (5))) {
            return 10;
        }
        return ((type) & ((1ul << (5))-1ul)) + 4;
    }

    case cap_null_cap:
        return 0;

    case cap_domain_cap:
        return 0;

    case cap_reply_cap:
        return 0;

    case cap_irq_control_cap:
        return 0;

    case cap_irq_handler_cap:
        return 0;

    default:
        return cap_get_archCapSizeBits(cap);
    }

}

/* Returns whether or not this capability has memory associated
 * with it or not. Refering to this as 'being physical' is to
 * match up with the haskell and abstract specifications */
static inline bool_t __attribute__((__const__))
cap_get_capIsPhysical(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    switch (ctag) {
    case cap_untyped_cap:
        return true;

    case cap_endpoint_cap:
        return true;

    case cap_notification_cap:
        return true;

    case cap_cnode_cap:
        return true;

    case cap_thread_cap:
        return true;

    case cap_zombie_cap:
        return true;

    case cap_domain_cap:
        return false;

    case cap_reply_cap:
        return false;

    case cap_irq_control_cap:
        return false;

    case cap_irq_handler_cap:
        return false;

    default:
        return cap_get_archCapIsPhysical(cap);
    }
}

static inline void * __attribute__((__const__))
cap_get_capPtr(cap_t cap)
{
    cap_tag_t ctag;

    ctag = cap_get_capType(cap);

    switch (ctag) {
    case cap_untyped_cap:
        return ((word_t *)(cap_untyped_cap_get_capPtr(cap)));

    case cap_endpoint_cap:
        return ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(cap)));

    case cap_notification_cap:
        return ((notification_t *)(cap_notification_cap_get_capNtfnPtr(cap)));

    case cap_cnode_cap:
        return ((cte_t *)(cap_cnode_cap_get_capCNodePtr(cap)));

    case cap_thread_cap:
        return (((cte_t *)((word_t)(cap_thread_cap_get_capTCBPtr(cap))&~((1ul << (10))-1ul)))+(0));

    case cap_zombie_cap:
        return ((cte_t *)(cap_zombie_cap_get_capZombiePtr(cap)));

    case cap_domain_cap:
        return ((void *)0);

    case cap_reply_cap:
        return ((void *)0);

    case cap_irq_control_cap:
        return ((void *)0);

    case cap_irq_handler_cap:
        return ((void *)0);
    default:
        return cap_get_archCapPtr(cap);

    }
}
# 17 "/home/sel4/work/work2/kernel/include/compound_types.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/compound_types.h" 2

struct pde_range {
    pde_t *base;
    word_t length;
};
typedef struct pde_range pde_range_t;

struct pte_range {
    pte_t *base;
    word_t length;
};
typedef struct pte_range pte_range_t;

typedef cte_t *cte_ptr_t;

struct extra_caps {
    cte_ptr_t excaprefs[((1ul<<(seL4_MsgExtraCapBits))-1)];
};
typedef struct extra_caps extra_caps_t;
# 16 "/home/sel4/work/work2/kernel/include/types.h" 2
# 15 "/home/sel4/work/work2/kernel/src/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/faults.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */



# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/api/faults.h" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/api/faults.h" 2

word_t setMRs_fault(tcb_t *sender, tcb_t* receiver, word_t *receiveIPCBuffer);
word_t Arch_setMRs_fault(tcb_t *sender, tcb_t* receiver, word_t *receiveIPCBuffer, word_t faultType);

bool_t handleFaultReply(tcb_t *receiver, tcb_t *sender);
bool_t Arch_handleFaultReply(tcb_t *receiver, tcb_t *sender, word_t faultType);
# 16 "/home/sel4/work/work2/kernel/src/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 2



enum IRQConstants {
//  INTERRUPT_RESERVED          =   0,
//  INTERRUPT_RESERVED          =   1,
//  INTERRUPT_RESERVED          =   2,
//  INTERRUPT_RESERVED          =   3,
//  INTERRUPT_RESERVED          =   4,
//  INTERRUPT_RESERVED          =   5,
//  INTERRUPT_RESERVED          =   6,
//  INTERRUPT_RESERVED          =   7,
//  INTERRUPT_RESERVED          =   8,
//  INTERRUPT_RESERVED          =   9,
//  INTERRUPT_RESERVED          =  10,
//  INTERRUPT_RESERVED          =  11,
//  INTERRUPT_RESERVED          =  12,
//  INTERRUPT_RESERVED          =  13,
//  INTERRUPT_RESERVED          =  14,
//  INTERRUPT_RESERVED          =  15,
//  INTERRUPT_RESERVED          =  16,
//  INTERRUPT_RESERVED          =  17,
//  INTERRUPT_RESERVED          =  18,
//  INTERRUPT_RESERVED          =  19,
//  INTERRUPT_RESERVED          =  20,
//  INTERRUPT_RESERVED          =  21,
//  INTERRUPT_RESERVED          =  22,
//  INTERRUPT_RESERVED          =  23,
//  INTERRUPT_RESERVED          =  24,
    INTERRUPT_VGIC_MAINTENANCE = 25,
    INTERRUPT_CNTHPIRQ = 26,
    INTERRUPT_CNTVIRQ = 27,
//  INTERRUPT_RESERVED          =  28,
    INTERRUPT_CNTPSIRQ = 29,
    INTERRUPT_CNTPNSIRQ = 30,
//  INTERRUPT_RESERVED          =  31,
    INTERRUPT_INTG00 = 32,
    INTERRUPT_INTG01 = 33,
    INTERRUPT_INTG02 = 34,
    INTERRUPT_INTG03 = 35,
    INTERRUPT_INTG04 = 36,
    INTERRUPT_INTG05 = 37,
    INTERRUPT_INTG06 = 38,
    INTERRUPT_INTG07 = 39,
    INTERRUPT_INTG08 = 40,
    INTERRUPT_INTG09 = 41,
    INTERRUPT_INTG10 = 42,
    INTERRUPT_INTG11 = 43,
    INTERRUPT_INTG12 = 44,
    INTERRUPT_INTG13 = 45,
    INTERRUPT_INTG14 = 46,
    INTERRUPT_INTG15 = 47,
    INTERRUPT_INTG16 = 48,
    INTERRUPT_INTG17 = 49,
    INTERRUPT_INTG18 = 50,
    INTERRUPT_INTG19 = 51,
    INTERRUPT_INTG20 = 52,
    INTERRUPT_INTG21 = 53,
    INTERRUPT_INTG22 = 54,
    INTERRUPT_INTG23 = 55,
    INTERRUPT_INTG24 = 56,
    INTERRUPT_INTG25 = 57,
    INTERRUPT_INTG26 = 58,
    INTERRUPT_INTG27 = 59,
    INTERRUPT_INTG28 = 60,
    INTERRUPT_INTG29 = 61,
    INTERRUPT_INTG30 = 62,
    INTERRUPT_INTG31 = 63,
    INTERRUPT_EINT16_31 = 64,



    INTERRUPT_TMU_CPU0 = 65,


    INTERRUPT_PDMA0 = 66,
    INTERRUPT_PDMA1 = 67,
    INTERRUPT_TIMER0 = 68,
    INTERRUPT_TIMER1 = 69,
    INTERRUPT_TIMER2 = 70,
    INTERRUPT_TIMER3 = 71,
    INTERRUPT_TIMER4 = 72,
    INTERRUPT_RTIC = 73,
    INTERRUPT_WDT = 74,
    INTERRUPT_RTC_ALARM = 75,
    INTERRUPT_RTC_TIC = 76,
    INTERRUPT_GPIO_RT = 77,
    INTERRUPT_GPIO_LB = 78,
    INTERRUPT_GPIO = 79,
//  INTERRUPT_RESERVED          =  80,
//  INTERRUPT_RESERVED          =  81,
    INTERRUPT_GPIO_C2C = 82,
    INTERRUPT_UART0 = 83,
    INTERRUPT_UART1 = 84,
    INTERRUPT_UART2 = 85,
    INTERRUPT_UART3 = 86,
    INTERRUPT_MONOCNT = 87,
    INTERRUPT_I2C0USI0 = 88,
    INTERRUPT_I2C1USI1 = 89,
    INTERRUPT_I2C2USI2 = 90,
    INTERRUPT_I2C3USI3 = 91,
    INTERRUPT_I2C4 = 92,
    INTERRUPT_I2C5 = 93,
    INTERRUPT_I2C6 = 94,
    INTERRUPT_I2C7 = 95,
    INTERRUPT_I2C = 96,
    INTERRUPT_TMU = 97,
    INTERRUPT_CPU_FIQ0 = 98,
    INTERRUPT_CPU_FIQ1 = 99,
    INTERRUPT_SPI0 = 100,
    INTERRUPT_SPI1 = 101,
    INTERRUPT_SPI2 = 102,
    INTERRUPT_USB_HOST20 = 103,
    INTERRUPT_USB_DRD30 = 104,
    INTERRUPT_MIPI_HSI = 105,
    INTERRUPT_USBOTG = 106,
    INTERRUPT_SDMMC0 = 107,
    INTERRUPT_SDMMC1 = 108,
    INTERRUPT_SDMMC2 = 109,
    INTERRUPT_SDMMC3 = 110,
    INTERRUPT_MIPI_CSI_A = 111,
    INTERRUPT_MIPI_CSI_B = 112,
    INTERRUPT_EFNFCON_DMA_ABORT = 113,
    INTERRUPT_MIPI_DSI_4LANE = 114,
    INTERRUPT_WDT_IOP = 115,
    INTERRUPT_ROTATOR = 116,
    INTERRUPT_GSCL0 = 117,
    INTERRUPT_GSCL1 = 118,
    INTERRUPT_GSCL2 = 119,
    INTERRUPT_GSCL3 = 120,
    INTERRUPT_JPEG = 121,
    INTERRUPT_EFNFCON_DMA = 122,
    INTERRUPT_G2D = 123,
    INTERRUPT_EFNFCON_0 = 124,
    INTERRUPT_EFNFCON_1 = 125,
    INTERRUPT_MIXER = 126,
    INTERRUPT_HDMI = 127,
    INTERRUPT_MFC = 128,
    INTERRUPT_AUDIO_SS = 129,
    INTERRUPT_I2S0 = 130,
    INTERRUPT_I2S1 = 131,
    INTERRUPT_I2S2 = 132,
    INTERRUPT_AC97 = 133,
    INTERRUPT_PCM0 = 134,
    INTERRUPT_PCM1 = 135,
    INTERRUPT_PCM2 = 136,
    INTERRUPT_SPDIF = 137,
    INTERRUPT_ADC0 = 138,
//  INTERRUPT_RESERVED          = 139,
    INTERRUPT_SATAPHY = 140,
    INTERRUPT_SATAPMEREQ = 141,
    INTERRUPT_CAM_C = 142,
    INTERRUPT_PMU = 143,
    INTERRUPT_INTFEEDCTRL_SSS = 144,
    INTERRUPT_DP1_1 = 145,
    INTERRUPT_CEC = 146,
    INTERRUPT_SATA = 147,
//  INTERRUPT_RESERVED          = 148,
    INTERRUPT_G3D_IRQGPU = 149,
    INTERRUPT_G3D_IRQJOB = 150,
    INTERRUPT_G3D_IRQMMU = 151,
    INTERRUPT_MCT_L0 = 152,
    INTERRUPT_MCT_L1 = 153,
//  INTERRUPT_RESERVED          = 154,
//  INTERRUPT_RESERVED          = 155,
    INTERRUPT_MDMA1 = 156,
    INTERRUPT_CAM_A = 157,
    INTERRUPT_CAM_B = 158,
    INTERRUPT_RP_TIMER = 159,

    INTERRUPT_TMU_CPU1 = 183,
    INTERRUPT_TMU_CPU2 = 184,
    INTERRUPT_TMU_CPU3 = 185,

    INTERRUPT_TMU_GPU = 215,

    INTERRUPT_216 = 216,
    INTERRUPT_217 = 217,
    INTERRUPT_218 = 218,
    INTERRUPT_219 = 219,
    INTERRUPT_220 = 220,
    INTERRUPT_232 = 232,
    maxIRQ = 232
} platform_interrupt_t;
# 208 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h"
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/gic_pl390.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/*
 * ARM Generic Interrupt Controller PL-390
 */



# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/gic_pl390.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/gic_pl390.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 2

/* code that is only used during kernel bootstrapping */


/* read-only data only used during kernel bootstrapping */


/* read/write data only used during kernel bootstrapping */


/* data will be aligned to n bytes in a special BSS section */
# 20 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/gic_pl390.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/smp/smp.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/smp/smp.h" 2
# 21 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/gic_pl390.h" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/model/statedata.h" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/model/statedata.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/model/statedata.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/object/tcb.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/api/failures.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/errors.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */




typedef enum {
    seL4_NoError = 0,
    seL4_InvalidArgument,
    seL4_InvalidCapability,
    seL4_IllegalOperation,
    seL4_RangeError,
    seL4_AlignmentError,
    seL4_FailedLookup,
    seL4_TruncatedMessage,
    seL4_DeleteFirst,
    seL4_RevokeFirst,
    seL4_NotEnoughMemory,

    /* This should always be the last item in the list
     * so it gives a count of the number of errors in the
     * enum.
     */
    seL4_NumErrors
} seL4_Error;
# 16 "/home/sel4/work/work2/kernel/include/api/failures.h" 2
/* These datatypes differ markedly from haskell, due to the
 * different implementation of the various fault monads */


enum exception {
    EXCEPTION_NONE,
    EXCEPTION_FAULT,
    EXCEPTION_LOOKUP_FAULT,
    EXCEPTION_SYSCALL_ERROR,
    EXCEPTION_PREEMPTED
};
typedef word_t exception_t;

typedef word_t syscall_error_type_t;

struct syscall_error {
    word_t invalidArgumentNumber;
    word_t invalidCapNumber;
    word_t rangeErrorMin;
    word_t rangeErrorMax;
    word_t memoryLeft;
    bool_t failedLookupWasSource;

    syscall_error_type_t type;
};
typedef struct syscall_error syscall_error_t;

extern lookup_fault_t current_lookup_fault;
extern seL4_Fault_t current_fault;
extern syscall_error_t current_syscall_error;
# 16 "/home/sel4/work/work2/kernel/include/object/tcb.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/object/tcb.h" 2

# 1 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 2

typedef enum {
    MessageID_Syscall,
    MessageID_Exception
} MessageID_t;


extern const register_t fault_messages[][(((n_syscallMessage)>(n_exceptionMessage))?(n_syscallMessage):(n_exceptionMessage))] __attribute__((externally_visible));

static inline void
setRegister(tcb_t *thread, register_t reg, word_t w)
{
    thread->tcbArch.tcbContext.registers[reg] = w;
}

static inline word_t __attribute__((__pure__))
getRegister(tcb_t *thread, register_t reg)
{
    return thread->tcbArch.tcbContext.registers[reg];
}
# 19 "/home/sel4/work/work2/kernel/include/object/tcb.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/object/cnode.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/object/cnode.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/object/cnode.h" 2

struct slot_range {
    cte_t *cnode;
    word_t offset;
    word_t length;
};
typedef struct slot_range slot_range_t;

exception_t decodeCNodeInvocation(word_t invLabel, word_t length,
                                  cap_t cap, extra_caps_t excaps,
                                  word_t *buffer);
exception_t invokeCNodeRevoke(cte_t *destSlot);
exception_t invokeCNodeDelete(cte_t *destSlot);
exception_t invokeCNodeCancelBadgedSends(cap_t cap);
exception_t invokeCNodeInsert(cap_t cap, cte_t *srcSlot, cte_t *destSlot);
exception_t invokeCNodeMove(cap_t cap, cte_t *srcSlot, cte_t *destSlot);
exception_t invokeCNodeRotate(cap_t cap1, cap_t cap2, cte_t *slot1,
                              cte_t *slot2, cte_t *slot3);
exception_t invokeCNodeSaveCaller(cte_t *destSlot);
void cteInsert(cap_t newCap, cte_t *srcSlot, cte_t *destSlot);
void cteMove(cap_t newCap, cte_t *srcSlot, cte_t *destSlot);
void capSwapForDelete(cte_t *slot1, cte_t *slot2);
void cteSwap(cap_t cap1, cte_t *slot1, cap_t cap2, cte_t *slot2);
exception_t cteRevoke(cte_t *slot);
exception_t cteDelete(cte_t *slot, bool_t exposed);
void cteDeleteOne(cte_t* slot);
void insertNewCap(cte_t *parent, cte_t *slot, cap_t cap);
void setupReplyMaster(tcb_t *thread);
bool_t __attribute__((__pure__)) isMDBParentOf(cte_t *cte_a, cte_t *cte_b);
exception_t ensureNoChildren(cte_t *slot);
exception_t ensureEmptySlot(cte_t *slot);
bool_t __attribute__((__pure__)) isFinalCapability(cte_t *cte);
bool_t __attribute__((__pure__)) slotCapLongRunningDelete(cte_t *slot);
cte_t *getReceiveSlots(tcb_t *thread, word_t *buffer);
cap_transfer_t __attribute__((__pure__)) loadCapTransfer(word_t *buffer);
# 20 "/home/sel4/work/work2/kernel/include/object/tcb.h" 2


/* Maximum length of the tcb name, including null terminator */

typedef int __assert_failed_tcb_name_fits[(((1ul << (10)) - (1ul << ((4 + 4))) - sizeof(tcb_t)) > 0) ? 1 : -1];


struct tcb_queue {
    tcb_t *head;
    tcb_t *end;
};
typedef struct tcb_queue tcb_queue_t;

static inline unsigned int
setMR(tcb_t *receiver, word_t* receiveIPCBuffer,
      unsigned int offset, word_t reg)
{
    if (offset >= n_msgRegisters) {
        if (receiveIPCBuffer) {
            receiveIPCBuffer[offset + 1] = reg;
            return offset + 1;
        } else {
            return n_msgRegisters;
        }
    } else {
        setRegister(receiver, msgRegisters[offset], reg);
        return offset + 1;
    }
}

void tcbSchedEnqueue(tcb_t *tcb);
void tcbSchedAppend(tcb_t *tcb);
void tcbSchedDequeue(tcb_t *tcb);


void tcbDebugAppend(tcb_t *tcb);
void tcbDebugRemove(tcb_t *tcb);
# 81 "/home/sel4/work/work2/kernel/include/object/tcb.h"
tcb_queue_t tcbEPAppend(tcb_t *tcb, tcb_queue_t queue);
tcb_queue_t tcbEPDequeue(tcb_t *tcb, tcb_queue_t queue);

void setupCallerCap(tcb_t *sender, tcb_t *receiver);
void deleteCallerCap(tcb_t *receiver);

word_t copyMRs(tcb_t *sender, word_t *sendBuf, tcb_t *receiver,
               word_t *recvBuf, word_t n);
exception_t decodeTCBInvocation(word_t invLabel, word_t length, cap_t cap,
                                cte_t* slot, extra_caps_t excaps, bool_t call,
                                word_t *buffer);
exception_t decodeCopyRegisters(cap_t cap, word_t length,
                                extra_caps_t excaps, word_t *buffer);
exception_t decodeReadRegisters(cap_t cap, word_t length, bool_t call,
                                word_t *buffer);
exception_t decodeWriteRegisters(cap_t cap, word_t length, word_t *buffer);
exception_t decodeTCBConfigure(cap_t cap, word_t length,
                               cte_t* slot, extra_caps_t rootCaps, word_t *buffer);
exception_t decodeSetPriority(cap_t cap, word_t length, word_t *buffer);
exception_t decodeSetMCPriority(cap_t cap, word_t length, word_t *buffer);
exception_t decodeSetIPCBuffer(cap_t cap, word_t length,
                               cte_t* slot, extra_caps_t excaps, word_t *buffer);
exception_t decodeSetSpace(cap_t cap, word_t length,
                           cte_t* slot, extra_caps_t excaps, word_t *buffer);
exception_t decodeDomainInvocation(word_t invLabel, word_t length,
                                   extra_caps_t excaps, word_t *buffer);
exception_t decodeBindNotification(cap_t cap, extra_caps_t excaps);
exception_t decodeUnbindNotification(cap_t cap);

enum thread_control_flag {
    thread_control_update_priority = 0x1,
    thread_control_update_ipc_buffer = 0x2,
    thread_control_update_space = 0x4,
    thread_control_update_mcp = 0x8,
    thread_control_update_all = 0xF,
};

typedef word_t thread_control_flag_t;

exception_t invokeTCB_Suspend(tcb_t *thread);
exception_t invokeTCB_Resume(tcb_t *thread);
exception_t invokeTCB_ThreadControl(tcb_t *target, cte_t* slot, cptr_t faultep,
                                    prio_t mcp, prio_t priority, cap_t cRoot_newCap,
                                    cte_t *cRoot_srcSlot, cap_t vRoot_newCap,
                                    cte_t *vRoot_srcSlot, word_t bufferAddr,
                                    cap_t bufferCap, cte_t *bufferSrcSlot,
                                    thread_control_flag_t updateFlags);
exception_t invokeTCB_CopyRegisters(tcb_t *dest, tcb_t *src,
                                    bool_t suspendSource, bool_t resumeTarget,
                                    bool_t transferFrame, bool_t transferInteger,
                                    word_t transferArch);
exception_t invokeTCB_ReadRegisters(tcb_t *src, bool_t suspendSource,
                                    word_t n, word_t arch, bool_t call);
exception_t invokeTCB_WriteRegisters(tcb_t *dest, bool_t resumeTarget,
                                     word_t n, word_t arch, word_t *buffer);
exception_t invokeTCB_NotificationControl(tcb_t *tcb, notification_t *ntfnPtr);

cptr_t __attribute__((__pure__)) getExtraCPtr(word_t *bufferPtr, word_t i);
void setExtraBadge(word_t *bufferPtr, word_t badge, word_t i);

exception_t lookupExtraCaps(tcb_t* thread, word_t *bufferPtr, seL4_MessageInfo_t info);
word_t setMRs_syscall_error(tcb_t *thread, word_t *receiveIPCBuffer);
word_t __attribute__((__const__)) Arch_decodeTransfer(word_t flags);
exception_t __attribute__((__const__)) Arch_performTransfer(word_t arch, tcb_t *tcb_src,
                                       tcb_t *tcb_dest);






void setThreadName(tcb_t *thread, const char *name);


void Arch_setTCBIPCBuffer(tcb_t *thread, word_t bufferAddr);
# 20 "/home/sel4/work/work2/kernel/include/model/statedata.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/types.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/include/model/statedata.h" 2
# 43 "/home/sel4/work/work2/kernel/include/model/statedata.h"
/* UP states are declared as VISIBLE so that they are accessible in assembly */
# 60 "/home/sel4/work/work2/kernel/include/model/statedata.h"

extern tcb_queue_t ksReadyQueues[(1 * 256)] __attribute__((externally_visible));
extern word_t ksReadyQueuesL1Bitmap[1] __attribute__((externally_visible));
extern word_t ksReadyQueuesL2Bitmap[1][(256 / (1 << 5)) + 1] __attribute__((externally_visible));
extern tcb_t *ksCurThread __attribute__((externally_visible));
extern tcb_t *ksIdleThread __attribute__((externally_visible));
extern tcb_t *ksSchedulerAction __attribute__((externally_visible));


/* Current state installed in the FPU, or NULL if the FPU is currently invalid */
extern user_fpu_state_t * ksActiveFPUState __attribute__((externally_visible));
/* Number of times we have restored a user context with an active FPU without switching it */
extern word_t ksFPURestoresSinceSwitch __attribute__((externally_visible));


extern tcb_t * ksDebugTCBs __attribute__((externally_visible));


;

extern word_t ksNumCPUs;

extern word_t ksWorkUnitsCompleted;
extern irq_state_t intStateIRQTable[];
extern cte_t *intStateIRQNode;
extern const dschedule_t ksDomSchedule[];
extern const word_t ksDomScheduleLength;
extern word_t ksDomScheduleIdx;
extern dom_t ksCurDomain;
extern word_t ksDomainTime;
extern word_t tlbLockCount __attribute__((externally_visible));
# 22 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/gic_pl390.h" 2

typedef uint16_t interrupt_t;
typedef uint16_t irq_t;

enum irqNumbers {
    irqInvalid = (irq_t) - 1
};

/* Special IRQ's */



/* Setters/getters helpers */





/* Memory map for GIC distributor */
struct gic_dist_map {
    uint32_t enable; /* 0x000 */
    uint32_t ic_type; /* 0x004 */
    uint32_t dist_ident; /* 0x008 */
    uint32_t res1[29]; /* [0x00C, 0x080) */

    uint32_t security[32]; /* [0x080, 0x100) */

    uint32_t enable_set[32]; /* [0x100, 0x180) */
    uint32_t enable_clr[32]; /* [0x180, 0x200) */
    uint32_t pending_set[32]; /* [0x200, 0x280) */
    uint32_t pending_clr[32]; /* [0x280, 0x300) */
    uint32_t active[32]; /* [0x300, 0x380) */
    uint32_t res2[32]; /* [0x380, 0x400) */

    uint32_t priority[255]; /* [0x400, 0x7FC) */
    uint32_t res3; /* 0x7FC */

    uint32_t targets[255]; /* [0x800, 0xBFC) */
    uint32_t res4; /* 0xBFC */

    uint32_t config[64]; /* [0xC00, 0xD00) */

    uint32_t spi[32]; /* [0xD00, 0xD80) */
    uint32_t res5[20]; /* [0xD80, 0xDD0) */
    uint32_t res6; /* 0xDD0 */
    uint32_t legacy_int; /* 0xDD4 */
    uint32_t res7[2]; /* [0xDD8, 0xDE0) */
    uint32_t match_d; /* 0xDE0 */
    uint32_t enable_d; /* 0xDE4 */
    uint32_t res8[70]; /* [0xDE8, 0xF00) */

    uint32_t sgi_control; /* 0xF00 */
    uint32_t res9[3]; /* [0xF04, 0xF10) */
    uint32_t sgi_pending_clr[4]; /* [0xF10, 0xF20) */
    uint32_t res10[40]; /* [0xF20, 0xFC0) */

    uint32_t periph_id[12]; /* [0xFC0, 0xFF0) */
    uint32_t component_id[4]; /* [0xFF0, 0xFFF] */
};

/* Memory map for GIC  cpu interface */
struct gic_cpu_iface_map {
    uint32_t icontrol; /*  0x000         */
    uint32_t pri_msk_c; /*  0x004         */
    uint32_t pb_c; /*  0x008         */
    uint32_t int_ack; /*  0x00C         */
    uint32_t eoi; /*  0x010         */
    uint32_t run_priority; /*  0x014         */
    uint32_t hi_pend; /*  0x018         */
    uint32_t ns_alias_bp_c; /*  0x01C         */
    uint32_t ns_alias_ack; /*  0x020 GIC400 only */
    uint32_t ns_alias_eoi; /*  0x024 GIC400 only */
    uint32_t ns_alias_hi_pend; /*  0x028 GIC400 only */

    uint32_t res1[5]; /* [0x02C, 0x040) */

    uint32_t integ_en_c; /*  0x040 PL390 only */
    uint32_t interrupt_out; /*  0x044 PL390 only */
    uint32_t res2[2]; /* [0x048, 0x050)    */

    uint32_t match_c; /*  0x050 PL390 only */
    uint32_t enable_c; /*  0x054 PL390 only */

    uint32_t res3[30]; /* [0x058, 0x0FC)  */
    uint32_t active_priority[4]; /* [0x0D0, 0xDC] GIC400 only */
    uint32_t ns_active_priority[4]; /* [0xE0,0xEC] GIC400 only */
    uint32_t res4[3];

    uint32_t cpu_if_ident; /*  0x0FC         */
    uint32_t res5[948]; /* [0x100. 0xFC0) */

    uint32_t periph_id[8]; /* [0xFC0, 9xFF0) PL390 only */
    uint32_t component_id[4]; /* [0xFF0, 0xFFF] PL390 only */
};

extern volatile struct gic_dist_map * const gic_dist;
extern volatile struct gic_cpu_iface_map * const gic_cpuiface;
/*
 * The only sane way to get an GIC IRQ number that can be properly
 * ACKED later is through the int_ack register. Unfortunately, reading
 * this register changes the interrupt state to pending so future
 * reads will not return the same value For this reason, we have a
 * global variable to store the IRQ number.
 */
extern uint32_t active_irq[1];

/* Helpers */
static inline int
is_irq_edge_triggered(irq_t irq)
{
    int word = irq >> 4;
    int bit = ((irq & 0xf) * 2);
    return !!(gic_dist->config[word] & (1ul << (bit + 1)));
}

static inline void
dist_pending_clr(irq_t irq)
{
    int word = ((irq) >> 5u);
    int bit = ((irq) & 0x1f);
    /* Using |= here is detrimental to your health */
    gic_dist->pending_clr[word] = (1ul << (bit));
}

static inline void
dist_enable_clr(irq_t irq)
{
    int word = ((irq) >> 5u);
    int bit = ((irq) & 0x1f);
    /* Using |= here is detrimental to your health */
    gic_dist->enable_clr[word] = (1ul << (bit));
}

static inline void
dist_enable_set(irq_t irq)
{
    int word = ((irq) >> 5u);
    int bit = ((irq) & 0x1f);
    gic_dist->enable_set[word] = (1ul << (bit));
}

static inline interrupt_t
getActiveIRQ(void)
{
    uint32_t irq;
    if (!(((active_irq[0]) & ((1ul << (10u))-1ul)) < 1020u)) {
        active_irq[0] = gic_cpuiface->int_ack;
    }

    if ((((active_irq[0]) & ((1ul << (10u))-1ul)) < 1020u)) {
        irq = active_irq[0] & ((1ul << (10u))-1ul);
    } else {
        irq = irqInvalid;
    }

    return irq;
}

/*
 * GIC has 4 states: pending->active(+pending)->inactive
 * seL4 expects two states: active->inactive.
 * We ignore the active state in GIC to conform
 */
static inline bool_t
isIRQPending(void)
{
    return (((gic_cpuiface->hi_pend) & ((1ul << (10u))-1ul)) < 1020u);
}

static inline void
maskInterrupt(bool_t disable, interrupt_t irq)
{
    if (disable) {
        dist_enable_clr(irq);
    } else {
        dist_enable_set(irq);
    }
}

static inline void
ackInterrupt(irq_t irq)
{
    if(!((((active_irq[0]) & ((1ul << (10u))-1ul)) < 1020u) && (active_irq[0] & ((1ul << (10u))-1ul)) == irq)) _assert_fail("IS_IRQ_VALID(active_irq[SMP_TERNARY(getCurrentCPUIndex(), 0)]) && (active_irq[SMP_TERNARY(getCurrentCPUIndex(), 0)] & IRQ_MASK) == irq", "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/gic_pl390.h", 204, __FUNCTION__);
    if (is_irq_edge_triggered(irq)) {
        dist_pending_clr(irq);
    }
    gic_cpuiface->eoi = active_irq[0];
    active_irq[0] = 1023u;

}

static inline void
handleSpuriousIRQ(void)
{
}

void initIRQController(void);
# 209 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 2
# 15 "/home/sel4/work/work2/kernel/include/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/machine.h" 2

# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 2
# 1 "/home/sel4/work/work2/kernel/include/basic_types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/vcpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/vcpu.h" 2



# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/vcpu.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/vcpu.h" 2



struct cpXRegs {
    uint32_t sctlr;
    uint32_t actlr;
};

struct gicVCpuIface {
    uint32_t hcr;
    uint32_t vmcr;
    uint32_t apr;
    virq_t lr[64];
};

struct vcpu {
    /* TCB associated with this VCPU. */
    struct tcb *vcpuTCB;
    struct cpXRegs cpx;
    struct gicVCpuIface vgic;
    /* Banked registers */
    word_t lr_svc, sp_svc;
    word_t lr_abt, sp_abt;
    word_t lr_und, sp_und;
    word_t lr_irq, sp_irq;
    word_t lr_fiq, sp_fiq, r8_fiq, r9_fiq, r10_fiq, r11_fiq, r12_fiq;
};
typedef struct vcpu vcpu_t;
typedef int __assert_failed_vcpu_size_correct[(sizeof(struct vcpu) <= (1ul << (12))) ? 1 : -1];

void VGICMaintenance(void);
void handleVCPUFault(word_t hsr);

void vcpu_init(vcpu_t *vcpu);

/* Performs one off initialization of VCPU state and structures. Should be
 * called in boot code before any other VCPU functions */
__attribute__((__section__(".boot.text"))) void vcpu_boot_init(void);

void vcpu_finalise(vcpu_t *vcpu);

void associateVCPUTCB(vcpu_t *vcpu, tcb_t *tcb);

void dissociateVCPUTCB(vcpu_t *vcpu, tcb_t *tcb);

exception_t decodeARMVCPUInvocation(
    word_t label,
    unsigned int length,
    cptr_t cptr,
    cte_t* slot,
    cap_t cap,
    extra_caps_t extraCaps,
    bool_t call,
    word_t* buffer
);

void vcpu_restore(vcpu_t *cpu);
void vcpu_switch(vcpu_t *cpu);

exception_t decodeVCPUWriteReg(cap_t cap, unsigned int length, word_t* buffer);
exception_t decodeVCPUReadReg(cap_t cap, unsigned int length, bool_t call, word_t* buffer);
exception_t decodeVCPUInjectIRQ(cap_t cap, unsigned int length, word_t* buffer);
exception_t decodeVCPUSetTCB(cap_t cap, extra_caps_t extraCaps);

exception_t invokeVCPUWriteReg(vcpu_t *vcpu, uint32_t field, uint32_t value);
exception_t invokeVCPUReadReg(vcpu_t *vcpu, uint32_t field, bool_t call);
exception_t invokeVCPUInjectIRQ(vcpu_t *vcpu, unsigned long index, virq_t virq);
exception_t invokeVCPUSetTCB(vcpu_t *vcpu, tcb_t *tcb);
# 18 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/devices.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




/* These devices are used by the seL4 kernel. */
# 23 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/devices.h"
/* HYP mode kernel devices */
# 38 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/devices.h"
/* Generic devices */
# 133 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/devices.h"
// #define AXI_FILE_D64_PADDR    0x12310000

// #define AXI_USBSATA_D64_PADDR 0x12330000







// #define AXI_GPS_PADDR         0x12610000
# 261 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/devices.h"
/* SoC specific devices */
# 20 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 2






static const kernel_frame_t __attribute__((__section__(".boot.rodata"))) kernel_devices[] = {
    {
        /*  Watch dog timer used as PIT */
        0x101C0000,
        0xfff02000,
        true /* armExecuteNever */
    },
    {
        /*  GIC */
        (0x10480000 + 0x2000),
        0xfff05000,
        true /* armExecuteNever */
    },
    {
        (0x10480000 + 0x1000),
        0xfff04000,
        true /* armExecuteNever */

    },
    {
        (0x10480000 + 0x4000),
        0xfff06000,
        false, /* armExecuteNever */


    },
    {
        0x12C20000,
        0xfff01000,
        true /* armExecuteNever */

    }
};

/* Available physical memory regions on platform (RAM) */
/* NOTE: Regions are not allowed to be adjacent! */
static const p_region_t __attribute__((__section__(".boot.rodata"))) avail_p_regs[] = {
    /* 2 GiB */
    { /* .start = */ 0x60000000, /* .end = */ 0xC0000000 }
};

static const p_region_t __attribute__((__section__(".boot.rodata"))) dev_p_regs[] = {
    { /* ,start */ 0x40000000 , /* .end */ 0x60000000 },
    { /* ,start */ 0x02070000 , /* .end */ 0x02070000 + (16 << 12) },
    { /* .start */ 0x03810000 , /* .end */ 0x03810000 + (1 << 12) },
    { /* .start */ 0x03860000 , /* .end */ 0x03860000 + (1 << 12) },
    { /* .start */ 0x10000000 , /* .end */ 0x10000000 + (1 << 12) },
    { /* .start */ 0x10010000 , /* .end */ 0x10010000 + (1 << 12) },
    { /* .start */ 0x10014000 , /* .end */ 0x10014000 + (1 << 12) },
    { /* .start */ 0x10018000 , /* .end */ 0x10018000 + (1 << 12) },
    { /* .start */ 0x1001C000 , /* .end */ 0x1001C000 + (1 << 12) },
    { /* .start */ 0x10020000 , /* .end */ 0x10020000 + (1 << 12) },
    { /* .start */ 0x10024000 , /* .end */ 0x10024000 + (1 << 12) },
    { /* .start */ 0x10028000 , /* .end */ 0x10028000 + (1 << 12) },
    { /* .start */ 0x1002C000 , /* .end */ 0x1002C000 + (1 << 12) },
    { /* .start */ 0x10030000 , /* .end */ 0x10030000 + (1 << 12) },
    { /* .start */ 0x10038000 , /* .end */ 0x10038000 + (1 << 12) },
    { /* .start */ 0x10040000 , /* .end */ 0x10040000 + (5 << 12) },
    { /* .start */ 0x10050000 , /* .end */ 0x10050000 + (1 << 12) },
    { /* .start */ 0x10060000 , /* .end */ 0x10060000 + (1 << 12) },
    { /* .start */ 0x10064000 , /* .end */ 0x10064000 + (1 << 12) },
    { /* .start */ 0x10068000 , /* .end */ 0x10068000 + (1 << 12) },
    { /* .start */ 0x1006C000 , /* .end */ 0x1006C000 + (1 << 12) },
    { /* .start */ 0x100A0000 , /* .end */ 0x100A0000 + (1 << 12) },
    { /* .start */ 0x100C0000 , /* .end */ 0x100C0000 + (1 << 12) },
    { /* .start */ 0x101B0000 , /* .end */ 0x101B0000 + (1 << 12) },
//  { /* .start */ MCT_PADDR             , /* .end */ MCT_PADDR              + (1 << PAGE_BITS) },
    { /* .start */ 0x101D0000 , /* .end */ 0x101D0000 + (1 << 12) },
    { /* .start */ 0x101E0000 , /* .end */ 0x101E0000 + (1 << 12) },
    { /* .start */ 0x10440000 , /* .end */ 0x10440000 + (1 << 12) },
    { /* .start */ 0x10450000 , /* .end */ 0x10450000 + (1 << 12) },
//  { /* .start */ GIC_PADDR             , /* .end */ GIC_PADDR              + (8 << PAGE_BITS) },
    { /* .start */ (0x10480000 + 0x6000) , /* .end */ (0x10480000 + 0x6000) + (1 << 12) },
    { /* .start */ 0x104A0000 , /* .end */ 0x104A0000 + (1 << 12) },
    { /* .start */ 0x104B0000 , /* .end */ 0x104B0000 + (1 << 12) },
    { /* .start */ 0x10500000 , /* .end */ 0x10500000 + (1 << 12) },
    { /* .start */ 0x10800000 , /* .end */ 0x10800000 + (1 << 12) },
    { /* .start */ 0x10830000 , /* .end */ 0x10830000 + (1 << 12) },
    { /* .start */ 0x10840000 , /* .end */ 0x10840000 + (1 << 12) },
    { /* .start */ 0x10850000 , /* .end */ 0x10850000 + (1 << 12) },
    { /* .start */ 0x10880000 , /* .end */ 0x10880000 + (1 << 12) },
    { /* .start */ 0x10890000 , /* .end */ 0x10890000 + (1 << 12) },
    { /* .start */ 0x108A0000 , /* .end */ 0x108A0000 + (1 << 12) },
    { /* .start */ 0x108B0000 , /* .end */ 0x108B0000 + (1 << 12) },
    { /* .start */ 0x10A40000 , /* .end */ 0x10A40000 + (1 << 12) },
    { /* .start */ 0x10A50000 , /* .end */ 0x10A50000 + (1 << 12) },
    { /* .start */ 0x10A60000 , /* .end */ 0x10A60000 + (1 << 12) },
    { /* .start */ 0x10C00000 , /* .end */ 0x10C00000 + (1 << 12) },
    { /* .start */ 0x10C10000 , /* .end */ 0x10C10000 + (1 << 12) },
    { /* .start */ 0x10CC0000 , /* .end */ 0x10CC0000 + (1 << 12) },
    { /* .start */ 0x10CD0000 , /* .end */ 0x10CD0000 + (1 << 12) },
    { /* .start */ 0x10CE0000 , /* .end */ 0x10CE0000 + (1 << 12) },
    { /* .start */ 0x10CF0000 , /* .end */ 0x10CF0000 + (1 << 12) },
    { /* .start */ 0x10D00000 , /* .end */ 0x10D00000 + (1 << 12) },
    { /* .start */ 0x10D10000 , /* .end */ 0x10D10000 + (1 << 12) },
    { /* .start */ 0x10DD0000 , /* .end */ 0x10DD0000 + (1 << 12) },
    { /* .start */ 0x10DE0000 , /* .end */ 0x10DE0000 + (1 << 12) },
    { /* .start */ 0x10E00000 , /* .end */ 0x10E00000 + (1 << 12) },
    { /* .start */ 0x10E40000 , /* .end */ 0x10E40000 + (1 << 12) },
    { /* .start */ 0x10E80000 , /* .end */ 0x10E80000 + (1 << 12) },
    { /* .start */ 0x10E90000 , /* .end */ 0x10E90000 + (1 << 12) },
    { /* .start */ 0x10F00000 , /* .end */ 0x10F00000 + (1 << 12) },
    { /* .start */ 0x10F10000 , /* .end */ 0x10F10000 + (1 << 12) },
    { /* .start */ 0x10F20000 , /* .end */ 0x10F20000 + (1 << 12) },
    { /* .start */ 0x10F30000 , /* .end */ 0x10F30000 + (1 << 12) },
    { /* .start */ 0x11000000 , /* .end */ 0x11000000 + (1 << 12) },
    { /* .start */ 0x11200000 , /* .end */ 0x11200000 + (1 << 12) },
    { /* .start */ 0x11210000 , /* .end */ 0x11210000 + (1 << 12) },
    { /* .start */ 0x14000000 , /* .end */ 0x14000000 + (1 << 12) },
    { /* .start */ 0x11680000 , /* .end */ 0x11680000 + (1 << 12) },
    { /* .start */ 0x116A0000 , /* .end */ 0x116A0000 + (1 << 12) },
    { /* .start */ 0x11800000 , /* .end */ 0x11800000 + (1 << 12) },
    { /* .start */ 0x11C00000 , /* .end */ 0x11C00000 + (1 << 12) },
    { /* .start */ 0x11C10000 , /* .end */ 0x11C10000 + (1 << 12) },
    { /* .start */ 0x11D40000 , /* .end */ 0x11D40000 + (1 << 12) },
    { /* .start */ 0x11D50000 , /* .end */ 0x11D50000 + (1 << 12) },
    { /* .start */ 0x11DA0000 , /* .end */ 0x11DA0000 + (1 << 12) },
    { /* .start */ 0x11DB0000 , /* .end */ 0x11DB0000 + (1 << 12) },
    { /* .start */ 0x11DC0000 , /* .end */ 0x11DC0000 + (1 << 12) },
    { /* .start */ 0x11E00000 , /* .end */ 0x11E00000 + (1 << 12) },
    { /* .start */ 0x11F20000 , /* .end */ 0x11F20000 + (1 << 12) },
    { /* .start */ 0x12000000 , /* .end */ 0x12000000 + (256 << 12) },
    { /* .start */ 0x12100000 , /* .end */ 0x12100000 + (1 << 12) },
    { /* .start */ 0x12110000 , /* .end */ 0x12110000 + (1 << 12) },
    { /* .start */ 0x12120000 , /* .end */ 0x12120000 + (1 << 12) },
    { /* .start */ 0x12130000 , /* .end */ 0x12130000 + (1 << 12) },
    { /* .start */ 0x12140000 , /* .end */ 0x12140000 + (1 << 12) },
    { /* .start */ 0x12400000 , /* .end */ 0x12400000 + (16 << 12) },
    { /* .start */ 0x12500000 , /* .end */ 0x12500000 + (1 << 12) },
    { /* .start */ 0x12160000 , /* .end */ 0x12160000 + (1 << 12) },
    { /* .start */ 0x12170000 , /* .end */ 0x12170000 + (1 << 12) },
    { /* .start */ 0x12180000 , /* .end */ 0x12180000 + (1 << 12) },
    { /* .start */ 0x12190000 , /* .end */ 0x12190000 + (1 << 12) },
    { /* .start */ 0x121A0000 , /* .end */ 0x121A0000 + (1 << 12) },
    { /* .start */ 0x121B0000 , /* .end */ 0x121B0000 + (1 << 12) },
    { /* .start */ 0x121C0000 , /* .end */ 0x121C0000 + (1 << 12) },
    { /* .start */ 0x121D0000 , /* .end */ 0x121D0000 + (1 << 12) },
    { /* .start */ 0x12200000 , /* .end */ 0x12200000 + (1 << 12) },
    { /* .start */ 0x12210000 , /* .end */ 0x12210000 + (1 << 12) },
    { /* .start */ 0x12220000 , /* .end */ 0x12220000 + (1 << 12) },
    { /* .start */ 0x12230000 , /* .end */ 0x12230000 + (1 << 12) },
    { /* .start */ 0x12250000 , /* .end */ 0x12250000 + (1 << 12) },
    { /* .start */ 0x122F0000 , /* .end */ 0x122F0000 + (1 << 12) },
    { /* .start */ 0x12300000 , /* .end */ 0x12300000 + (1 << 12) },
    { /* .start */ 0x12300000 , /* .end */ 0x12300000 + (1 << 12) },
    { /* .start */ 0x12320000 , /* .end */ 0x12320000 + (1 << 12) },
    { /* .start */ 0x12320000 , /* .end */ 0x12320000 + (1 << 12) },
    { /* .start */ 0x12360000 , /* .end */ 0x12360000 + (1 << 12) },
    { /* .start */ 0x12370000 , /* .end */ 0x12370000 + (1 << 12) },
    { /* .start */ 0x12380000 , /* .end */ 0x12380000 + (1 << 12) },
    { /* .start */ 0x12390000 , /* .end */ 0x12390000 + (1 << 12) },
    { /* .start */ 0x12600000 , /* .end */ 0x12600000 + (1 << 12) },
    { /* .start */ 0x12600000 , /* .end */ 0x12600000 + (1 << 12) },
    { /* .start */ 0x12620000 , /* .end */ 0x12620000 + (1 << 12) },
    { /* .start */ 0x12630000 , /* .end */ 0x12630000 + (1 << 12) },
    { /* .start */ 0x12C00000 , /* .end */ 0x12C00000 + (1 << 12) },
    { /* .start */ 0x12C10000 , /* .end */ 0x12C10000 + (1 << 12) },
    { /* .start */ 0x12C20000 , /* .end */ 0x12C20000 + (1 << 12) },
    { /* .start */ 0x12C30000 , /* .end */ 0x12C30000 + (1 << 12) },
    { /* .start */ 0x12C50000 , /* .end */ 0x12C50000 + (1 << 12) },
    { /* .start */ 0x12C60000 , /* .end */ 0x12C60000 + (1 << 12) },
    { /* .start */ 0x12C70000 , /* .end */ 0x12C70000 + (1 << 12) },
    { /* .start */ 0x12C80000 , /* .end */ 0x12C80000 + (1 << 12) },
    { /* .start */ 0x12C90000 , /* .end */ 0x12C90000 + (1 << 12) },
    { /* .start */ 0x12CA0000 , /* .end */ 0x12CA0000 + (1 << 12) },
    { /* .start */ 0x12CB0000 , /* .end */ 0x12CB0000 + (1 << 12) },
    { /* .start */ 0x12CC0000 , /* .end */ 0x12CC0000 + (1 << 12) },
    { /* .start */ 0x12CD0000 , /* .end */ 0x12CD0000 + (1 << 12) },
    { /* .start */ 0x12CE0000 , /* .end */ 0x12CE0000 + (1 << 12) },
    { /* .start */ 0x12D00000 , /* .end */ 0x12D00000 + (1 << 12) },
    { /* .start */ 0x12D10000 , /* .end */ 0x12D10000 + (1 << 12) },
    { /* .start */ 0x12D20000 , /* .end */ 0x12D20000 + (1 << 12) },
    { /* .start */ 0x12D30000 , /* .end */ 0x12D30000 + (1 << 12) },
    { /* .start */ 0x12D40000 , /* .end */ 0x12D40000 + (1 << 12) },
    { /* .start */ 0x12D50000 , /* .end */ 0x12D50000 + (1 << 12) },
    { /* .start */ 0x12D60000 , /* .end */ 0x12D60000 + (1 << 12) },
    { /* .start */ 0x12D70000 , /* .end */ 0x12D70000 + (1 << 12) },
    { /* .start */ 0x12D80000 , /* .end */ 0x12D80000 + (1 << 12) },
    { /* .start */ 0x12D90000 , /* .end */ 0x12D90000 + (1 << 12) },
    { /* .start */ 0x12DA0000 , /* .end */ 0x12DA0000 + (1 << 12) },
    { /* .start */ 0x12DB0000 , /* .end */ 0x12DB0000 + (1 << 12) },
    { /* .start */ 0x12DD0000 , /* .end */ 0x12DD0000 + (1 << 12) },
    { /* .start */ 0x12DE0000 , /* .end */ 0x12DE0000 + (1 << 12) },
    { /* .start */ 0x13000000 , /* .end */ 0x13000000 + (1 << 12) },
    { /* .start */ 0x13010000 , /* .end */ 0x13010000 + (1 << 12) },
    { /* .start */ 0x13020000 , /* .end */ 0x13020000 + (1 << 12) },
    { /* .start */ 0x13030000 , /* .end */ 0x13030000 + (1 << 12) },
    { /* .start */ 0x13040000 , /* .end */ 0x13040000 + (1 << 12) },
    { /* .start */ 0x13050000 , /* .end */ 0x13050000 + (1 << 12) },
    { /* .start */ 0x13060000 , /* .end */ 0x13060000 + (1 << 12) },
    { /* .start */ 0x13070000 , /* .end */ 0x13070000 + (1 << 12) },
    { /* .start */ 0x130F0000 , /* .end */ 0x130F0000 + (1 << 12) },
    { /* .start */ 0x13110000 , /* .end */ 0x13110000 + (1 << 12) },
    { /* .start */ 0x13120000 , /* .end */ 0x13120000 + (1 << 12) },
    { /* .start */ 0x13130000 , /* .end */ 0x13130000 + (1 << 12) },
    { /* .start */ 0x13140000 , /* .end */ 0x13140000 + (1 << 12) },
    { /* .start */ 0x13150000 , /* .end */ 0x13150000 + (1 << 12) },
    { /* .start */ 0x13160000 , /* .end */ 0x13160000 + (1 << 12) },
    { /* .start */ 0x13170000 , /* .end */ 0x13170000 + (1 << 12) },
    { /* .start */ 0x13180000 , /* .end */ 0x13180000 + (1 << 12) },
    { /* .start */ 0x13190000 , /* .end */ 0x13190000 + (1 << 12) },
    { /* .start */ 0x131A0000 , /* .end */ 0x131A0000 + (1 << 12) },
    { /* .start */ 0x131B0000 , /* .end */ 0x131B0000 + (1 << 12) },
    { /* .start */ 0x131E0000 , /* .end */ 0x131E0000 + (1 << 12) },
    { /* .start */ 0x131F0000 , /* .end */ 0x131F0000 + (1 << 12) },
    { /* .start */ 0x13260000 , /* .end */ 0x13260000 + (1 << 12) },
    { /* .start */ 0x13270000 , /* .end */ 0x13270000 + (1 << 12) },
    { /* .start */ 0x13280000 , /* .end */ 0x13280000 + (1 << 12) },
    { /* .start */ 0x13290000 , /* .end */ 0x13290000 + (1 << 12) },
    { /* .start */ 0x132A0000 , /* .end */ 0x132A0000 + (1 << 12) },
    { /* .start */ 0x132B0000 , /* .end */ 0x132B0000 + (1 << 12) },
    { /* .start */ 0x132C0000 , /* .end */ 0x132C0000 + (1 << 12) },
    { /* .start */ 0x132D0000 , /* .end */ 0x132D0000 + (1 << 12) },
    { /* .start */ 0x132E0000 , /* .end */ 0x132E0000 + (1 << 12) },
    { /* .start */ 0x132F0000 , /* .end */ 0x132F0000 + (1 << 12) },
    { /* .start */ 0x13400000 , /* .end */ 0x13400000 + (1 << 12) },
    { /* .start */ 0x13620000 , /* .end */ 0x13620000 + (1 << 12) },
    { /* .start */ 0x13640000 , /* .end */ 0x13640000 + (1 << 12) },
    { /* .start */ 0x13650000 , /* .end */ 0x13650000 + (1 << 12) },
    { /* .start */ 0x13670000 , /* .end */ 0x13670000 + (1 << 12) },
    { /* .start */ 0x13C00000 , /* .end */ 0x13C00000 + (1 << 12) },
    { /* .start */ 0x13C10000 , /* .end */ 0x13C10000 + (1 << 12) },
    { /* .start */ 0x13C20000 , /* .end */ 0x13C20000 + (1 << 12) },
    { /* .start */ 0x13C30000 , /* .end */ 0x13C30000 + (1 << 12) },
    { /* .start */ 0x13C40000 , /* .end */ 0x13C40000 + (1 << 12) },
    { /* .start */ 0x13C50000 , /* .end */ 0x13C50000 + (1 << 12) },
    { /* .start */ 0x13C90000 , /* .end */ 0x13C90000 + (1 << 12) },
    { /* .start */ 0x13CA0000 , /* .end */ 0x13CA0000 + (1 << 12) },
    { /* .start */ 0x13E00000 , /* .end */ 0x13E00000 + (1 << 12) },
    { /* .start */ 0x13E10000 , /* .end */ 0x13E10000 + (1 << 12) },
    { /* .start */ 0x13E20000 , /* .end */ 0x13E20000 + (1 << 12) },
    { /* .start */ 0x13E30000 , /* .end */ 0x13E30000 + (1 << 12) },
    { /* .start */ 0x13E40000 , /* .end */ 0x13E40000 + (1 << 12) },
    { /* .start */ 0x13E50000 , /* .end */ 0x13E50000 + (1 << 12) },
    { /* .start */ 0x13E60000 , /* .end */ 0x13E60000 + (1 << 12) },
    { /* .start */ 0x13E70000 , /* .end */ 0x13E70000 + (1 << 12) },
    { /* .start */ 0x13E80000 , /* .end */ 0x13E80000 + (1 << 12) },
    { /* .start */ 0x13E90000 , /* .end */ 0x13E90000 + (1 << 12) },
    { /* .start */ 0x13EA0000 , /* .end */ 0x13EA0000 + (1 << 12) },
    { /* .start */ 0x13EB0000 , /* .end */ 0x13EB0000 + (1 << 12) },
    { /* .start */ 0x14220000 , /* .end */ 0x14220000 + (1 << 12) },
    { /* .start */ 0x14400000 , /* .end */ 0x14400000 + (1 << 12) },
    { /* .start */ 0x14410000 , /* .end */ 0x14410000 + (1 << 12) },
    { /* .start */ 0x14420000 , /* .end */ 0x14420000 + (1 << 12) },
    { /* .start */ 0x14430000 , /* .end */ 0x14430000 + (1 << 12) },
    { /* .start */ 0x14450000 , /* .end */ 0x14450000 + (1 << 12) },
    { /* .start */ 0x14500000 , /* .end */ 0x14500000 + (1 << 12) },
    { /* .start */ 0x14510000 , /* .end */ 0x14510000 + (1 << 12) },
    { /* .start */ 0x14530000 , /* .end */ 0x14530000 + (1 << 12) },
    { /* .start */ 0x14540000 , /* .end */ 0x14540000 + (1 << 12) },
    { /* .start */ 0x14550000 , /* .end */ 0x14550000 + (1 << 12) },
    { /* .start */ 0x14560000 , /* .end */ 0x14560000 + (1 << 12) },
    { /* .start */ 0x14570000 , /* .end */ 0x14570000 + (1 << 12) },
    { /* .start */ 0x14580000 , /* .end */ 0x14580000 + (1 << 12) },
    { /* .start */ 0x14590000 , /* .end */ 0x14590000 + (1 << 12) },
    { /* .start */ 0x145B0000 , /* .end */ 0x145B0000 + (1 << 12) },
    { /* .start */ 0x145D0000 , /* .end */ 0x145D0000 + (1 << 12) },
    { /* .start */ 0x14640000 , /* .end */ 0x14640000 + (1 << 12) },
    { /* .start */ 0x14650000 , /* .end */ 0x14650000 + (1 << 12) },
    { /* .start */ 0x146D0000 , /* .end */ 0x146D0000 + (1 << 12) },
    { /* .start */ 0x18000000 , /* .end */ 0x18000000 + (512 << 12) },
    { /* .start */ 0x18200000 , /* .end */ 0x18200000 + (1 << 12) },
    { /* .start */ 0x18300000 , /* .end */ 0x18300000 + (1 << 12) },
    { /* .start */ 0x18400000 , /* .end */ 0x18400000 + (512 << 12) },
    { /* .start */ 0x18600000 , /* .end */ 0x18600000 + (1 << 12) },
    { /* .start */ 0x18680000 , /* .end */ 0x18680000 + (1 << 12) },
    { /* .start */ 0x18690000 , /* .end */ 0x18690000 + (1 << 12) },
    { /* .start */ 0x18700000 , /* .end */ 0x18700000 + (1 << 12) },
};

/* Handle a platform-reserved IRQ. */
static inline void
handleReservedIRQ(irq_t irq)
{
    if ((1) &&
            (irq == INTERRUPT_VGIC_MAINTENANCE)) {
        VGICMaintenance();
        return;
    }
}
# 20 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/armv/armv7-a/armv/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




static inline void wfi(void)
{
    __asm__ volatile("wfi" ::: "memory");
}

static inline void dsb(void)
{
    __asm__ volatile("dsb" ::: "memory");
}

static inline void dmb(void)
{
    __asm__ volatile("dmb" ::: "memory");
}

static inline void isb(void)
{
    __asm__ volatile("isb" ::: "memory");
}
# 21 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/smp.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/smp.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/smp/smp.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/smp.h" 2
# 1 "/home/sel4/work/work2/kernel/include/model/smp.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/model/smp.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/model/smp.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/statedata.h" 2

# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/statedata.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug_conf.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/statedata.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/statedata.h" 2


/* TODO: add ARM-dependent fields here */
/* Bitmask of all cores should receive the reschedule IPI */
extern word_t ipiReschedulePending __attribute__((externally_visible));
;


extern user_breakpoint_state_t armKSNullBreakpointState __attribute__((externally_visible));



extern pdeS1_t armHSGlobalPGD[(1ul << (2))] __attribute__((externally_visible));
extern pdeS1_t armHSGlobalPD[(1ul << (9))] __attribute__((externally_visible));
extern pteS1_t armHSGlobalPT[(1ul << (9))] __attribute__((externally_visible));
# 19 "/home/sel4/work/work2/kernel/include/model/smp.h" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/include/model/smp.h" 2
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/smp.h" 2
# 22 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2

# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine_pl2.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine_pl2.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/vcpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine_pl2.h" 2



static inline void writeContextIDPL2(word_t id)
{
    word_t pd_val, vmid;
    __asm__ volatile("mrrc p15, 4, %0, %1, c2" : "=r"(pd_val), "=r"(vmid));
    __asm__ volatile("mcrr p15, 4, %0, %1, c2" : : "r"(pd_val), "r"(id << (48-32)));
    isb();
}

static inline void writeContextIDAndPD(word_t id, word_t pd_val)
{
    __asm__ volatile("mcrr p15, 6, %0, %1, c2" : : "r"(pd_val), "r"(id << (48-32)));
    isb();
}


static inline void setCurrentPDPL2(paddr_t addr)
{
    word_t pd_val, vmid;
    __asm__ volatile("mrrc p15, 6, %0, %1, c2" : "=r"(pd_val), "=r"(vmid));
    dsb();
    __asm__ volatile("mcrr p15, 6, %0, %1, c2" : : "r"(addr), "r"(vmid));
    isb();
}

static inline void setCurrentHypPD(paddr_t addr)
{
    word_t zero = 0;
    dsb();
    __asm__ volatile("mcrr p15, 4, %0, %1, c2" : : "r"(addr), "r"(zero));
    isb();
}

static inline void setVTCR(word_t r)
{
    dsb();
    __asm__ volatile("mcr p15, 4, %0, c2, c1, 2" : : "r"(r));
    isb();
}

static inline void setHCR(word_t r)
{
    dsb();
    __asm__ volatile("mcr p15, 4, %0, c1, c1, 0" : : "r"(r));
    isb();
}

static inline void setHMAIR(word_t hmair0, word_t hmair1)
{
    __asm__ volatile("mcr p15, 4, %0, c10, c2, 0" : : "r"(hmair0));
    __asm__ volatile("mcr p15, 4, %0, c10, c2, 1" : : "r"(hmair1));
    isb();
}

static inline void setMAIR(word_t hmair0, word_t hmair1)
{
    __asm__ volatile("mcr p15, 0, %0, c10, c2, 0" : : "r"(hmair0));
    __asm__ volatile("mcr p15, 0, %0, c10, c2, 1" : : "r"(hmair1));
    isb();
}

static inline void invalidateHypTLB(void)
{
    dsb();
    __asm__ volatile("mcr p15, 4, %0, c8, c7, 0" : : "r"(0));
    dsb();
    isb();
}

static inline paddr_t __attribute__((__pure__)) addressTranslateS1CPR(vptr_t vaddr)
{
    uint32_t ipa0, ipa1;
    __asm__ volatile ("mcr  p15, 0, %0, c7, c8, 0" :: "r"(vaddr));
    isb();
    __asm__ volatile ("mrrc p15, 0, %0, %1, c7" : "=r"(ipa0), "=r"(ipa1));

    return ipa0;
}

static inline word_t __attribute__((__pure__)) getHSR(void)
{
    word_t HSR;
    __asm__ volatile("mrc p15, 4, %0, c5, c2, 0" : "=r"(HSR));
    return HSR;
}

static inline word_t __attribute__((__pure__)) getHDFAR(void)
{
    word_t HDFAR;
    __asm__ volatile("mrc p15, 4, %0, c6, c0, 0" : "=r"(HDFAR));
    return HDFAR;
}

static inline word_t __attribute__((__pure__)) getHIFAR(void)
{
    word_t HIFAR;
    __asm__ volatile("mrc p15, 4, %0, c6, c0, 2" : "=r"(HIFAR));
    return HIFAR;
}

static inline word_t __attribute__((__pure__)) getHPFAR(void)
{
    word_t HPFAR;
    __asm__ volatile("mrc p15, 4, %0, c6, c0, 4" : "=r"(HPFAR));
    return HPFAR;
}

static inline word_t getSCTLR(void)
{
    word_t SCTLR;
    __asm__ volatile ("mrc p15, 0, %0, c1, c0, 0" : "=r"(SCTLR));
    return SCTLR;
}

static inline void setSCTLR(word_t sctlr)
{
    __asm__ volatile ("mcr p15, 0, %0, c1, c0, 0" :: "r"(sctlr));
}
# 25 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/hardware.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/hardware.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/hardware.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/hardware.h" 2

/*
 * 0xffe00000 asid id slot (arm/arch/kernel/vspace.h)
 * 0xfff00000 devices      (plat/machine/devices.h)
 * 0xffff0000 vectors      (arch/machine/hardware.h)
 * 0xffffc000 global page  (arch/machine/hardware.h)
 */
# 26 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/stack.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */



# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/kernel/stack.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/kernel/stack.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/kernel/stack.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */



# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/kernel/stack.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/kernel/stack.h" 2
# 18 "/home/sel4/work/work2/kernel/include/kernel/stack.h" 2

/* These are the stacks used in kernel, shared between architecures/modes.
 * CONFIG_KERNEL_STACK_BITS is defined in kernel/Kconfig. The physical/offset
 * address of the stack is per-arch-mode aligned. KERNEL_STACK_ALIGNMENT is
 * defined for each arch/mode in <mode/kernel/stack.h>
 */
extern char kernel_stack_alloc[1][(1ul << (12))];
# 27 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 2
# 41 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h"
/** Generic timer CP15 registers **/
# 71 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h"
word_t __attribute__((__pure__)) getRestartPC(tcb_t *thread);
void setNextPC(tcb_t *thread, word_t v);

/* Architecture specific machine operations */

static inline word_t getProcessorID(void)
{
    word_t processor_id;
    __asm__ volatile("mrc  " "p15, 0, %0, c0, c0, 0" : "=r"(processor_id));
    return processor_id;
}


static inline word_t readSystemControlRegister(void)
{
    word_t scr;
    __asm__ volatile("mrc  " "p15, 0, %0, c1, c0, 0" : "=r"(scr));
    return scr;
}


static inline void writeSystemControlRegister(word_t scr)
{
    do { word_t _v = scr; __asm__ volatile("mcr  " "p15, 0, %0, c1, c0, 0" :: "r" (_v)); }while(0);
}


static inline word_t readAuxiliaryControlRegister(void)
{
    word_t acr;
    __asm__ volatile("mrc  " "p15, 0, %0, c1, c0, 1" : "=r"(acr));
    return acr;
}


static inline void writeAuxiliaryControlRegister(word_t acr)
{
    do { word_t _v = acr; __asm__ volatile("mcr  " "p15, 0, %0, c1, c0, 1" :: "r" (_v)); }while(0);
}

/** MODIFIES: [*] */
/** DONT_TRANSLATE */
static inline void clearExMonitor(void)
{
    word_t tmp;
    __asm__ volatile("strex r0, r1, [%0]" : : "r"(&tmp) : "r0");
}

static inline void flushBTAC(void)
{
    __asm__ volatile("mcr p15, 0, %0, c7, c5, 6" : : "r"(0));
}

static inline void writeContextID(word_t id)
{
    if (1) {
        writeContextIDPL2(id);
    } else {
        __asm__ volatile("mcr p15, 0, %0, c13, c0, 1" : : "r"(id));
        isb();
    }
}

/* Address space control */

static inline void writeTTBR0(paddr_t addr)
{
    /* Mask supplied address (retain top 19 bits).  Set the lookup cache bits:
     * outer write-back cacheable, no allocate on write, inner non-cacheable.
     */
    __asm__ volatile("mcr p15, 0, %0, c2, c0, 0" : :
                 "r"((addr & 0xffffe000) | 0x18));
}

static inline void writeTPIDRURW(word_t reg)
{
    __asm__ volatile("mcr p15, 0, %0, c13, c0, 2" :: "r"(reg));
}

static inline void writeTPIDRPRW(word_t reg)
{
    __asm__ volatile("mcr p15, 0, %0, c13, c0, 4" :: "r"(reg));
}

static inline word_t readTPIDRPRW(void)
{
    word_t reg;
    __asm__ volatile("mrc p15, 0, %0, c13, c0, 4" :"=r"(reg));
    return reg;
}

static inline word_t readTPIDRURW(void)
{
    word_t reg;
    __asm__ volatile("mrc p15, 0, %0, c13, c0, 2" : "=r"(reg));
    return reg;
}

static inline word_t readMPIDR(void)
{
    word_t reg;
    __asm__ volatile ("mrc p15, 0, %0, c0, c0, 5" : "=r"(reg));
    return reg;
}

static inline void setCurrentPD(paddr_t addr)
{
    /* Mask supplied address (retain top 19 bits).  Set the lookup cache bits:
     * outer write-back cacheable, no allocate on write, inner non-cacheable.
     */
    /* Before changing the PD ensure all memory stores have completed */
    if (1) {
        setCurrentPDPL2(addr);
    } else {
        dsb();
        writeTTBR0(addr);
        /* Ensure the PD switch completes before we do anything else */
        isb();
    }
}

static inline void setKernelStack(word_t stack_address)
{

    /* Setup kernel stack pointer.
     * Load the (per-core) kernel stack pointer to TPIDRPRW for faster reloads on traps.
     */
    writeTPIDRPRW(stack_address);

}

static inline word_t getKernelStack(void)
{

    return readTPIDRPRW();



}
# 221 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h"
/* TLB control */

static inline void invalidateLocalTLB(void)
{
    dsb();
    __asm__ volatile("mcr p15, 0, %0, c8, c7, 0" : : "r"(0));
    dsb();
    isb();
}

static inline void invalidateLocalTLB_ASID(hw_asid_t hw_asid)
{
    if (1) {
        invalidateLocalTLB();
    } else {
        dsb();
        __asm__ volatile("mcr p15, 0, %0, c8, c7, 2" : : "r"(hw_asid));
        dsb();
        isb();
    }
}

static inline void invalidateLocalTLB_VAASID(word_t mva_plus_asid)
{
    if (1) {
        invalidateLocalTLB();
    } else {
        dsb();
        __asm__ volatile("mcr p15, 0, %0, c8, c7, 1" : : "r"(mva_plus_asid));
        dsb();
        isb();
    }
}

void lockTLBEntry(vptr_t vaddr);

static inline void cleanByVA(vptr_t vaddr, paddr_t paddr)
{







    __asm__ volatile("mcr p15, 0, %0, c7, c10, 1" : : "r"(vaddr));

    /* Erratum 586323 - end with DMB to ensure the write goes out. */
    dmb();
}

/* D-Cache clean to PoU (L2 cache) (v6/v7 common) */
static inline void cleanByVA_PoU(vptr_t vaddr, paddr_t paddr)
{
# 283 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h"
    /* Flush to coherency for table walks... Why? */
    __asm__ volatile("mcr p15, 0, %0, c7, c10, 1" : : "r"(vaddr));
# 294 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h"
    /* Erratum 586323 - end with DMB to ensure the write goes out. */
    dmb();
}

/* D-Cache invalidate to PoC (v6/v7 common) */
static inline void invalidateByVA(vptr_t vaddr, paddr_t paddr)
{





    __asm__ volatile("mcr p15, 0, %0, c7, c6, 1" : : "r"(vaddr));

    dmb();
}

/* I-Cache invalidate to PoU (L2 cache) (v6/v7 common) */
static inline void invalidateByVA_I(vptr_t vaddr, paddr_t paddr)
{




    __asm__ volatile("mcr p15, 0, %0, c7, c5, 1" : : "r"(vaddr));

    isb();
}

/* I-Cache invalidate all to PoU (L2 cache) (v6/v7 common) */
static inline void invalidate_I_PoU(void)
{




    __asm__ volatile("mcr p15, 0, %0, c7, c5, 0" : : "r"(0));
    isb();
}

/* D-Cache clean & invalidate to PoC (v6/v7 common) */
static inline void cleanInvalByVA(vptr_t vaddr, paddr_t paddr)
{







    __asm__ volatile("mcr p15, 0, %0, c7, c14, 1" : : "r"(vaddr));

    dsb();
}

/* Invalidate branch predictors by VA (v6/v7 common) */
static inline void branchFlush(vptr_t vaddr, paddr_t paddr)
{
    __asm__ volatile("mcr p15, 0, %0, c7, c5, 7" : : "r"(vaddr));
}

/* Fault status */

static inline word_t __attribute__((__pure__)) getIFSR(void)
{
    word_t IFSR;
    __asm__ volatile("mrc p15, 0, %0, c5, c0, 1" : "=r"(IFSR));
    return IFSR;
}

static inline word_t __attribute__((__pure__)) getDFSR(void)
{
    word_t DFSR;
    __asm__ volatile("mrc p15, 0, %0, c5, c0, 0" : "=r"(DFSR));
    return DFSR;
}

static inline word_t __attribute__((__pure__)) getFAR(void)
{
    word_t FAR;
    __asm__ volatile("mrc p15, 0, %0, c6, c0, 0" : "=r"(FAR));
    return FAR;
}

static inline word_t getACTLR(void)
{
    word_t ACTLR;
    __asm__ volatile ("mrc p15, 0, %0, c1, c0, 1" : "=r"(ACTLR));
    return ACTLR;
}

static inline void setACTLR(word_t actlr)
{
    __asm__ volatile ("mcr p15, 0, %0, c1, c0, 1" :: "r"(actlr));
}

void arch_clean_invalidate_caches(void);
# 18 "/home/sel4/work/work2/kernel/include/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/machine.h" 2

static inline void* __attribute__((__const__))
ptrFromPAddr(paddr_t paddr)
{
    return (void*)(paddr + (0xe0000000 - 0x60000000));
}

static inline paddr_t __attribute__((__const__))
addrFromPPtr(void* pptr)
{
    return (paddr_t)pptr - (0xe0000000 - 0x60000000);
}

static inline region_t __attribute__((__const__))
paddr_to_pptr_reg(p_region_t p_reg)
{
    return (region_t) {
        p_reg.start + (0xe0000000 - 0x60000000), p_reg.end + (0xe0000000 - 0x60000000)
    };
}

static inline p_region_t __attribute__((__const__))
pptr_to_paddr_reg(region_t reg)
{
    return (p_region_t) {
        reg.start - (0xe0000000 - 0x60000000), reg.end - (0xe0000000 - 0x60000000)
    };
}
# 15 "/home/sel4/work/work2/kernel/include/api/syscall.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/api/syscall.h" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/api/syscall.h" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/kernel/vspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/kernel/vspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/kernel/vspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/kernel/vspace.h" 2

/* PD slot reserved for storing the PD's allocated hardware ASID */


enum pde_pte_tag {
    ME_PDE,
    ME_PTE
};
typedef word_t pde_pte_tag_t;

struct createMappingEntries_ret {
    exception_t status;
    pde_pte_tag_t tag;
    void *pde_pte_ptr;
    unsigned int offset;
    word_t size;
};
typedef struct createMappingEntries_ret createMappingEntries_ret_t;

struct findPDForASID_ret {
    exception_t status;
    pde_t *pd;
};
typedef struct findPDForASID_ret findPDForASID_ret_t;

struct lookupPTSlot_ret {
    exception_t status;
    pte_t *ptSlot;
};
typedef struct lookupPTSlot_ret lookupPTSlot_ret_t;


hw_asid_t getHWASID(asid_t asid);

void copyGlobalMappings(pde_t *newPD);
findPDForASID_ret_t findPDForASID(asid_t asid);
lookupPTSlot_ret_t lookupPTSlot(pde_t *pd, vptr_t vptr);
pde_t* __attribute__((__const__)) lookupPDSlot(pde_t *pd, vptr_t vptr);
void deleteASIDPool(asid_t base, asid_pool_t* pool);
void deleteASID(asid_t asid, pde_t* pd);
void unmapPageTable(asid_t asid, vptr_t vaddr, pte_t* pt);
void unmapPage(vm_page_size_t page_size, asid_t asid, vptr_t vptr, void *pptr);
hw_asid_t getHWASID(asid_t asid);
hw_asid_t findFreeHWASID(void);
void flushPage(vm_page_size_t page_size, pde_t* pd, asid_t asid, word_t vptr);
void flushTable(pde_t* pd, asid_t asid, word_t vptr, pte_t* pt);
void flushSpace(asid_t asid);
void invalidateTLBByASID(asid_t asid);

bool_t __attribute__((__const__)) isIOSpaceFrameCap(cap_t cap);

/* Reserved memory ranges */
static const region_t __attribute__((__section__(".boot.rodata"))) mode_reserved_region[] = {
    {
        ((0xff000000 >> (9 + 12)) + 0) << ARMSectionBits,
        ((0xff000000 >> (9 + 12)) + 1) << ARMSectionBits
    }
};
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 2



cap_t create_it_address_space(cap_t root_cnode_cap, v_region_t it_v_reg);
bool_t create_device_frames(cap_t root_cnode_cap);
cap_t create_unmapped_it_frame_cap(pptr_t pptr, bool_t use_large);
cap_t create_mapped_it_frame_cap(cap_t pd_cap, pptr_t pptr, vptr_t vptr, asid_t asid, bool_t use_large, bool_t executable);

void map_kernel_window(void);
void map_kernel_frame(paddr_t paddr, pptr_t vaddr, vm_rights_t vm_rights, vm_attributes_t vm_attributes);
void activate_global_pd(void);
void write_it_asid_pool(cap_t it_ap_cap, cap_t it_pd_cap);

/* ==================== BOOT CODE FINISHES HERE ==================== */

void idle_thread(void);


/* need a fake array to get the pointer from the linker script */
extern char arm_vector_table[1];

word_t* __attribute__((__pure__)) lookupIPCBuffer(bool_t isReceiver, tcb_t *thread);
exception_t handleVMFault(tcb_t *thread, vm_fault_type_t vm_faultType);
pde_t* pageTableMapped(asid_t asid, vptr_t vaddr, pte_t* pt);
void setVMRoot(tcb_t *tcb);
bool_t __attribute__((__const__)) isValidVTableRoot(cap_t cap);
exception_t checkValidIPCBuffer(vptr_t vptr, cap_t cap);

vm_rights_t __attribute__((__const__)) maskVMRights(vm_rights_t vm_rights,
                               seL4_CapRights_t cap_rights_mask);

exception_t decodeARMMMUInvocation(word_t invLabel, word_t length, cptr_t cptr,
                                   cte_t *cte, cap_t cap, extra_caps_t excaps,
                                   word_t *buffer);


void Arch_userStackTrace(tcb_t *tptr);
# 16 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 2
# 18 "/home/sel4/work/work2/kernel/include/api/syscall.h" 2
# 1 "./arch/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/* This header was generated by kernel/tools/syscall_header_gen.py.
 *
 * To add a system call number, edit kernel/include/api/syscall.xml
 *
 */
# 38 "./arch/api/syscall.h"
enum syscall {
    SysCall = -1,
    SysReplyRecv = -2,
    SysSend = -3,
    SysNBSend = -4,
    SysRecv = -5,
    SysReply = -6,
    SysYield = -7,
    SysNBRecv = -8,

    SysDebugPutChar = -9,
    SysDebugDumpScheduler = -10,


    SysDebugHalt = -11,
    SysDebugCapIdentify = -12,
    SysDebugSnapshot = -13,


    SysDebugNameThread = -14,
# 76 "./arch/api/syscall.h"
};
typedef word_t syscall_t;

/* System call names */

static char *syscall_names[] __attribute__((unused)) = {
         [1] = "Call",
         [2] = "ReplyRecv",
         [3] = "Send",
         [4] = "NBSend",
         [5] = "Recv",
         [6] = "Reply",
         [7] = "Yield",
         [8] = "NBRecv",
};
# 19 "/home/sel4/work/work2/kernel/include/api/syscall.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/debug.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/include/api/debug.h" 2





# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/benchmark.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track_types.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */





# 1 "/home/sel4/work/work2/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * CAmkES project configuration
 * Tue Aug  1 11:39:17 2017
 */
# 18 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track_types.h" 2




/* the following code can be used at any point in the kernel
 * to determine detail about the kernel entry point */
typedef enum {
    Entry_Interrupt,
    Entry_UnknownSyscall,
    Entry_UserLevelFault,
    Entry_DebugFault,
    Entry_VMFault,
    Entry_Syscall,
    Entry_UnimplementedDevice,

    Entry_VCPUFault,




} entry_type_t;

/**
 * @brief Kernel entry logging
 *
 * Encapsulates useful info about the cause of the kernel entry
 */
typedef struct __attribute__((packed)) kernel_entry {
    seL4_Word path: 3;
    union {
        struct {
            seL4_Word word: 29;
        };
        /* Tracked kernel entry info filled from outside this file */
        struct {
            seL4_Word syscall_no: 4;
            seL4_Word cap_type: 5;
            seL4_Word is_fastpath: 1;
            seL4_Word invocation_tag: 19;
        };
    };
} kernel_entry_t;
# 17 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/constants.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */
# 18 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 2

struct lookupCap_ret {
    exception_t status;
    cap_t cap;
};
typedef struct lookupCap_ret lookupCap_ret_t;

struct lookupCapAndSlot_ret {
    exception_t status;
    cap_t cap;
    cte_t *slot;
};
typedef struct lookupCapAndSlot_ret lookupCapAndSlot_ret_t;

struct lookupSlot_raw_ret {
    exception_t status;
    cte_t *slot;
};
typedef struct lookupSlot_raw_ret lookupSlot_raw_ret_t;

struct lookupSlot_ret {
    exception_t status;
    cte_t *slot;
};
typedef struct lookupSlot_ret lookupSlot_ret_t;

struct resolveAddressBits_ret {
    exception_t status;
    cte_t *slot;
    word_t bitsRemaining;
};
typedef struct resolveAddressBits_ret resolveAddressBits_ret_t;

lookupCap_ret_t lookupCap(tcb_t *thread, cptr_t cPtr);
lookupCapAndSlot_ret_t lookupCapAndSlot(tcb_t *thread, cptr_t cPtr);
lookupSlot_raw_ret_t lookupSlot(tcb_t *thread, cptr_t capptr);
lookupSlot_ret_t lookupSlotForCNodeOp(bool_t isSource,
                                      cap_t root, cptr_t capptr,
                                      word_t depth);
lookupSlot_ret_t lookupSourceSlot(cap_t root, cptr_t capptr,
                                  word_t depth);
lookupSlot_ret_t lookupTargetSlot(cap_t root, cptr_t capptr,
                                  word_t depth);
lookupSlot_ret_t lookupPivotSlot(cap_t root, cptr_t capptr,
                                 word_t depth);
resolveAddressBits_ret_t resolveAddressBits(cap_t nodeCap,
                                            cptr_t capptr,
                                            word_t n_bits);
# 20 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 2



extern kernel_entry_t ksKernelEntry;
# 56 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h"
static inline void
benchmark_debug_syscall_start(word_t cptr, word_t msgInfo, word_t syscall)
{
    seL4_MessageInfo_t info = messageInfoFromWord_raw(msgInfo);
    lookupCapAndSlot_ret_t lu_ret = lookupCapAndSlot(ksCurThread, cptr);
    ksKernelEntry.path = Entry_Syscall;
    ksKernelEntry.syscall_no = -syscall;
    ksKernelEntry.cap_type = cap_get_capType(lu_ret.cap);
    ksKernelEntry.invocation_tag = seL4_MessageInfo_get_label(info);
}
# 18 "/home/sel4/work/work2/kernel/include/api/debug.h" 2
# 1 "./arch/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/* This header was generated by kernel/tools/syscall_header_gen.py.
 *
 * To add a system call number, edit kernel/include/api/syscall.xml
 *
 */
# 19 "/home/sel4/work/work2/kernel/include/api/debug.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/include/api/debug.h" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/include/api/debug.h" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 2



int get_num_avail_p_regs(void);
p_region_t get_avail_p_reg(word_t i);
int get_num_dev_p_regs(void);
p_region_t get_dev_p_reg(word_t i);
void map_kernel_devices(void);

void initL2Cache(void);

void initIRQController(void);
void cpu_initLocalIRQController(void);

static inline void plat_cleanL2Range(paddr_t start, paddr_t end);
static inline void plat_invalidateL2Range(paddr_t start, paddr_t end);
static inline void plat_cleanInvalidateL2Range(paddr_t start, paddr_t end);
static inline void plat_cleanInvalidateCache(void);

void cleanInvalidateCacheRange_RAM(word_t start, word_t end, paddr_t pstart);
void cleanCacheRange_RAM(word_t start, word_t end, paddr_t pstart);
void cleanCacheRange_PoU(word_t start, word_t end, paddr_t pstart);
void invalidateCacheRange_RAM(word_t start, word_t end, paddr_t pstart);
void invalidateCacheRange_I(word_t start, word_t end, paddr_t pstart);
void branchFlushRange(word_t start, word_t end, paddr_t pstart);

void clean_D_PoU(void);
void cleanInvalidate_D_PoC(void);
void cleanCaches_PoU(void);
void cleanInvalidateL1Caches(void);

/* Cleaning memory before user-level access */
static inline void clearMemory(word_t* ptr, word_t bits)
{
    memzero(ptr, (1ul << (bits)));
    cleanCacheRange_PoU((word_t)ptr, (word_t)ptr + (1ul << (bits)) - 1,
                        addrFromPPtr(ptr));
}

static inline void clearMemoryRAM(word_t* ptr, word_t bits)
{
    memzero(ptr, (1ul << (bits)));
    cleanCacheRange_RAM((word_t)ptr, (word_t)ptr + (1ul << (bits)) - 1,
                        addrFromPPtr(ptr));
}
# 71 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h"
static inline void Arch_finaliseInterrupt(void)
{
}
# 18 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 2

static inline __attribute__((__const__)) word_t
ready_queues_index(word_t dom, word_t prio)
{
    if (1 > 1) {
        return dom * 256 + prio;
    } else {
        if(!(dom == 0)) _assert_fail("dom == 0", "/home/sel4/work/work2/kernel/include/kernel/thread.h", 25, __FUNCTION__);
        return prio;
    }
}

static inline __attribute__((__const__)) word_t
prio_to_l1index(word_t prio)
{
    return (prio >> 5);
}

static inline __attribute__((__const__)) word_t
l1index_to_prio(word_t l1index)
{
    return (l1index << 5);
}

static inline bool_t __attribute__((__pure__))
isRunnable(const tcb_t *thread)
{
    switch (thread_state_get_tsType(thread->tcbState)) {
    case ThreadState_Running:
    case ThreadState_Restart:



        return true;

    default:
        return false;
    }
}

void configureIdleThread(tcb_t *tcb);
void activateThread(void);
void suspend(tcb_t *target);
void restart(tcb_t *target);
void doIPCTransfer(tcb_t *sender, endpoint_t *endpoint,
                   word_t badge, bool_t grant, tcb_t *receiver);
void doReplyTransfer(tcb_t *sender, tcb_t *receiver, cte_t *slot);
void doNormalTransfer(tcb_t *sender, word_t *sendBuffer, endpoint_t *endpoint,
                      word_t badge, bool_t canGrant, tcb_t *receiver,
                      word_t *receiveBuffer);
void doFaultTransfer(word_t badge, tcb_t *sender, tcb_t *receiver,
                     word_t *receiverIPCBuffer);
void doNBRecvFailedTransfer(tcb_t *thread);
void schedule(void);
void chooseThread(void);
void switchToThread(tcb_t *thread);
void switchToIdleThread(void);
void setDomain(tcb_t *tptr, dom_t dom);
void setPriority(tcb_t *tptr, prio_t prio);
void setMCPriority(tcb_t *tptr, prio_t mcp);
void scheduleTCB(tcb_t *tptr);
void attemptSwitchTo(tcb_t *tptr);
void switchIfRequiredTo(tcb_t *tptr);
void setThreadState(tcb_t *tptr, _thread_state_t ts);
void timerTick(void);
void rescheduleRequired(void);
# 22 "/home/sel4/work/work2/kernel/include/api/debug.h" 2



static inline void
debug_printKernelEntryReason(void)
{
    kprintf("\nKernel entry via ");
    switch (ksKernelEntry.path) {
    case Entry_Interrupt:
        kprintf("Interrupt, irq %lu\n", (unsigned long) ksKernelEntry.word);
        break;
    case Entry_UnknownSyscall:
        kprintf("Unknown syscall, word: %lu", (unsigned long) ksKernelEntry.word);
        break;
    case Entry_VMFault:
        kprintf("VM Fault, fault type: %lu\n", (unsigned long) ksKernelEntry.word);
        break;
    case Entry_UserLevelFault:
        kprintf("User level fault, number: %lu", (unsigned long) ksKernelEntry.word);
        break;





    case Entry_Syscall:
        kprintf("Syscall, number: %ld, %s\n", (long) ksKernelEntry.syscall_no, syscall_names[ksKernelEntry.syscall_no]);
        if (ksKernelEntry.syscall_no == -SysSend ||
                ksKernelEntry.syscall_no == -SysNBSend ||
                ksKernelEntry.syscall_no == -SysCall) {

            kprintf("Cap type: %lu, Invocation tag: %lu\n", (unsigned long) ksKernelEntry.cap_type, (unsigned long) ksKernelEntry.invocation_tag)
                                                                ;
        }
        break;

    case Entry_VCPUFault:
        kprintf("VCPUFault\n");
        break;






    default:
        kprintf("Unknown\n");
        break;

    }
}

/* Prints the user context and stack trace of the current thread */
static inline void
debug_printUserState(void)
{
    tcb_t *tptr = ksCurThread;
    kprintf("Current thread: %s\n", tptr->tcbName);
    kprintf("Next instruction adress: %lx\n", getRestartPC(tptr));
    kprintf("Stack:\n");
    Arch_userStackTrace(tptr);
}

static inline void
debug_printTCB(tcb_t *tcb)
{
    kprintf("%40s\t", tcb->tcbName);
    char* state;
    switch (thread_state_get_tsType(tcb->tcbState)) {
    case ThreadState_Inactive:
        state = "inactive";
        break;
    case ThreadState_Running:
        state = "running";
        break;
    case ThreadState_Restart:
        state = "restart";
        break;
    case ThreadState_BlockedOnReceive:
        state = "blocked on recv";
        break;
    case ThreadState_BlockedOnSend:
        state = "blocked on send";
        break;
    case ThreadState_BlockedOnReply:
        state = "blocked on reply";
        break;
    case ThreadState_BlockedOnNotification:
        state = "blocked on ntfn";
        break;





    case ThreadState_IdleThreadState:
        state = "idle";
        break;
    default:
        _fail("Unknown thread state", "/home/sel4/work/work2/kernel/include/api/debug.h", 121, __func__);
    }

    kprintf("%15s\t%p\t%20lu\n", state, (void *) getRestartPC(tcb), tcb->tcbPriority);
}

static inline void
debug_dumpScheduler(void)
{
    kprintf("Dumping all tcbs!\n");
    kprintf("Name                                    \tState          \tIP                  \t Prio\n");
    kprintf("--------------------------------------------------------------------------------------\n");
    for (tcb_t *curr = ksDebugTCBs; curr != ((void *)0); curr = curr->tcbDebugNext) {
        debug_printTCB(curr);
    }
}
# 20 "/home/sel4/work/work2/kernel/include/api/syscall.h" 2

exception_t handleSyscall(syscall_t syscall);
exception_t handleInterruptEntry(void);
exception_t handleUnknownSyscall(word_t w);
exception_t handleUserLevelFault(word_t w_a, word_t w_b);
exception_t handleVMFaultEvent(vm_fault_type_t vm_faultType);

static inline word_t __attribute__((__pure__))
getSyscallArg(word_t i, word_t* ipc_buffer)
{
    if (i < n_msgRegisters) {
        return getRegister(ksCurThread, msgRegisters[i]);
    }

    if(!(ipc_buffer != ((void *)0))) _assert_fail("ipc_buffer != NULL", "/home/sel4/work/work2/kernel/include/api/syscall.h", 34, __FUNCTION__);
    return ipc_buffer[i + 1];
}

extern extra_caps_t current_extra_caps;
# 17 "/home/sel4/work/work2/kernel/src/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/object.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cap.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




struct deriveCap_ret {
    exception_t status;
    cap_t cap;
};
typedef struct deriveCap_ret deriveCap_ret_t;

struct finaliseCap_ret {
    cap_t remainder;
    irq_t irq;
};
typedef struct finaliseCap_ret finaliseCap_ret_t;
# 20 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/objecttype.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/objecttype.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/objecttype.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/objecttype.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/objecttype.h" 2

deriveCap_ret_t Arch_deriveCap(cte_t *slot, cap_t cap);
cap_t __attribute__((__const__)) Arch_updateCapData(bool_t preserve, word_t data, cap_t cap);
cap_t __attribute__((__const__)) Arch_maskCapRights(seL4_CapRights_t cap_rights_mask, cap_t cap);
cap_t Arch_finaliseCap(cap_t cap, bool_t final);
bool_t __attribute__((__const__)) Arch_hasRecycleRights(cap_t cap);
bool_t __attribute__((__const__)) Arch_sameRegionAs(cap_t cap_a, cap_t cap_b);
bool_t __attribute__((__const__)) Arch_sameObjectAs(cap_t cap_a, cap_t cap_b);
bool_t __attribute__((__const__)) Arch_isFrameType(word_t type);
cap_t Arch_createObject(object_t t, void *regionBase, word_t userSize, bool_t deviceMemory);
exception_t Arch_decodeInvocation(word_t invLabel, word_t length,
                                  cptr_t cptr, cte_t *slot, cap_t cap,
                                  extra_caps_t excaps, bool_t call, word_t *buffer);
void Arch_prepareThreadDelete(tcb_t *thread);
word_t Arch_getObjectSize(word_t t);
# 21 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 2

deriveCap_ret_t deriveCap(cte_t *slot, cap_t cap);
finaliseCap_ret_t finaliseCap(cap_t cap, bool_t final, bool_t exposed);
bool_t __attribute__((__const__)) hasCancelSendRights(cap_t cap);
bool_t __attribute__((__const__)) sameRegionAs(cap_t cap_a, cap_t cap_b);
bool_t __attribute__((__const__)) sameObjectAs(cap_t cap_a, cap_t cap_b);
cap_t __attribute__((__const__)) updateCapData(bool_t preserve, word_t newData, cap_t cap);
cap_t __attribute__((__const__)) maskCapRights(seL4_CapRights_t seL4_CapRights, cap_t cap);
cap_t createObject(object_t t, void *regionBase, word_t, bool_t deviceMemory);
void createNewObjects(object_t t, cte_t *parent, slot_range_t slots,
                      void *regionBase, word_t userSize, bool_t deviceMemory);
exception_t decodeInvocation(word_t invLabel, word_t length,
                             cptr_t capIndex, cte_t *slot, cap_t cap,
                             extra_caps_t excaps, bool_t block, bool_t call,
                             word_t *buffer);
exception_t performInvocation_Endpoint(endpoint_t *ep, word_t badge,
                                       bool_t canGrant, bool_t block,
                                       bool_t call);
exception_t performInvocation_Notification(notification_t *ntfn,
                                           word_t badge);
exception_t performInvocation_Reply(tcb_t *thread, cte_t *slot);
word_t getObjectSize(word_t t, word_t userObjSize);
# 16 "/home/sel4/work/work2/kernel/include/object.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/notification.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/object/notification.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/object/notification.h" 2

void sendSignal(notification_t *ntfnPtr, word_t badge);
void receiveSignal(tcb_t *thread, cap_t cap, bool_t isBlocking);
void cancelAllSignals(notification_t *ntfnPtr);
void cancelSignal(tcb_t *threadPtr, notification_t *ntfnPtr);
void completeSignal(notification_t *ntfnPtr, tcb_t *tcb);
void unbindMaybeNotification(notification_t *ntfnPtr);
void unbindNotification(tcb_t *tcb);
void bindNotification(tcb_t *tcb, notification_t *ntfnPtr);
# 17 "/home/sel4/work/work2/kernel/include/object.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/object.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/endpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/object/endpoint.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/object/endpoint.h" 2

void sendIPC(bool_t blocking, bool_t do_call, word_t badge,
             bool_t canGrant, tcb_t *thread, endpoint_t *epptr);
void receiveIPC(tcb_t *thread, cap_t cap, bool_t isBlocking);
void cancelIPC(tcb_t *tptr);
void cancelAllIPC(endpoint_t *epptr);
void cancelBadgedSends(endpoint_t *epptr, word_t badge);
void replyFromKernel_error(tcb_t *thread);
void replyFromKernel_success_empty(tcb_t *thread);
# 19 "/home/sel4/work/work2/kernel/include/object.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/interrupt.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/interrupt.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/interrupt.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/interrupt.h" 2

exception_t Arch_decodeIRQControlInvocation(word_t invLabel, word_t length,
                                            cte_t *srcSlot, extra_caps_t excaps,
                                            word_t *buffer);

static inline exception_t
Arch_checkIRQ(word_t irq)
{
    if (irq > maxIRQ) {
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 0;
        current_syscall_error.rangeErrorMax = maxIRQ;
        return EXCEPTION_SYSCALL_ERROR;
    }
    return EXCEPTION_NONE;
}
# 18 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 2

exception_t decodeIRQControlInvocation(word_t invLabel, word_t length,
                                       cte_t *srcSlot, extra_caps_t excaps,
                                       word_t *buffer);
exception_t invokeIRQControl(irq_t irq, cte_t *handlerSlot, cte_t *controlSlot);
exception_t decodeIRQHandlerInvocation(word_t invLabel, irq_t irq,
                                       extra_caps_t excaps);
void invokeIRQHandler_AckIRQ(irq_t irq);
void invokeIRQHandler_SetIRQHandler(irq_t irq, cap_t cap, cte_t *slot);
void invokeIRQHandler_ClearIRQHandler(irq_t irq);
void deletingIRQHandler(irq_t irq);
void deletedIRQHandler(irq_t irq);
void handleInterrupt(irq_t irq);
bool_t isIRQActive(irq_t irq);
void setIRQState(irq_state_t irqState, irq_t irq);
# 20 "/home/sel4/work/work2/kernel/include/object.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/include/object.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/include/object.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/include/object.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/untyped.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/object/untyped.h" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/object/untyped.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/object/untyped.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/object/untyped.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/object/untyped.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/include/object/untyped.h" 2

/* It is assumed that every untyped is within seL4_MinUntypedBits and seL4_MaxUntypedBits
 * (inclusive). This means that every untyped stored as seL4_MinUntypedBits
 * subtracted from its size before it is stored in capBlockSize, and
 * capFreeIndex counts in chunks of size 2^seL4_MinUntypedBits. The seL4_MaxUntypedBits
 * is the minimal untyped that can be stored when considering both how
 * many bits of capBlockSize there are, and the largest offset that can
 * be stored in capFreeIndex */







exception_t decodeUntypedInvocation(word_t invLabel, word_t length,
                                    cte_t *slot, cap_t cap,
                                    extra_caps_t excaps, bool_t call,
                                    word_t *buffer);
exception_t invokeUntyped_Retype(cte_t *srcSlot, bool_t reset,
                                 void* retypeBase, object_t newType,
                                 word_t userSize, slot_range_t destSlots,
                                 bool_t deviceMemory);
# 24 "/home/sel4/work/work2/kernel/include/object.h" 2
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/thread.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/kernel/thread.h" 1
/*
 * Copyright 2017, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




static inline word_t
sanitiseRegister(register_t reg, word_t v, bool_t archInfo)
{
    if (reg == CPSR) {

        /* on aarch32 archInfo means 'has VCPU', see Arch_getSanitiseRegisterInfo below */
        if (archInfo) {
            switch (v & 0x1f) {
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x17:
            case 0x1b:
            case 0x1f:
                return v;
            case 0x1a:
            default:
                /* For backwards compatibility, Invalid modes revert to USER mode */
                break;
            }
        }


        return (v & 0xf8000000) | ( (1 << 6) | 0x10 | 0 );
    } else {
        return v;
    }
}

static inline bool_t __attribute__((__pure__))
Arch_getSanitiseRegisterInfo(tcb_t *thread)
{

    return (thread->tcbArch.tcbVCPU != ((void *)0));



}
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/thread.h" 2

void Arch_switchToThread(tcb_t *tcb);
void Arch_switchToIdleThread(void);
void Arch_configureIdleThread(tcb_t *tcb);
void Arch_activateIdleThread(tcb_t *tcb);
# 19 "/home/sel4/work/work2/kernel/src/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/debug.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/machine/debug.h" 2
# 20 "/home/sel4/work/work2/kernel/src/api/faults.c" 2

/* consistency with libsel4 */
typedef int __assert_failed_InvalidRoot[(lookup_fault_invalid_root + 1 == seL4_InvalidRoot) ? 1 : -1];
typedef int __assert_failed_MissingCapability[(lookup_fault_missing_capability + 1 == seL4_MissingCapability) ? 1 : -1];
typedef int __assert_failed_DepthMismatch[(lookup_fault_depth_mismatch + 1 == seL4_DepthMismatch) ? 1 : -1];
typedef int __assert_failed_GuardMismatch[(lookup_fault_guard_mismatch + 1 == seL4_GuardMismatch) ? 1 : -1];
typedef int __assert_failed_seL4_UnknownSyscall_Syscall[((word_t) n_syscallMessage == seL4_UnknownSyscall_Syscall) ? 1 : -1];
typedef int __assert_failed_seL4_UserException_Number[((word_t) n_exceptionMessage == seL4_UserException_Number) ? 1 : -1];
typedef int __assert_failed_seL4_UserException_Code[((word_t) n_exceptionMessage + 1 == seL4_UserException_Code) ? 1 : -1];

static inline unsigned int
setMRs_lookup_failure(tcb_t *receiver, word_t* receiveIPCBuffer,
                      lookup_fault_t luf, unsigned int offset)
{
    word_t lufType = lookup_fault_get_lufType(luf);
    word_t i;

    i = setMR(receiver, receiveIPCBuffer, offset, lufType + 1);

    /* check constants match libsel4 */
    if (offset == seL4_CapFault_LookupFailureType) {
        if(!(offset + 1 == seL4_CapFault_BitsLeft)) _assert_fail("offset + 1 == seL4_CapFault_BitsLeft", "/home/sel4/work/work2/kernel/src/api/faults.c", 41, __FUNCTION__);
        if(!(offset + 2 == seL4_CapFault_DepthMismatch_BitsFound)) _assert_fail("offset + 2 == seL4_CapFault_DepthMismatch_BitsFound", "/home/sel4/work/work2/kernel/src/api/faults.c", 42, __FUNCTION__);
        if(!(offset + 2 == seL4_CapFault_GuardMismatch_GuardFound)) _assert_fail("offset + 2 == seL4_CapFault_GuardMismatch_GuardFound", "/home/sel4/work/work2/kernel/src/api/faults.c", 43, __FUNCTION__);
        if(!(offset + 3 == seL4_CapFault_GuardMismatch_BitsFound)) _assert_fail("offset + 3 == seL4_CapFault_GuardMismatch_BitsFound", "/home/sel4/work/work2/kernel/src/api/faults.c", 44, __FUNCTION__);
    } else {
        if(!(offset == 1)) _assert_fail("offset == 1", "/home/sel4/work/work2/kernel/src/api/faults.c", 46, __FUNCTION__);
    }

    switch (lufType) {
    case lookup_fault_invalid_root:
        return i;

    case lookup_fault_missing_capability:
        return setMR(receiver, receiveIPCBuffer, offset + 1,
                     lookup_fault_missing_capability_get_bitsLeft(luf));

    case lookup_fault_depth_mismatch:
        setMR(receiver, receiveIPCBuffer, offset + 1,
              lookup_fault_depth_mismatch_get_bitsLeft(luf));
        return setMR(receiver, receiveIPCBuffer, offset + 2,
                     lookup_fault_depth_mismatch_get_bitsFound(luf));

    case lookup_fault_guard_mismatch:
        setMR(receiver, receiveIPCBuffer, offset + 1,
              lookup_fault_guard_mismatch_get_bitsLeft(luf));
        setMR(receiver, receiveIPCBuffer, offset + 2,
              lookup_fault_guard_mismatch_get_guardFound(luf));
        return setMR(receiver, receiveIPCBuffer, offset + 3,
                     lookup_fault_guard_mismatch_get_bitsFound(luf));

    default:
        _fail("Invalid lookup failure", "/home/sel4/work/work2/kernel/src/api/faults.c", 72, __func__);
    }
}

static inline void
copyMRsFaultReply(tcb_t *sender, tcb_t *receiver, MessageID_t id, word_t length)
{
    word_t i;
    bool_t archInfo;

    archInfo = Arch_getSanitiseRegisterInfo(receiver);

    for (i = 0; i < (((length)<(n_msgRegisters))?(length):(n_msgRegisters)); i++) {
        register_t r = fault_messages[id][i];
        word_t v = getRegister(sender, msgRegisters[i]);
        setRegister(receiver, r, sanitiseRegister(r, v, archInfo));
    }

    if (i < length) {
        word_t *sendBuf = lookupIPCBuffer(false, sender);
        if (sendBuf) {
            for (; i < length; i++) {
                register_t r = fault_messages[id][i];
                word_t v = sendBuf[i + 1];
                setRegister(receiver, r, sanitiseRegister(r, v, archInfo));
            }
        }
    }
}

static inline void
copyMRsFault(tcb_t *sender, tcb_t *receiver, MessageID_t id,
             word_t length, word_t *receiveIPCBuffer)
{
    word_t i;
    for (i = 0; i < (((length)<(n_msgRegisters))?(length):(n_msgRegisters)); i++) {
        setRegister(receiver, msgRegisters[i], getRegister(sender, fault_messages[id][i]));
    }

    if (receiveIPCBuffer) {
        for (; i < length; i++) {
            receiveIPCBuffer[i + 1] = getRegister(sender, fault_messages[id][i]);
        }
    }
}

bool_t
handleFaultReply(tcb_t *receiver, tcb_t *sender)
{
    /* These lookups are moved inward from doReplyTransfer */
    seL4_MessageInfo_t tag = messageInfoFromWord(getRegister(sender, msgInfoRegister));
    word_t label = seL4_MessageInfo_get_label(tag);
    word_t length = seL4_MessageInfo_get_length(tag);
    seL4_Fault_t fault = receiver->tcbFault;

    switch (seL4_Fault_get_seL4_FaultType(fault)) {
    case seL4_Fault_CapFault:
        return true;

    case seL4_Fault_UnknownSyscall:
        copyMRsFaultReply(sender, receiver, MessageID_Syscall, (((length)<(n_syscallMessage))?(length):(n_syscallMessage)));
        return (label == 0);

    case seL4_Fault_UserException:
        copyMRsFaultReply(sender, receiver, MessageID_Exception, (((length)<(n_exceptionMessage))?(length):(n_exceptionMessage)));
        return (label == 0);
# 186 "/home/sel4/work/work2/kernel/src/api/faults.c"
    default:
        return Arch_handleFaultReply(receiver, sender, seL4_Fault_get_seL4_FaultType(fault));
    }
}

word_t
setMRs_fault(tcb_t *sender, tcb_t* receiver, word_t *receiveIPCBuffer)
{
    switch (seL4_Fault_get_seL4_FaultType(sender->tcbFault)) {
    case seL4_Fault_CapFault:
        setMR(receiver, receiveIPCBuffer, seL4_CapFault_IP, getRestartPC(sender));
        setMR(receiver, receiveIPCBuffer, seL4_CapFault_Addr,
              seL4_Fault_CapFault_get_address(sender->tcbFault));
        setMR(receiver, receiveIPCBuffer, seL4_CapFault_InRecvPhase,
              seL4_Fault_CapFault_get_inReceivePhase(sender->tcbFault));
        return setMRs_lookup_failure(receiver, receiveIPCBuffer,
                                     sender->tcbLookupFailure, seL4_CapFault_LookupFailureType);

    case seL4_Fault_UnknownSyscall: {
        copyMRsFault(sender, receiver, MessageID_Syscall, n_syscallMessage,
                     receiveIPCBuffer);

        return setMR(receiver, receiveIPCBuffer, n_syscallMessage,
                     seL4_Fault_UnknownSyscall_get_syscallNumber(sender->tcbFault));
    }

    case seL4_Fault_UserException: {
        copyMRsFault(sender, receiver, MessageID_Exception,
                     n_exceptionMessage, receiveIPCBuffer);
        setMR(receiver, receiveIPCBuffer, n_exceptionMessage,
              seL4_Fault_UserException_get_number(sender->tcbFault));
        return setMR(receiver, receiveIPCBuffer, n_exceptionMessage + 1u,
                     seL4_Fault_UserException_get_code(sender->tcbFault));
    }
# 244 "/home/sel4/work/work2/kernel/src/api/faults.c"
    default:
        return Arch_setMRs_fault(sender, receiver, receiveIPCBuffer,
                                 seL4_Fault_get_seL4_FaultType(sender->tcbFault));
    }
}
# 1 "/home/sel4/work/work2/kernel/src/api/syscall.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/benchmark.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/benchmark/benchmark.h" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/benchmark/benchmark.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/constants.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */
# 17 "/home/sel4/work/work2/kernel/include/benchmark/benchmark.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/benchmark/benchmark.h" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_tracepoints_types.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */





# 1 "/home/sel4/work/work2/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * CAmkES project configuration
 * Tue Aug  1 11:39:17 2017
 */
# 18 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_tracepoints_types.h" 2
# 19 "/home/sel4/work/work2/kernel/include/benchmark/benchmark.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/hardware.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/include/benchmark/benchmark.h" 2
# 13 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/benchmark.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/benchmark.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation.h" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation_types.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */





# 1 "/home/sel4/work/work2/include/generated/autoconf.h" 1
/*
 * Automatically generated C config: don't edit
 * CAmkES project configuration
 * Tue Aug  1 11:39:17 2017
 */
# 18 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation_types.h" 2
# 17 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/constants.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */
# 18 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation.h" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation.h" 2
# 16 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/faults.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/faulthandler.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/kernel/faulthandler.h" 2

void handleFault(tcb_t *tptr);
exception_t sendFaultIPC(tcb_t *tptr);
void handleDoubleFault(tcb_t *tptr, seL4_Fault_t ex1);
# 21 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 27 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/string.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/string.h" 2



# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/string.h" 2

word_t strnlen(const char *s, word_t maxlen);
word_t strlcpy(char *dest, const char *src, word_t size);
word_t strlcat(char *dest, const char *src, word_t size);
# 28 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/traps.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/kernel/traps.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/kernel/traps.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/traps.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/traps.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/traps.h" 2

static inline void arch_c_entry_hook(void)
{

    /* If using the TPIDRURW register for the IPC buffer then
     * there's no pointer in saving whatever the user put into
     * it since we will overwrite it anyway next time we
     * load the thread */
    if (!1) {
        setRegister(ksCurThread, TPIDRURW, readTPIDRURW());
    }

}

static inline void arch_c_exit_hook(void)
{
}

void __attribute__((externally_visible)) __attribute__((__noreturn__)) restore_user_context(void);

void c_handle_syscall(word_t cptr, word_t msgInfo, syscall_t syscall)
__attribute__((externally_visible)) __attribute__((__section__(".vectors.text")));

void c_handle_interrupt(void)
__attribute__((externally_visible)) __attribute__((__section__(".vectors.text")));

void c_handle_undefined_instruction(void)
__attribute__((externally_visible)) __attribute__((__section__(".vectors.text")));

void c_handle_data_fault(void)
__attribute__((externally_visible)) __attribute__((__section__(".vectors.text")));

void c_handle_instruction_fault(void)
__attribute__((externally_visible)) __attribute__((__section__(".vectors.text")));


void c_handle_vcpu_fault(word_t hsr)
__attribute__((externally_visible)) __attribute__((__section__(".vectors.text")));



void c_handle_enfp(void)
__attribute__((externally_visible)) __attribute__((__section__(".vectors.text")));
# 17 "/home/sel4/work/work2/kernel/include/kernel/traps.h" 2
# 1 "/home/sel4/work/work2/kernel/include/smp/lock.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/smp/lock.h" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/smp/lock.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/smp/lock.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/include/smp/lock.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/include/smp/lock.h" 2
# 1 "/home/sel4/work/work2/kernel/include/smp/ipi.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/smp/ipi.h" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/smp/ipi.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/smp/ipi.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/smp/ipi.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/smp/ipi.h" 2
# 20 "/home/sel4/work/work2/kernel/include/smp/ipi.h" 2
# 22 "/home/sel4/work/work2/kernel/include/smp/lock.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/include/smp/lock.h" 2
# 18 "/home/sel4/work/work2/kernel/include/kernel/traps.h" 2

/* This C function should be the first thing called from C after entry from
 * assembly. It provides a single place to do any entry work that is not
 * done in assembly for various reasons */
static inline void c_entry_hook(void)
{
    arch_c_entry_hook();



}

/* This C function should be the last thing called from C before exiting
 * the kernel (be it to assembly or returning to user space). It provides
 * a place to provide any additional instrumentation or functionality
 * in C before leaving the kernel */
static inline void c_exit_hook(void)
{



    arch_c_exit_hook();
}
# 29 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 30 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2


# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/capdl.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




void capDL(void);
# 33 "/home/sel4/work/work2/kernel/src/api/syscall.c" 2


/* The haskell function 'handleEvent' is split into 'handleXXX' variants
 * for each event causing a kernel entry */

exception_t
handleInterruptEntry(void)
{
    irq_t irq;

    irq = getActiveIRQ();

    if (irq != irqInvalid) {
        handleInterrupt(irq);
        Arch_finaliseInterrupt();
    } else {



        handleSpuriousIRQ();
    }

    schedule();
    activateThread();

    return EXCEPTION_NONE;
}

exception_t
handleUnknownSyscall(word_t w)
{

    if (w == SysDebugPutChar) {
        putchar(getRegister(ksCurThread, capRegister));
        return EXCEPTION_NONE;
    }
    if (w == SysDebugDumpScheduler) {

        debug_dumpScheduler();

        return EXCEPTION_NONE;
    }


    if (w == SysDebugHalt) {
        kprintf("Debug halt syscall from user thread %p\n", ksCurThread);
        halt();
    }
    if (w == SysDebugSnapshot) {
        kprintf("Debug snapshot syscall from user thread %p\n", ksCurThread);
        capDL();
        return EXCEPTION_NONE;
    }
    if (w == SysDebugCapIdentify) {
        word_t cptr = getRegister(ksCurThread, capRegister);
        lookupCapAndSlot_ret_t lu_ret = lookupCapAndSlot(ksCurThread, cptr);
        word_t cap_type = cap_get_capType(lu_ret.cap);
        setRegister(ksCurThread, capRegister, cap_type);
        return EXCEPTION_NONE;
    }

    if (w == SysDebugNameThread) {
        /* This is a syscall meant to aid debugging, so if anything goes wrong
         * then assume the system is completely misconfigured and halt */
        const char *name;
        word_t len;
        word_t cptr = getRegister(ksCurThread, capRegister);
        lookupCapAndSlot_ret_t lu_ret = lookupCapAndSlot(ksCurThread, cptr);
        /* ensure we got a TCB cap */
        word_t cap_type = cap_get_capType(lu_ret.cap);
        if (cap_type != cap_thread_cap) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 104, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("SysDebugNameThread: cap is not a TCB, halting"); kprintf(">>" "\033[0m" "\n"); } while (0);
            halt();
        }
        /* Add 1 to the IPC buffer to skip the message info word */
        name = (const char*)(lookupIPCBuffer(true, ksCurThread) + 1);
        if (!name) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 110, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("SysDebugNameThread: Failed to lookup IPC buffer, halting"); kprintf(">>" "\033[0m" "\n"); } while (0);
            halt();
        }
        /* ensure the name isn't too long */
        len = strnlen(name, seL4_MsgMaxLength * sizeof(word_t));
        if (len == seL4_MsgMaxLength * sizeof(word_t)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 116, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("SysDebugNameThread: Name too long, halting"); kprintf(">>" "\033[0m" "\n"); } while (0);
            halt();
        }
        setThreadName(((tcb_t *)(cap_thread_cap_get_capTCBPtr(lu_ret.cap))), name);
        return EXCEPTION_NONE;
    }
# 193 "/home/sel4/work/work2/kernel/src/api/syscall.c"
    current_fault = seL4_Fault_UnknownSyscall_new(w);
    handleFault(ksCurThread);

    schedule();
    activateThread();

    return EXCEPTION_NONE;
}

exception_t
handleUserLevelFault(word_t w_a, word_t w_b)
{
    current_fault = seL4_Fault_UserException_new(w_a, w_b);
    handleFault(ksCurThread);

    schedule();
    activateThread();

    return EXCEPTION_NONE;
}

exception_t
handleVMFaultEvent(vm_fault_type_t vm_faultType)
{
    exception_t status;

    status = handleVMFault(ksCurThread, vm_faultType);
    if (status != EXCEPTION_NONE) {
        handleFault(ksCurThread);
    }

    schedule();
    activateThread();

    return EXCEPTION_NONE;
}


static exception_t
handleInvocation(bool_t isCall, bool_t isBlocking)
{
    seL4_MessageInfo_t info;
    cptr_t cptr;
    lookupCapAndSlot_ret_t lu_ret;
    word_t *buffer;
    exception_t status;
    word_t length;
    tcb_t *thread;

    thread = ksCurThread;

    info = messageInfoFromWord(getRegister(thread, msgInfoRegister));
    cptr = getRegister(thread, capRegister);

    /* faulting section */
    lu_ret = lookupCapAndSlot(thread, cptr);

    if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 251, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Invocation of invalid cap #%lu.", cptr); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_fault = seL4_Fault_CapFault_new(cptr, false);

        if (isBlocking) {
            handleFault(thread);
        }

        return EXCEPTION_NONE;
    }

    buffer = lookupIPCBuffer(false, thread);

    status = lookupExtraCaps(thread, buffer, info);

    if (__builtin_expect(!!(status != EXCEPTION_NONE), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 266, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Lookup of extra caps failed."); kprintf(">>" "\033[0m" "\n"); } while (0);
        if (isBlocking) {
            handleFault(thread);
        }
        return EXCEPTION_NONE;
    }

    /* Syscall error/Preemptible section */
    length = seL4_MessageInfo_get_length(info);
    if (__builtin_expect(!!(length > n_msgRegisters && !buffer), 0)) {
        length = n_msgRegisters;
    }
    status = decodeInvocation(seL4_MessageInfo_get_label(info), length,
                              cptr, lu_ret.slot, lu_ret.cap,
                              current_extra_caps, isBlocking, isCall,
                              buffer);

    if (__builtin_expect(!!(status == EXCEPTION_PREEMPTED), 0)) {
        return status;
    }

    if (__builtin_expect(!!(status == EXCEPTION_SYSCALL_ERROR), 0)) {
        if (isCall) {
            replyFromKernel_error(thread);
        }
        return EXCEPTION_NONE;
    }

    if (__builtin_expect(!!(thread_state_get_tsType(thread->tcbState) == ThreadState_Restart), 0)
                                                                                 ) {
        if (isCall) {
            replyFromKernel_success_empty(thread);
        }
        setThreadState(thread, ThreadState_Running);
    }

    return EXCEPTION_NONE;
}

static void
handleReply(void)
{
    cte_t *callerSlot;
    cap_t callerCap;

    callerSlot = (((cte_t *)((word_t)(ksCurThread)&~((1ul << (10))-1ul)))+(tcbCaller));
    callerCap = callerSlot->cap;

    switch (cap_get_capType(callerCap)) {
    case cap_reply_cap: {
        tcb_t *caller;

        if (cap_reply_cap_get_capReplyMaster(callerCap)) {
            break;
        }
        caller = ((tcb_t *)(cap_reply_cap_get_capTCBPtr(callerCap)));
        /* Haskell error:
         * "handleReply: caller must not be the current thread" */
        if(!(caller != ksCurThread)) _assert_fail("caller != NODE_STATE(ksCurThread)", "/home/sel4/work/work2/kernel/src/api/syscall.c", 324, __FUNCTION__);
        doReplyTransfer(ksCurThread, caller, callerSlot);
        return;
    }

    case cap_null_cap:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 330, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Attempted reply operation when no reply cap present."); kprintf(">>" "\033[0m" "\n"); } while (0);
        return;

    default:
        break;
    }

    _fail("handleReply: invalid caller cap", "/home/sel4/work/work2/kernel/src/api/syscall.c", 337, __func__);
}

static void
handleRecv(bool_t isBlocking)
{
    word_t epCPtr;
    lookupCap_ret_t lu_ret;

    epCPtr = getRegister(ksCurThread, capRegister);

    lu_ret = lookupCap(ksCurThread, epCPtr);

    if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
        /* current_lookup_fault has been set by lookupCap */
        current_fault = seL4_Fault_CapFault_new(epCPtr, true);
        handleFault(ksCurThread);
        return;
    }

    switch (cap_get_capType(lu_ret.cap)) {
    case cap_endpoint_cap:
        if (__builtin_expect(!!(!cap_endpoint_cap_get_capCanReceive(lu_ret.cap)), 0)) {
            current_lookup_fault = lookup_fault_missing_capability_new(0);
            current_fault = seL4_Fault_CapFault_new(epCPtr, true);
            handleFault(ksCurThread);
            break;
        }

        deleteCallerCap(ksCurThread);
        receiveIPC(ksCurThread, lu_ret.cap, isBlocking);
        break;

    case cap_notification_cap: {
        notification_t *ntfnPtr;
        tcb_t *boundTCB;
        ntfnPtr = ((notification_t *)(cap_notification_cap_get_capNtfnPtr(lu_ret.cap)));
        boundTCB = (tcb_t*)notification_ptr_get_ntfnBoundTCB(ntfnPtr);
        if (__builtin_expect(!!(!cap_notification_cap_get_capNtfnCanReceive(lu_ret.cap) || (boundTCB && boundTCB != ksCurThread)), 0)
                                                                          ) {
            current_lookup_fault = lookup_fault_missing_capability_new(0);
            current_fault = seL4_Fault_CapFault_new(epCPtr, true);
            handleFault(ksCurThread);
            break;
        }

        receiveSignal(ksCurThread, lu_ret.cap, isBlocking);
        break;
    }
    default:
        current_lookup_fault = lookup_fault_missing_capability_new(0);
        current_fault = seL4_Fault_CapFault_new(epCPtr, true);
        handleFault(ksCurThread);
        break;
    }
}

static void
handleYield(void)
{
    tcbSchedDequeue(ksCurThread);
    tcbSchedAppend(ksCurThread);
    rescheduleRequired();
}

exception_t
handleSyscall(syscall_t syscall)
{
    exception_t ret;
    irq_t irq;

    switch (syscall) {
    case SysSend:
        ret = handleInvocation(false, true);
        if (__builtin_expect(!!(ret != EXCEPTION_NONE), 0)) {
            irq = getActiveIRQ();
            if (irq != irqInvalid) {
                handleInterrupt(irq);
                Arch_finaliseInterrupt();
            }
        }
        break;

    case SysNBSend:
        ret = handleInvocation(false, false);
        if (__builtin_expect(!!(ret != EXCEPTION_NONE), 0)) {
            irq = getActiveIRQ();
            if (irq != irqInvalid) {
                handleInterrupt(irq);
                Arch_finaliseInterrupt();
            }
        }
        break;

    case SysCall:
        ret = handleInvocation(true, true);
        if (__builtin_expect(!!(ret != EXCEPTION_NONE), 0)) {
            irq = getActiveIRQ();
            if (irq != irqInvalid) {
                handleInterrupt(irq);
                Arch_finaliseInterrupt();
            }
        }
        break;

    case SysRecv:
        handleRecv(true);
        break;

    case SysReply:
        handleReply();
        break;

    case SysReplyRecv:
        handleReply();
        handleRecv(true);
        break;

    case SysNBRecv:
        handleRecv(false);
        break;

    case SysYield:
        handleYield();
        break;

    default:
        _fail("Invalid syscall", "/home/sel4/work/work2/kernel/src/api/syscall.c", 464, __func__);
    }

    schedule();
    activateThread();

    return EXCEPTION_NONE;
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/fastpath/fastpath.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/armv/armv7-a/armv/context_switch.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */



# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/include/arch/arm/armv/armv7-a/armv/context_switch.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/armv/armv7-a/armv/context_switch.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/armv/armv7-a/armv/context_switch.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/model/statedata.h" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/model/statedata.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/model/statedata.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/model/statedata.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/model/statedata.h" 2




extern asid_pool_t *armKSASIDTable[(1ul << (asidHighBits))] __attribute__((externally_visible));
extern asid_t armKSHWASIDTable[(1ul << (hwASIDBits))] __attribute__((externally_visible));
extern hw_asid_t armKSNextASID __attribute__((externally_visible));
# 36 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/model/statedata.h"
extern pdeS1_t armHSGlobalPGD[(1ul << (2))] __attribute__((externally_visible));
extern pdeS1_t armHSGlobalPD[(1ul << (9))] __attribute__((externally_visible));
extern pteS1_t armHSGlobalPT[(1ul << (9))] __attribute__((externally_visible));
extern pde_t armUSGlobalPD[(1ul << (11))] __attribute__((externally_visible));
/* Stage 2 translations have a slightly different encoding to Stage 1
 * So we need to build a User global PT for global mappings */
extern pte_t armUSGlobalPT[(1ul << (9))] __attribute__((externally_visible));
extern vcpu_t *armHSCurVCPU;
extern bool_t armHSVCPUActive;
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/armv/armv7-a/armv/context_switch.h" 2

static inline void setHardwareASID(hw_asid_t hw_asid)
{



    writeContextID(hw_asid);
}

static inline void armv_contextSwitch_HWASID(pde_t *cap_pd, hw_asid_t hw_asid)
{

    writeContextIDAndPD(hw_asid, addrFromPPtr(cap_pd));
# 51 "/home/sel4/work/work2/kernel/include/arch/arm/armv/armv7-a/armv/context_switch.h"
}

static inline void armv_contextSwitch(pde_t* cap_pd, asid_t asid)
{
    armv_contextSwitch_HWASID(cap_pd, getHWASID(asid));
}
# 20 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */



# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug_conf.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/api/constants.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/armv/armv7-a/armv/debug.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/armv/armv7-a/armv/debug.h" 2
# 20 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug.h" 2


void restore_user_debug_context(tcb_t *target_thread);
void saveAllBreakpointState(tcb_t *t);
void loadAllDisabledBreakpointState(void);


void Arch_debugAssociateVCPUTCB(tcb_t *t);
void Arch_debugDissociateVCPUTCB(tcb_t *t);
# 21 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/smp/lock.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/fpu.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/machine/fpu.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/machine/fpu.h" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/machine/fpu.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/fpu.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/fpu.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/fpu.h" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/fpu.h" 2
# 42 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/fpu.h"
extern bool_t isFPUEnabledCached[1];



/* This variable is set at init time to true if the FPU supports 32 registers (d0-d31) */
extern bool_t isFPUD32SupportedCached;

/* Store state in the FPU registers into memory. */
static inline void saveFpuState(user_fpu_state_t *dest)
{
    word_t fpexc;

    /* Store FPEXC */
    __asm__ volatile("mrc  " " p10, 7,  %0, cr8, cr0, 0" /* 32-bit Floating-Point Exception Control register */ : "=r"(fpexc));
# 68 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/fpu.h"
    dest->fpexc = fpexc;

    /* We don't support asynchronous exceptions */
    if(!((dest->fpexc & (1ul << (31))) == 0)) _assert_fail("(dest->fpexc & BIT(FPEXC_EX_BIT)) == 0", "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/fpu.h", 71, __FUNCTION__);

    if (isFPUD32SupportedCached) {
        register word_t regs_d16_d31 __asm__("ip") = (word_t) &dest->fpregs[16];
        __asm__ volatile(
            ".word 0xeccc0b20        \n" /*  vstmia  ip, {d16-d31} */
            :
            : "r" (regs_d16_d31)
            : "memory"
        );
    }

    register word_t regs_d0_d15 __asm__("r2") = (word_t) &dest->fpregs[0];
    __asm__ volatile(
        /* Store d0 - d15 to memory */
        ".word 0xec820b20       \n" /* vstmia  r2, {d0-d15}" */
        /* Store PFSCR */
        ".word 0xeef1ea10       \n" /* vmrs   lr, fpscr */
        "str  lr, [%[tcb_fpscr]]\n"
        :
        : [tcb_fpscr] "r" (&dest->fpscr), "r" (regs_d0_d15)
        : "memory", "lr"
    );
}

/* Enable the FPU to be used without faulting.
 * Required even if the kernel attempts to use the FPU. */
static inline void enableFpu(void)
{
    word_t fpexc;
    __asm__ volatile("mrc  " " p10, 7,  %0, cr8, cr0, 0" /* 32-bit Floating-Point Exception Control register */ : "=r"(fpexc));
    fpexc |= (1ul << (30));
    do { word_t _v = fpexc; __asm__ volatile("mcr  " " p10, 7,  %0, cr8, cr0, 0" /* 32-bit Floating-Point Exception Control register */ :: "r" (_v)); }while(0);
    isFPUEnabledCached[0] = true;
}

/* Check if FPU is enable */
static inline bool_t isFpuEnable(void)
{
    return isFPUEnabledCached[0];
}

/* Load FPU state from memory into the FPU registers. */
static inline void loadFpuState(user_fpu_state_t *src)
{
    register word_t regs_d16_d31 __asm__("r2") = (word_t) &src->fpregs[16];
    if (isFPUD32SupportedCached) {
        __asm__ volatile(
            ".word 0xecd20b20       \n" /*   vldmia  r2, {d16-d31} */
            :: "r" (regs_d16_d31)
        );
    }

    register word_t regs_d0_d15 __asm__("r0") = (word_t) &src->fpregs[0];
    register word_t regs_fpscr __asm__("r1") = src->fpscr;
    __asm__ volatile(
        /* Restore d0 - d15 from memory */
        ".word 0xec900b20         \n" /*  vldmia  r0, {d0-d15} */
        /* Load fpscr */
        ".word 0xeee11a10         \n" /*  vmsr    fpscr, r1 */
        :: "r" (regs_d0_d15), "r" (regs_fpscr)
    );

    /* Restore FPEXC */
    do { word_t _v = src->fpexc; __asm__ volatile("mcr  " " p10, 7,  %0, cr8, cr0, 0" /* 32-bit Floating-Point Exception Control register */ :: "r" (_v)); }while(0);
}



/* Disable the FPU so that usage of it causes a fault */
static inline void disableFpu(void)
{
    word_t fpexc;
    __asm__ volatile("mrc  " " p10, 7,  %0, cr8, cr0, 0" /* 32-bit Floating-Point Exception Control register */ : "=r"(fpexc));
    fpexc &= ~(1ul << (30));
    do { word_t _v = fpexc; __asm__ volatile("mcr  " " p10, 7,  %0, cr8, cr0, 0" /* 32-bit Floating-Point Exception Control register */ :: "r" (_v)); }while(0);

    isFPUEnabledCached[0] = false;
}
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/fpu.h" 2

bool_t fpsimd_HWCapTest(void);
bool_t fpsimd_init(void);
# 20 "/home/sel4/work/work2/kernel/include/machine/fpu.h" 2



/* Perform any actions required for the deletion of the given thread. */
void fpuThreadDelete(tcb_t *thread);

/* Handle an FPU exception. */
exception_t handleFPUFault(void);

void switchLocalFpuOwner(user_fpu_state_t *new_owner);

/* Switch the current owner of the FPU state on the core specified by 'cpu'. */
void switchFpuOwner(user_fpu_state_t *new_owner, word_t cpu);

/* Returns whether or not the passed thread is using the current active fpu state */
static inline bool_t nativeThreadUsingFPU(tcb_t *thread)
{
    return &thread->tcbArch.tcbContext.fpuState ==
           ksActiveFPUState;
}

static inline void __attribute__((always_inline)) lazyFPURestore(tcb_t *thread)
{
    if (__builtin_expect(!!(ksActiveFPUState), 0)) {
        /* If we have enabled/disabled the FPU too many times without
         * someone else trying to use it, we assume it is no longer
         * in use and switch out its state. */
        if (__builtin_expect(!!(ksFPURestoresSinceSwitch > 64), 0)) {
            switchLocalFpuOwner(((void *)0));
            ksFPURestoresSinceSwitch = 0;
        } else {
            if (__builtin_expect(!!(nativeThreadUsingFPU(thread)), 1)) {
                /* We are using the FPU, make sure it is enabled */
                enableFpu();
            } else {
                /* Someone is using the FPU and it might be enabled */
                disableFpu();
            }
            ksFPURestoresSinceSwitch++;
        }
    } else {
        /* No-one (including us) is using the FPU, so we assume it
         * is currently disabled */
    }
}
# 23 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h" 2

/* When building the fastpath the assembler in traps.S makes these
 * assumptions. Because compile_asserts are hard to do in assembler,
 * we place them here */
typedef int __assert_failed_SysCall_Minus1[(SysCall == -1) ? 1 : -1];
typedef int __assert_failed_SysReplyRecv_Minus2[(SysReplyRecv == -2) ? 1 : -1];

/* Use macros to not break verification */



/** MODIFIES: [*] */
/** DONT_TRANSLATE */
static inline void
clearExMonitor_fp(void)
{
    word_t temp1 = 0;
    word_t temp2;
    __asm__ volatile (
        "strex %[output], %[mem], [%[mem]]"
        : [output]"+r"(temp1)
        : [mem]"r"(&temp2)
    );
}

static inline void __attribute__((always_inline))
switchToThread_fp(tcb_t *thread, pde_t *cap_pd, pde_t stored_hw_asid)
{
    hw_asid_t hw_asid;

    hw_asid = pde_pde_invalid_get_stored_hw_asid(stored_hw_asid);
    armv_contextSwitch_HWASID(cap_pd, hw_asid);
    if (1) {
        vcpu_switch(thread->tcbArch.tcbVCPU);
    }
# 69 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/fastpath/fastpath.h"
    ksCurThread = thread;
    clearExMonitor_fp();
}

static inline void
mdb_node_ptr_mset_mdbNext_mdbRevocable_mdbFirstBadged(
    mdb_node_t *node_ptr, word_t mdbNext,
    word_t mdbRevocable, word_t mdbFirstBadged)
{
    node_ptr->words[1] = mdbNext | (mdbRevocable << 1) | mdbFirstBadged;
}

static inline void
mdb_node_ptr_set_mdbPrev_np(mdb_node_t *node_ptr, word_t mdbPrev)
{
    node_ptr->words[0] = mdbPrev;
}

static inline bool_t
isValidVTableRoot_fp(cap_t pd_cap)
{
    return (pd_cap.words[0] & ((1ul << (5))-1ul)) ==
           ((1ul << (4)) | cap_page_directory_cap);
}

/* This is an accelerated check that msgLength, which appears
   in the bottom of the msgInfo word, is <= 4 and that msgExtraCaps
   which appears above it is zero. We are assuming that n_msgRegisters == 4
   for this check to be useful. By masking out the bottom 3 bits, we are
   really checking that n + 3 <= MASK(3), i.e. n + 3 <= 7 or n <= 4. */
typedef int __assert_failed_n_msgRegisters_eq_4[(n_msgRegisters == 4) ? 1 : -1];
static inline int
fastpath_mi_check(word_t msgInfo)
{
    return ((msgInfo & ((1ul << (seL4_MsgLengthBits + seL4_MsgExtraCapBits))-1ul))
            + 3) & ~((1ul << (3))-1ul);
}

static inline void
fastpath_copy_mrs(word_t length, tcb_t *src, tcb_t *dest)
{
    word_t i;
    register_t reg;

    /* assuming that length < n_msgRegisters */
    for (i = 0; i < length; i ++) {
        /* assuming that the message registers simply increment */
        reg = msgRegisters[0] + i;
        setRegister(dest, reg, getRegister(src, reg));
    }
}

static inline int
fastpath_reply_cap_check(cap_t cap)
{
    return (cap.words[0] & ((1ul << (5))-1ul)) == cap_reply_cap;
}

/** DONT_TRANSLATE */
static inline void __attribute__((__noreturn__))
fastpath_restore(word_t badge, word_t msgInfo, tcb_t *cur_thread)
{
    do {} while (0);

    c_exit_hook();






    writeTPIDRURW(getRegister(ksCurThread, TPIDRURW));



    lazyFPURestore(ksCurThread);


    register word_t badge_reg __asm__("r0") = badge;
    register word_t msgInfo_reg __asm__("r1") = msgInfo;
    register word_t cur_thread_reg __asm__("r2") = (word_t)cur_thread;

    if (1) {
        __asm__ volatile( /* r0 and r1 should be preserved */
            "mov sp, r2         \n"
            /* Pop user registers, preserving r0 and r1 */
            "add sp, sp, #8     \n"
            "pop {r2-r12}       \n"
            /* Retore the user stack pointer */
            "pop {lr}           \n"
            "msr sp_usr, lr     \n"
            /* prepare the exception return lr */
            "ldr lr, [sp, #4]   \n"
            "msr elr_hyp, lr    \n"
            /* prepare the user status register */
            "ldr lr, [sp, #8]   \n"
            "msr spsr_hyp, lr   \n"
            /* Finally, pop our LR */
            "pop {lr}           \n"
            /* Return to user */
            "eret"
            :
            : [badge] "r" (badge_reg),
            [msginfo]"r"(msgInfo_reg),
            [cur_thread]"r"(cur_thread_reg)
            : "memory"
        );
    } else {
        __asm__ volatile("mov sp, r2 \n                  add sp, sp, %[LR_SVC_OFFSET] \n                  ldmdb sp, {r2-lr}^ \n                  rfeia sp"



                     :
                     : [badge]"r"(badge_reg),
                     [msginfo]"r"(msgInfo_reg),
                     [cur_thread]"r"(cur_thread_reg),
                     [LR_SVC_OFFSET]"i"(LR_svc * sizeof(word_t))
                     : "memory"
                    );
    }
    __builtin_unreachable();
}
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/fastpath/fastpath.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/fastpath/fastpath.h" 2

void slowpath(syscall_t syscall)
__attribute__((__noreturn__));

void fastpath_call(word_t cptr, word_t r_msgInfo)
__attribute__((__noreturn__)) __attribute__((__section__(".vectors.fastpath_call")));

void fastpath_reply_recv(word_t cptr, word_t r_msgInfo)
__attribute__((__noreturn__)) __attribute__((__section__(".vectors.fastpath_reply_recv")));
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/traps.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug_conf.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/fpu.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2

# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/arch/arm/32/c_traps.c" 2

/** DONT_TRANSLATE */
void __attribute__((externally_visible)) __attribute__((__noreturn__)) restore_user_context(void)
{
    do {} while (0);

    word_t cur_thread_reg = (word_t) ksCurThread;

    c_exit_hook();






    lazyFPURestore(ksCurThread);



    writeTPIDRURW(getRegister(ksCurThread, TPIDRURW));


    if (1) {
        __asm__ volatile(
            /* Set stack pointer to point at the r0 of the user context. */
            "mov sp, %[cur_thread_reg] \n"
            /* Pop user registers */
            "pop {r0-r12}              \n"
            /* Retore the user stack pointer */
            "pop {lr}                  \n"
            "msr sp_usr, lr            \n"
            /* prepare the eception return lr */
            "ldr lr, [sp, #4]          \n"
            "msr elr_hyp, lr           \n"
            /* prepare the user status register */
            "ldr lr, [sp, #8]          \n"
            "msr spsr_hyp, lr          \n"
            /* Finally, pop our LR */
            "pop {lr}                  \n"
            /* Return to user */
            "eret"
            : /* no output */
            : [cur_thread_reg] "r" (cur_thread_reg)
            : "memory"
        );
    } else {
        __asm__ volatile("mov sp, %[cur_thread] \n                  ldmdb sp, {r0-lr}^ \n                  rfeia sp"


                     : /* no output */
                     : [cur_thread] "r" (cur_thread_reg + LR_svc * sizeof(word_t))
                    );
    }
    __builtin_unreachable();
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/32/idle.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/32/idle.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/32/idle.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/debug.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/include/api/debug.h" 2
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/32/idle.c" 2

void idle_thread(void)
{
    while (1) {
        wfi();
    }
}

/** DONT_TRANSLATE */
void __attribute__((__noreturn__)) __attribute__((noinline)) __attribute__((externally_visible)) halt(void)
{
    /* halt is actually, idle thread without the interrupts */
    __asm__ volatile("cpsid iaf");


    kprintf("halting...");

    debug_printKernelEntryReason();


    idle_thread();
    __builtin_unreachable();
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/thread.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/thread.c" 2

void
Arch_switchToThread(tcb_t *tcb)
{
    setVMRoot(tcb);






    clearExMonitor();
}

__attribute__((__section__(".boot.text"))) void
Arch_configureIdleThread(tcb_t *tcb)
{
    setRegister(tcb, CPSR, ( (1 << 6) | 0x1a | 0 ));
    setRegister(tcb, LR_svc, (word_t)(&idle_thread));
}

void
Arch_switchToIdleThread(void)
{
    if (1) {
        vcpu_switch(((void *)0));
    }

    /* Force the idle thread to run on kernel page table */
    setVMRoot(ksIdleThread);




}

void
Arch_activateIdleThread(tcb_t *tcb)
{
    /* Don't need to do anything */
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/bootinfo.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/bootinfo.h" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/bootinfo.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/bootinfo_types.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */




/* caps with fixed slot positions in the root CNode */

enum {
    seL4_CapNull = 0, /* null cap */
    seL4_CapInitThreadTCB = 1, /* initial thread's TCB cap */
    seL4_CapInitThreadCNode = 2, /* initial thread's root CNode cap */
    seL4_CapInitThreadVSpace = 3, /* initial thread's VSpace cap */
    seL4_CapIRQControl = 4, /* global IRQ controller cap */
    seL4_CapASIDControl = 5, /* global ASID controller cap */
    seL4_CapInitThreadASIDPool = 6, /* initial thread's ASID pool cap */
    seL4_CapIOPort = 7, /* global IO port cap (null cap if not supported) */
    seL4_CapIOSpace = 8, /* global IO space cap (null cap if no IOMMU support) */
    seL4_CapBootInfoFrame = 9, /* bootinfo frame cap */
    seL4_CapInitThreadIPCBuffer = 10, /* initial thread's IPC buffer frame cap */
    seL4_CapDomain = 11, /* global domain controller cap */
    seL4_NumInitialCaps = 12
};

/* Legacy code will have assumptions on the vspace root being a Page Directory
 * type, so for now we define one to the other */


/* types */
typedef seL4_Word seL4_SlotPos;

typedef struct {
    seL4_SlotPos start; /* first CNode slot position OF region */
    seL4_SlotPos end; /* first CNode slot position AFTER region */
} __attribute__((packed)) seL4_SlotRegion;

typedef struct {
    seL4_Word paddr; /* physical address of untyped cap  */
    seL4_Uint8 padding1;
    seL4_Uint8 padding2;
    seL4_Uint8 sizeBits;/* size (2^n) bytes of each untyped */
    seL4_Uint8 isDevice;/* whether the untyped is a device  */
} __attribute__((packed)) seL4_UntypedDesc;

typedef struct {
    seL4_Word extraLen; /* length of any additional bootinfo information */
    seL4_NodeId nodeID; /* ID [0..numNodes-1] of the seL4 node (0 if uniprocessor) */
    seL4_Word numNodes; /* number of seL4 nodes (1 if uniprocessor) */
    seL4_Word numIOPTLevels; /* number of IOMMU PT levels (0 if no IOMMU support) */
    seL4_IPCBuffer* ipcBuffer; /* pointer to initial thread's IPC buffer */
    seL4_SlotRegion empty; /* empty slots (null caps) */
    seL4_SlotRegion sharedFrames; /* shared-frame caps (shared between seL4 nodes) */
    seL4_SlotRegion userImageFrames; /* userland-image frame caps */
    seL4_SlotRegion userImagePaging; /* userland-image paging structure caps */
    seL4_SlotRegion ioSpaceCaps; /* IOSpace caps for ARM SMMU */
    seL4_SlotRegion extraBIPages; /* caps for any pages used to back the additional bootinfo information */
    seL4_Uint8 initThreadCNodeSizeBits; /* initial thread's root CNode size (2^n slots) */
    seL4_Domain initThreadDomain; /* Initial thread's domain ID */
    seL4_Word archInfo; /* tsc freq on x86, unused on arm */
    seL4_SlotRegion untyped; /* untyped-object caps (untyped caps) */
    seL4_UntypedDesc untypedList[280]; /* information about each untyped */
    /* the untypedList should be the last entry in this struct, in order
     * to make this struct easier to represent in other languages */
} __attribute__((packed)) seL4_BootInfo;

/* If extraLen > 0 then 4K after the start of bootinfo is a region of extraLen additional
 * bootinfo structures. Bootinfo structures are arch/platform specific and may or may not
 * exist in any given execution. */
typedef struct {
    /* identifier of the following chunk. IDs are arch/platform specific */
    seL4_Word id;
    /* length of the chunk, including this header */
    seL4_Word len;
} __attribute__((packed)) seL4_BootInfoHeader;

/* Bootinfo identifiers share a global namespace, even if they are arch or platform specific
 * and are enumerated here */
# 17 "/home/sel4/work/work2/kernel/include/bootinfo.h" 2






/* adjust constants in config.h if this assert fails */
typedef int __assert_failed_bi_size[(sizeof(seL4_BootInfo) <= (1ul << (12))) ? 1 : -1];
# 15 "/home/sel4/work/work2/kernel/include/kernel/boot.h" 2







/*
 * Resolve naming differences between the abstract specifications
 * of the bootstrapping phase and the runtime phase of the kernel.
 */
typedef cte_t slot_t;
typedef cte_t* slot_ptr_t;



/* (node-local) state accessed only during bootstrapping */

typedef struct ndks_boot {
    region_t freemem[2];
    seL4_BootInfo* bi_frame;
    seL4_SlotPos slot_pos_cur;
    seL4_SlotPos slot_pos_max;
} ndks_boot_t;

extern ndks_boot_t ndks_boot;

/* function prototypes */

static inline bool_t
is_reg_empty(region_t reg)
{
    return reg.start == reg.end;
}

pptr_t alloc_region(word_t size_bits);
bool_t insert_region(region_t reg);
void write_slot(slot_ptr_t slot_ptr, cap_t cap);
cap_t create_root_cnode(void);
bool_t provide_cap(cap_t root_cnode_cap, cap_t cap);
cap_t create_it_asid_pool(cap_t root_cnode_cap);
void write_it_pd_pts(cap_t root_cnode_cap, cap_t it_pd_cap);
bool_t create_idle_thread(void);
bool_t create_untypeds_for_region(cap_t root_cnode_cap, bool_t device_memory, region_t reg, seL4_SlotPos first_untyped_slot);
bool_t create_kernel_untypeds(cap_t root_cnode_cap, region_t boot_mem_reuse_reg, seL4_SlotPos first_untyped_slot);
void bi_finalise(void);
bool_t create_irq_cnode(void);
void create_domain_cap(cap_t root_cnode_cap);

cap_t create_ipcbuf_frame(cap_t root_cnode_cap, cap_t pd_cap, vptr_t vptr);

region_t allocate_extra_bi_region(word_t extra_size);
pptr_t allocate_bi_frame(node_id_t node_id, word_t num_nodes, vptr_t ipcbuf_vptr);

void create_bi_frame_cap(cap_t root_cnode_cap, cap_t pd_cap, pptr_t pptr, vptr_t vptr);

typedef struct create_frames_of_region_ret {
    seL4_SlotRegion region;
    bool_t success;
} create_frames_of_region_ret_t;

create_frames_of_region_ret_t
create_frames_of_region(
    cap_t root_cnode_cap,
    cap_t pd_cap,
    region_t reg,
    bool_t do_map,
    sword_t pv_offset
);

cap_t
create_it_pd_pts(
    cap_t root_cnode_cap,
    v_region_t ui_v_reg,
    vptr_t ipcbuf_vptr,
    vptr_t bi_frame_vptr
);

tcb_t *
create_initial_thread(
    cap_t root_cnode_cap,
    cap_t it_pd_cap,
    vptr_t ui_v_entry,
    vptr_t bi_frame_vptr,
    vptr_t ipcbuf_vptr,
    cap_t ipcbuf_cap
);

void init_core_state(tcb_t *scheduler_action);
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/stack.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/debug.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/untyped.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "./arch/api/invocation.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */


# 1 "./arch/api/sel4_invocation.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */


# 1 "./api/invocation.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */



enum invocation_label {
    InvalidInvocation,
    UntypedRetype,
    TCBReadRegisters,
    TCBWriteRegisters,
    TCBCopyRegisters,
    TCBConfigure,
    TCBSetPriority,
    TCBSetMCPriority,
    TCBSetIPCBuffer,
    TCBSetSpace,
    TCBSuspend,
    TCBResume,
    TCBBindNotification,
    TCBUnbindNotification,
# 49 "./api/invocation.h"
    CNodeRevoke,
    CNodeDelete,
    CNodeCancelBadgedSends,
    CNodeCopy,
    CNodeMint,
    CNodeMove,
    CNodeMutate,
    CNodeRotate,
    CNodeSaveCaller,
    IRQIssueIRQHandler,
    IRQAckIRQ,
    IRQSetIRQHandler,
    IRQClearIRQHandler,
    DomainSetSet,
    nInvocationLabels
};
# 19 "./arch/api/sel4_invocation.h" 2
enum sel4_arch_invocation_label {
    ARMPDClean_Data = nInvocationLabels,
    ARMPDInvalidate_Data,
    ARMPDCleanInvalidate_Data,
    ARMPDUnify_Instruction,

    ARMVCPUSetTCB,


    ARMVCPUInjectIRQ,


    ARMVCPUReadReg,


    ARMVCPUWriteReg,

    nSeL4ArchInvocationLabels
};
# 19 "./arch/api/invocation.h" 2
enum arch_invocation_label {
    ARMPageTableMap = nSeL4ArchInvocationLabels,
    ARMPageTableUnmap,






    ARMPageMap,
    ARMPageRemap,
    ARMPageUnmap,



    ARMPageClean_Data,
    ARMPageInvalidate_Data,
    ARMPageCleanInvalidate_Data,
    ARMPageUnify_Instruction,
    ARMPageGetAddress,
    ARMASIDControlMakePool,
    ARMASIDPoolAssign,
    nArchInvocationLabels
};
# 26 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 27 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 28 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/devices.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 29 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 30 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/armv/armv7-a/armv/context_switch.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 31 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/iospace.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/iospace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/iospace.h" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/iospace.h" 2
# 31 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/iospace.h"
/* define dummy functions */
static inline seL4_SlotRegion
create_iospace_caps(cap_t root_cnode_cap)
{
    return (seL4_SlotRegion){ .start = 0, .end = 0 };
}

static inline exception_t
decodeARMIOPTInvocation(word_t invLabel, uint32_t length, cte_t* slot, cap_t cap, extra_caps_t excaps, word_t* buffer)
{
    return EXCEPTION_NONE;
}

static inline exception_t
decodeARMIOMapInvocation(word_t invLabel, uint32_t length, cte_t* slot, cap_t cap, extra_caps_t excaps, word_t* buffer)
{
    return EXCEPTION_NONE;
}

static inline exception_t
performPageInvocationUnmapIO(cap_t cap, cte_t *slot)
{
    return EXCEPTION_NONE;
}

static inline exception_t
decodeARMIOSpaceInvocation(word_t invLabel, cap_t cap)
{
    return EXCEPTION_NONE;
}

static inline void
unmapIOPage(cap_t cap)
{
}

static inline void
deleteIOPageTable(cap_t cap)
{
}

static inline void
clearIOPageDirectory(cap_t cap)
{
}
# 32 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/vcpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 33 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/tlb.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/tlb.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/smp/ipi_inline.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/smp/ipi_inline.h" 2
# 1 "/home/sel4/work/work2/kernel/include/smp/ipi.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/smp/ipi_inline.h" 2
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/tlb.h" 2

static inline void invalidateTranslationSingle(vptr_t vptr)
{
    invalidateLocalTLB_VAASID(vptr);
    ;
}

static inline void invalidateTranslationASID(hw_asid_t hw_asid)
{
    invalidateLocalTLB_ASID(hw_asid);
    ;
}

static inline void invalidateTranslationAll(void)
{
    invalidateLocalTLB();
    ;
}
# 34 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c" 2





/* ARM uses multiple identical mappings in a page table / page directory to construct
 * large mappings. In both cases it happens to be 16 entries, which can be calculated by
 * looking at the size difference of the mappings, and is done this way to remove magic
 * numbers littering this code and make it clear what is going on */



/* helper stuff to avoid fencepost errors when
 * getting the last byte of a PTE or PDE */




/* Stage 2 */



/* STage 1 hyp */




struct resolve_ret {
    paddr_t frameBase;
    vm_page_size_t frameSize;
    bool_t valid;
};
typedef struct resolve_ret resolve_ret_t;
# 94 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
/* AP encoding slightly different. AP only used for kernel mappings which are fixed after boot time */
__attribute__((__section__(".boot.text")))
static word_t __attribute__((__const__))
APFromVMRights(vm_rights_t vm_rights)
{
    switch (vm_rights) {
    case VMKernelOnly:
        return 0;
    case VMReadWrite:
        return 1;
    case VMNoAccess:
        /* RO at PL1 only */
        return 2;
    case VMReadOnly:
        return 3;
    default:
        _fail("Invalid VM rights", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 110, __func__);
    }
}

static word_t __attribute__((__const__))
HAPFromVMRights(vm_rights_t vm_rights)
{
    switch (vm_rights) {
    case VMKernelOnly:
    case VMNoAccess:
        return 0;
    case VMReadOnly:
        return 1;
    /*
    case VMWriteOnly:
        return 2;
    */
    case VMReadWrite:
        return 3;
    default:
        _fail("Invalid VM rights", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 130, __func__);
    }
}



vm_rights_t __attribute__((__const__))
maskVMRights(vm_rights_t vm_rights, seL4_CapRights_t cap_rights_mask)
{
    if (vm_rights == VMNoAccess) {
        return VMNoAccess;
    }
    if (vm_rights == VMReadOnly &&
            seL4_CapRights_get_capAllowRead(cap_rights_mask)) {
        return VMReadOnly;
    }
    if (vm_rights == VMReadWrite &&
            seL4_CapRights_get_capAllowRead(cap_rights_mask)) {
        if (!seL4_CapRights_get_capAllowWrite(cap_rights_mask)) {
            return VMReadOnly;
        } else {
            return VMReadWrite;
        }
    }
    if (vm_rights == VMReadWrite &&
            !seL4_CapRights_get_capAllowRead(cap_rights_mask) &&
            seL4_CapRights_get_capAllowWrite(cap_rights_mask)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 157, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Attempted to make unsupported write only mapping"); kprintf(">>" "\033[0m" "\n"); } while (0);
    }
    return VMKernelOnly;
}

/* ==================== BOOT CODE STARTS HERE ==================== */

__attribute__((__section__(".boot.text"))) void
map_kernel_frame(paddr_t paddr, pptr_t vaddr, vm_rights_t vm_rights, vm_attributes_t attributes)
{
    word_t idx = (vaddr & ((1ul << (pageBitsForSize(ARMSection)))-1ul)) >> pageBitsForSize(ARMSmallPage);

    if(!(vaddr >= 0xfff00000)) _assert_fail("vaddr >= PPTR_TOP", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 169, __FUNCTION__); /* vaddr lies in the region the global PT covers */
# 199 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
    armHSGlobalPT[idx] =
        pteS1_pteS1_small_new(
            0, /* Executeable */
            0, /* Executeable at PL1 */
            0, /* Not contiguous */
            paddr,
            0, /* global */
            1, /* AF -- always set */
            0, /* Not shared */
            APFromVMRights(vm_rights),
            0, /* non secure */
            vm_attributes_get_armPageCacheable(attributes)
        );

}
# 332 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
__attribute__((__section__(".boot.text"))) void
map_kernel_window(void)
{
    paddr_t phys;
    uint32_t idx;
    pdeS1_t pde;
    pte_t __attribute__((unused)) pteS2;

    /* Initialise PGD */
    for (idx = 0; idx < 3; idx++) {
        pde = pdeS1_pdeS1_invalid_new();
        armHSGlobalPGD[idx] = pde;
    }
    pde = pdeS1_pdeS1_coarse_new(0, 0, 0, 0, addrFromPPtr(armHSGlobalPD));
    armHSGlobalPGD[3] = pde;

    /* Initialise PMD */
    /* Invalidate up until kernelBase */
    for (idx = 0; idx < (0xe0000000 - 0xC0000000) >> (9 + 12); idx++) {
        pde = pdeS1_pdeS1_invalid_new();
        armHSGlobalPD[idx] = pde;
    }
    /* mapping of kernelBase (virtual address) to kernel's physBase  */
    /* up to end of virtual address space minus 2M using 2M frames */
    phys = 0x60000000;
    for (; idx < (1ul << (9)) - 1; idx++) {
        pde = pdeS1_pdeS1_section_new(
                  0, /* Executable */
                  0, /* Executable in PL1 */
                  0, /* Not contiguous */
                  phys, /* Address */
                  0, /* global */
                  1, /* AF -- always set to 1 */
                  0, /* Not Shareable */
                  0, /* AP: WR at PL1 only */
                  0, /* Not secure */
                  1 /* outer write-back Cacheable */
              );
        armHSGlobalPD[idx] = pde;
        phys += (1ul << (9 + 12));
    }
    /* map page table covering last 2M of virtual address space */
    pde = pdeS1_pdeS1_coarse_new(0, 0, 0, 0, addrFromPPtr(armHSGlobalPT));
    armHSGlobalPD[idx] = pde;

    /* now start initialising the page table */
    memzero(armHSGlobalPT, 1 << 12);
    for (idx = 0; idx < 256; idx++) {
        pteS1_t pte;
        pte = pteS1_pteS1_small_new(
                  0, /* Executable */
                  0, /* Executable in PL1 */
                  0, /* Not contiguous */
                  phys, /* Address */
                  0, /* global */
                  1, /* AF -- always set to 1 */
                  0, /* Not Shareable */
                  0, /* AP: WR at PL1 only */
                  0, /* Not secure */
                  1 /* outer write-back Cacheable */
              );
        armHSGlobalPT[idx] = pte;
        phys += (1ul << (12));
    }
    /* map vector table */
    map_kernel_frame(
        addrFromPPtr(arm_vector_table),
        0xffff0000,
        VMKernelOnly,
        vm_attributes_new(
            false, /* armExecuteNever */
            true, /* armParityEnabled */
            true /* armPageCacheable */
        )
    );
# 435 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
    map_kernel_devices();
}



static __attribute__((__section__(".boot.text"))) void
map_it_frame_cap(cap_t pd_cap, cap_t frame_cap, bool_t executable)
{
    pte_t* pt;
    pte_t* targetSlot;
    pde_t* pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(pd_cap)));
    void* frame = (void*)generic_frame_cap_get_capFBasePtr(frame_cap);
    vptr_t vptr = generic_frame_cap_get_capFMappedAddress(frame_cap);

    if(!(generic_frame_cap_get_capFMappedASID(frame_cap) != 0)) _assert_fail("generic_frame_cap_get_capFMappedASID(frame_cap) != 0", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 449, __FUNCTION__);

    pd += (vptr >> pageBitsForSize(ARMSection));
    pt = ptrFromPAddr(pde_pde_coarse_ptr_get_address(pd));
    targetSlot = pt + ((vptr & ((1ul << (pageBitsForSize(ARMSection)))-1ul))
                       >> pageBitsForSize(ARMSmallPage));
# 468 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
    *targetSlot = pte_pte_small_new(
                      0, /* Executeable */
                      0, /* Not contiguous */
                      addrFromPPtr(frame),
                      1, /* AF -- always set */
                      0, /* Not shared */
                      HAPFromVMRights(VMReadWrite),
                      0xf /* Inner and Outer write-back */ /* Cacheable */
                  );

}

/* Create a frame cap for the initial thread. */

static __attribute__((__section__(".boot.text"))) cap_t
create_it_frame_cap(pptr_t pptr, vptr_t vptr, asid_t asid, bool_t use_large)
{
    if (use_large)
        return
            cap_frame_cap_new(
                ARMSection, /* capFSize           */
                (asid & ((1ul << (asidLowBits))-1ul)), /* capFMappedASIDLow  */
                wordFromVMRights(VMReadWrite), /* capFVMRights       */
                vptr, /* capFMappedAddress  */
                false, /* capFIsDevice       */
                ((asid >> asidLowBits) & ((1ul << (asidHighBits))-1ul)), /* capFMappedASIDHigh */
                pptr /* capFBasePtr        */
            );
    else
        return
            cap_small_frame_cap_new(
                (asid & ((1ul << (asidLowBits))-1ul)), /* capFMappedASIDLow  */
                wordFromVMRights(VMReadWrite), /* capFVMRights       */
                vptr, /* capFMappedAddress  */
                false, /* capFIsDevice       */



                ((asid >> asidLowBits) & ((1ul << (asidHighBits))-1ul)), /* capFMappedASIDHigh */
                pptr /* capFBasePtr        */
            );
}

static __attribute__((__section__(".boot.text"))) void
map_it_pt_cap(cap_t pd_cap, cap_t pt_cap)
{
    pde_t* pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(pd_cap)));
    pte_t* pt = ((pte_t *)cap_page_table_cap_get_capPTBasePtr(pt_cap));
    vptr_t vptr = cap_page_table_cap_get_capPTMappedAddress(pt_cap);
    pde_t* targetSlot = pd + (vptr >> pageBitsForSize(ARMSection));

    if(!(cap_page_table_cap_get_capPTIsMapped(pt_cap))) _assert_fail("cap_page_table_cap_get_capPTIsMapped(pt_cap)", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 519, __FUNCTION__);
# 528 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
    *targetSlot = pde_pde_coarse_new(addrFromPPtr(pt));

}

/* Create a page table for the initial thread */

static __attribute__((__section__(".boot.text"))) cap_t
create_it_page_table_cap(cap_t pd, pptr_t pptr, vptr_t vptr, asid_t asid)
{
    cap_t cap;
    cap = cap_page_table_cap_new(
              1, /* capPTIsMapped      */
              asid, /* capPTMappedASID    */
              vptr, /* capPTMappedAddress */
              pptr /* capPTBasePtr       */
          );
    if (asid != asidInvalid) {
        map_it_pt_cap(pd, cap);
    }
    return cap;
}

/* Create an address space for the initial thread.
 * This includes page directory and page tables */
__attribute__((__section__(".boot.text"))) cap_t
create_it_address_space(cap_t root_cnode_cap, v_region_t it_v_reg)
{
    cap_t pd_cap;
    vptr_t pt_vptr;
    pptr_t pt_pptr;
    seL4_SlotPos slot_pos_before;
    seL4_SlotPos slot_pos_after;
    pptr_t pd_pptr;

    /* create PD obj and cap */
    pd_pptr = alloc_region(14);
    if (!pd_pptr) {
        return cap_null_cap_new();
    }
    memzero(((pde_t *)(pd_pptr)), 1 << 14);
    copyGlobalMappings(((pde_t *)(pd_pptr)));
    cleanCacheRange_PoU(pd_pptr, pd_pptr + (1 << 14) - 1,
                        addrFromPPtr((void *)pd_pptr));
    pd_cap =
        cap_page_directory_cap_new(
            true, /* capPDIsMapped   */
            1 /* initial thread's ASID */, /* capPDMappedASID */
            pd_pptr /* capPDBasePtr    */
        );
    slot_pos_before = ndks_boot.slot_pos_cur;
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapInitThreadVSpace)), pd_cap);

    /* create all PT objs and caps necessary to cover userland image */

    for (pt_vptr = (((it_v_reg.start) >> (9 + 12)) << (9 + 12));
            pt_vptr < it_v_reg.end;
            pt_vptr += (1ul << (9 + 12))) {
        pt_pptr = alloc_region(12);
        if (!pt_pptr) {
            return cap_null_cap_new();
        }
        memzero(((pte_t *)pt_pptr), 1 << 12);
        if (!provide_cap(root_cnode_cap,
                         create_it_page_table_cap(pd_cap, pt_pptr, pt_vptr, 1 /* initial thread's ASID */))
           ) {
            return cap_null_cap_new();
        }
    }

    slot_pos_after = ndks_boot.slot_pos_cur;
    ndks_boot.bi_frame->userImagePaging = (seL4_SlotRegion) {
        slot_pos_before, slot_pos_after
    };

    return pd_cap;
}

__attribute__((__section__(".boot.text"))) cap_t
create_unmapped_it_frame_cap(pptr_t pptr, bool_t use_large)
{
    return create_it_frame_cap(pptr, 0, asidInvalid, use_large);
}

__attribute__((__section__(".boot.text"))) cap_t
create_mapped_it_frame_cap(cap_t pd_cap, pptr_t pptr, vptr_t vptr, asid_t asid, bool_t use_large, bool_t executable)
{
    cap_t cap = create_it_frame_cap(pptr, vptr, asid, use_large);
    map_it_frame_cap(pd_cap, cap, executable);
    return cap;
}
# 636 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
__attribute__((__section__(".boot.text"))) void
activate_global_pd(void)
{
    uint32_t r;
    /* Ensure that there's nothing stale in newly-mapped regions, and
       that everything we've written (particularly the kernel page tables)
       is committed. */
    cleanInvalidateL1Caches();
    /* Setup the memory attributes: We use 2 indicies (cachable/non-cachable) */
    setHMAIR((0x0 /* strongly ordered or device memory */ << 0) | (0xff /* Inner and Outer RW write-back non-transient */ << 8), 0);
    setCurrentHypPD(addrFromPPtr(armHSGlobalPGD));
    invalidateHypTLB();




    /* TODO find a better place to init the VMMU */
    r = 0;
    /* Translation range */
    r |= (0x0 << 0); /* 2^(32 -(0)) input range. */
    r |= (r & 0x8) << 1; /* Sign bit */
    /* starting level */
    r |= (0x0 << 6); /* Start at second level */
    /* Sharability of tables */
    r |= (1ul << (8)); /* Inner write-back, write-allocate */
    r |= (1ul << (10)); /* Outer write-back, write-allocate */
    /* Long descriptor format (not that we have a choice) */
    r |= (1ul << (31));
    setVTCR(r);
}



__attribute__((__section__(".boot.text"))) void
write_it_asid_pool(cap_t it_ap_cap, cap_t it_pd_cap)
{
    asid_pool_t* ap = ((asid_pool_t *)(pptr_t)cap_get_capPtr(it_ap_cap));
    ap->array[1 /* initial thread's ASID */] = ((pde_t *)((pptr_t)cap_get_capPtr(it_pd_cap)));
    armKSASIDTable[1 /* initial thread's ASID */ >> asidLowBits] = ap;
}

/* ==================== BOOT CODE FINISHES HERE ==================== */

findPDForASID_ret_t
findPDForASID(asid_t asid)
{
    findPDForASID_ret_t ret;
    asid_pool_t *poolPtr;
    pde_t *pd;

    poolPtr = armKSASIDTable[asid >> asidLowBits];
    if (__builtin_expect(!!(!poolPtr), 0)) {
        current_lookup_fault = lookup_fault_invalid_root_new();

        ret.pd = ((void *)0);
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    }

    pd = poolPtr->array[asid & ((1ul << (asidLowBits))-1ul)];
    if (__builtin_expect(!!(!pd), 0)) {
        current_lookup_fault = lookup_fault_invalid_root_new();

        ret.pd = ((void *)0);
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    }

    ret.pd = pd;
    ret.status = EXCEPTION_NONE;
    return ret;
}

word_t * __attribute__((__pure__))
lookupIPCBuffer(bool_t isReceiver, tcb_t *thread)
{
    word_t w_bufferPtr;
    cap_t bufferCap;
    vm_rights_t vm_rights;

    w_bufferPtr = thread->tcbIPCBuffer;
    bufferCap = (((cte_t *)((word_t)(thread)&~((1ul << (10))-1ul)))+(tcbBuffer))->cap;

    if (__builtin_expect(!!(cap_get_capType(bufferCap) != cap_small_frame_cap && cap_get_capType(bufferCap) != cap_frame_cap), 0)
                                                             ) {
        return ((void *)0);
    }
    if (__builtin_expect(!!(generic_frame_cap_get_capFIsDevice(bufferCap)), 0)) {
        return ((void *)0);
    }

    vm_rights = generic_frame_cap_get_capFVMRights(bufferCap);
    if (__builtin_expect(!!(vm_rights == VMReadWrite || (!isReceiver && vm_rights == VMReadOnly)), 1)
                                                        ) {
        word_t basePtr;
        unsigned int pageBits;

        basePtr = generic_frame_cap_get_capFBasePtr(bufferCap);
        pageBits = pageBitsForSize(generic_frame_cap_get_capFSize(bufferCap));
        return (word_t *)(basePtr + (w_bufferPtr & ((1ul << (pageBits))-1ul)));
    } else {
        return ((void *)0);
    }
}

exception_t
checkValidIPCBuffer(vptr_t vptr, cap_t cap)
{
    if (__builtin_expect(!!(cap_get_capType(cap) != cap_small_frame_cap && cap_get_capType(cap) != cap_frame_cap), 0)
                                                       ) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 746, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Requested IPC Buffer is not a frame cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
    if (__builtin_expect(!!(generic_frame_cap_get_capFIsDevice(cap)), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 751, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Specifying a device frame as an IPC buffer is not permitted."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (__builtin_expect(!!(vptr & ((1ul << (9))-1ul)), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 758, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Requested IPC Buffer location 0x%x is not aligned.", (int)vptr); kprintf(">>" "\033[0m" "\n"); } while (0)
                            ;
        current_syscall_error.type = seL4_AlignmentError;
        return EXCEPTION_SYSCALL_ERROR;
    }

    return EXCEPTION_NONE;
}

pde_t * __attribute__((__const__))
lookupPDSlot(pde_t *pd, vptr_t vptr)
{
    unsigned int pdIndex;

    pdIndex = vptr >> (12 + 9);
    return pd + pdIndex;
}

lookupPTSlot_ret_t
lookupPTSlot(pde_t *pd, vptr_t vptr)
{
    lookupPTSlot_ret_t ret;
    pde_t *pdSlot;

    pdSlot = lookupPDSlot(pd, vptr);

    if (__builtin_expect(!!(pde_ptr_get_pdeType(pdSlot) != pde_pde_coarse), 0)) {
        current_lookup_fault = lookup_fault_missing_capability_new(9 + 12);

        ret.ptSlot = ((void *)0);
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    } else {
        pte_t *pt, *ptSlot;
        unsigned int ptIndex;

        pt = ptrFromPAddr(pde_pde_coarse_ptr_get_address(pdSlot));
        ptIndex = (vptr >> 12) & ((1ul << (9))-1ul);
        ptSlot = pt + ptIndex;

        ret.ptSlot = ptSlot;
        ret.status = EXCEPTION_NONE;
        return ret;
    }
}

static pte_t *
lookupPTSlot_nofail(pte_t *pt, vptr_t vptr)
{
    unsigned int ptIndex;

    ptIndex = (vptr >> 12) & ((1ul << (9))-1ul);
    return pt + ptIndex;
}

static const resolve_ret_t default_resolve_ret_t;

static resolve_ret_t
resolveVAddr(pde_t *pd, vptr_t vaddr)
{
    pde_t *pde = lookupPDSlot(pd, vaddr);
    resolve_ret_t ret = default_resolve_ret_t;

    ret.valid = true;

    switch (pde_ptr_get_pdeType(pde)) {
    case pde_pde_section:
        ret.frameBase = pde_pde_section_ptr_get_address(pde);







        if (pde_pde_section_ptr_get_contiguous_hint(pde)) {
            /* Entires are represented as 16 contiguous sections. We need to mask
               to get the super section frame base */
            ret.frameBase &= ~((1ul << (pageBitsForSize(ARMSuperSection)))-1ul);
            ret.frameSize = ARMSuperSection;
        } else {
            ret.frameSize = ARMSection;
        }

        return ret;

    case pde_pde_coarse: {
        pte_t *pt = ptrFromPAddr(pde_pde_coarse_ptr_get_address(pde));
        pte_t *pte = lookupPTSlot_nofail(pt, vaddr);
        switch (pte_ptr_get_pteType(pte)) {
        case pte_pte_small:
            ret.frameBase = pte_pte_small_ptr_get_address(pte);

            if (pte_pte_small_ptr_get_contiguous_hint(pte)) {
                /* Entries are represented as 16 contiguous small frames. We need to mask
                   to get the large frame base */
                ret.frameBase &= ~((1ul << (pageBitsForSize(ARMLargePage)))-1ul);
                ret.frameSize = ARMLargePage;
            } else {
                ret.frameSize = ARMSmallPage;
            }



            return ret;







        default:
            break;
        }
        break;
    }
    }

    ret.valid = false;
    return ret;
}

static pte_t __attribute__((__const__))
makeUserPTE(vm_page_size_t page_size, paddr_t paddr,
            bool_t cacheable, bool_t nonexecutable, vm_rights_t vm_rights)
{
    pte_t pte;
# 945 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
    word_t hap;

    hap = HAPFromVMRights(vm_rights);

    switch (page_size) {
    case ARMSmallPage: {
        if (cacheable) {
            pte = pte_pte_small_new(
                      nonexecutable, /* Executable */
                      0, /* Not contiguous */
                      paddr,
                      1, /* AF - Always set */
                      0, /* not shared */
                      hap, /* HAP - access */
                      0xf /* Inner and Outer write-back */ /* Cacheable */);
        } else {
            pte = pte_pte_small_new(
                      nonexecutable, /* Executable */
                      0, /* Not contiguous */
                      paddr,
                      1, /* AF - Always set */
                      0, /* not shared */
                      hap, /* HAP - access */
                      0x0 /* Strongly ordered or device memory */ /* Not cacheable */);
        }
        break;
    }

    case ARMLargePage: {
        if (cacheable) {
            pte = pte_pte_small_new(
                      nonexecutable, /* Executable */
                      1, /* 16 contiguous */
                      paddr,
                      1, /* AF - Always set */
                      0, /* not shared */
                      hap, /* HAP - access */
                      0xf /* Inner and Outer write-back */ /* Cacheable */);
        } else {
            pte = pte_pte_small_new(
                      nonexecutable, /* Executable */
                      1, /* 16 contiguous */
                      paddr,
                      1, /* AF - Always set */
                      0, /* not shared */
                      hap, /* HAP - access */
                      0x0 /* Strongly ordered or device memory */ /* Not cacheable */);
        }
        break;
    }
    default:
        _fail("Invalid PTE frame type", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 996, __func__);
    }


    return pte;
}

static pde_t __attribute__((__const__))
makeUserPDE(vm_page_size_t page_size, paddr_t paddr, bool_t parity,
            bool_t cacheable, bool_t nonexecutable, word_t domain,
            vm_rights_t vm_rights)
{





    word_t hap, size2;

    (void)domain;
    hap = HAPFromVMRights(vm_rights);


    switch (page_size) {
    case ARMSection:
        size2 = 0;
        break;

    case ARMSuperSection:
        size2 = 1;
        break;

    default:
        _fail("Invalid PDE frame type", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1029, __func__);
    }
# 1051 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
    if (cacheable) {
        return pde_pde_section_new(
                   nonexecutable, /* Executable */
                   size2, /* contiguous */
                   paddr,
                   1, /* AF - Always set */
                   0, /* not shared */
                   hap,
                   0xf /* Inner and Outer write-back */ /* Cacheable */);
    } else {
        return pde_pde_section_new(
                   nonexecutable, /* Executable */
                   size2, /* contiguous */
                   paddr,
                   1, /* AF - Always set */
                   0, /* not shared */
                   hap,
                   0x0 /* Strongly ordered or device memory */ /* Not cacheable */);
    }

}

bool_t __attribute__((__const__))
isValidVTableRoot(cap_t cap)
{
    return cap_get_capType(cap) == cap_page_directory_cap &&
           cap_page_directory_cap_get_capPDIsMapped(cap);
}

bool_t __attribute__((__const__))
isIOSpaceFrameCap(cap_t cap)
{



    return false;

}

void
setVMRoot(tcb_t *tcb)
{
    cap_t threadRoot;
    asid_t asid;
    pde_t *pd;
    findPDForASID_ret_t find_ret;

    threadRoot = (((cte_t *)((word_t)(tcb)&~((1ul << (10))-1ul)))+(tcbVTable))->cap;

    if (cap_get_capType(threadRoot) != cap_page_directory_cap ||
            !cap_page_directory_cap_get_capPDIsMapped(threadRoot)) {

        setCurrentPD(addrFromPPtr(armUSGlobalPD));



        return;
    }

    pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(threadRoot)));
    asid = cap_page_directory_cap_get_capPDMappedASID(threadRoot);
    find_ret = findPDForASID(asid);
    if (__builtin_expect(!!(find_ret.status != EXCEPTION_NONE || find_ret.pd != pd), 0)) {

        setCurrentPD(addrFromPPtr(armUSGlobalPD));



        return;
    }

    armv_contextSwitch(pd, asid);
    if (1) {
        vcpu_switch(tcb->tcbArch.tcbVCPU);
    }
}

static bool_t
setVMRootForFlush(pde_t* pd, asid_t asid)
{
    cap_t threadRoot;

    threadRoot = (((cte_t *)((word_t)(ksCurThread)&~((1ul << (10))-1ul)))+(tcbVTable))->cap;

    if (cap_get_capType(threadRoot) == cap_page_directory_cap &&
            cap_page_directory_cap_get_capPDIsMapped(threadRoot) &&
            ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(threadRoot))) == pd) {
        return false;
    }

    armv_contextSwitch(pd, asid);

    return true;
}

pde_t *
pageTableMapped(asid_t asid, vptr_t vaddr, pte_t* pt)
{
    findPDForASID_ret_t find_ret;
    pde_t pde;
    unsigned int pdIndex;

    find_ret = findPDForASID(asid);
    if (__builtin_expect(!!(find_ret.status != EXCEPTION_NONE), 0)) {
        return ((void *)0);
    }

    pdIndex = vaddr >> (12 + 9);
    pde = find_ret.pd[pdIndex];

    if (__builtin_expect(!!(pde_get_pdeType(pde) == pde_pde_coarse && ptrFromPAddr (pde_pde_coarse_get_address(pde)) == pt), 1)
                                                                       ) {
        return find_ret.pd;
    } else {
        return ((void *)0);
    }
}

static void
invalidateASID(asid_t asid)
{
    asid_pool_t *asidPool;
    pde_t *pd;

    asidPool = armKSASIDTable[asid >> asidLowBits];
    if(!(asidPool)) _assert_fail("asidPool", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1176, __FUNCTION__);

    pd = asidPool->array[asid & ((1ul << (asidLowBits))-1ul)];
    if(!(pd)) _assert_fail("pd", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1179, __FUNCTION__);

    pd[(0xff000000 >> (9 + 12))] = pde_pde_invalid_new(0, false);
}

static pde_t __attribute__((__pure__))
loadHWASID(asid_t asid)
{
    asid_pool_t *asidPool;
    pde_t *pd;

    asidPool = armKSASIDTable[asid >> asidLowBits];
    if(!(asidPool)) _assert_fail("asidPool", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1191, __FUNCTION__);

    pd = asidPool->array[asid & ((1ul << (asidLowBits))-1ul)];
    if(!(pd)) _assert_fail("pd", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1194, __FUNCTION__);

    return pd[(0xff000000 >> (9 + 12))];
}

static void
storeHWASID(asid_t asid, hw_asid_t hw_asid)
{
    asid_pool_t *asidPool;
    pde_t *pd;

    asidPool = armKSASIDTable[asid >> asidLowBits];
    if(!(asidPool)) _assert_fail("asidPool", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1206, __FUNCTION__);

    pd = asidPool->array[asid & ((1ul << (asidLowBits))-1ul)];
    if(!(pd)) _assert_fail("pd", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1209, __FUNCTION__);

    /* Store HW ASID in the last entry
       Masquerade as an invalid PDE */
    pd[(0xff000000 >> (9 + 12))] = pde_pde_invalid_new(hw_asid, true);

    armKSHWASIDTable[hw_asid] = asid;
}

hw_asid_t
findFreeHWASID(void)
{
    word_t hw_asid_offset;
    hw_asid_t hw_asid;

    /* Find a free hardware ASID */
    for (hw_asid_offset = 0;
            hw_asid_offset <= (word_t)((hw_asid_t) - 1);
            hw_asid_offset ++) {
        hw_asid = armKSNextASID + ((hw_asid_t)hw_asid_offset);
        if (armKSHWASIDTable[hw_asid] == asidInvalid) {
            return hw_asid;
        }
    }

    hw_asid = armKSNextASID;

    /* If we've scanned the table without finding a free ASID */
    invalidateASID(armKSHWASIDTable[hw_asid]);

    /* Flush TLB */
    invalidateTranslationASID(hw_asid);
    armKSHWASIDTable[hw_asid] = asidInvalid;

    /* Increment the NextASID index */
    armKSNextASID++;

    return hw_asid;
}

hw_asid_t
getHWASID(asid_t asid)
{
    pde_t stored_hw_asid;

    stored_hw_asid = loadHWASID(asid);
    if (pde_pde_invalid_get_stored_asid_valid(stored_hw_asid)) {
        return pde_pde_invalid_get_stored_hw_asid(stored_hw_asid);
    } else {
        hw_asid_t new_hw_asid;

        new_hw_asid = findFreeHWASID();
        storeHWASID(asid, new_hw_asid);
        return new_hw_asid;
    }
}

static void
invalidateASIDEntry(asid_t asid)
{
    pde_t stored_hw_asid;

    stored_hw_asid = loadHWASID(asid);
    if (pde_pde_invalid_get_stored_asid_valid(stored_hw_asid)) {
        armKSHWASIDTable[pde_pde_invalid_get_stored_hw_asid(stored_hw_asid)] =
            asidInvalid;
    }
    invalidateASID(asid);
}

void
unmapPageTable(asid_t asid, vptr_t vaddr, pte_t* pt)
{
    pde_t *pd, *pdSlot;
    unsigned int pdIndex;

    pd = pageTableMapped (asid, vaddr, pt);

    if (__builtin_expect(!!(pd != ((void *)0)), 1)) {
        pdIndex = vaddr >> (9 + 12);
        pdSlot = pd + pdIndex;

        *pdSlot = pde_pde_invalid_new(0, 0);
        cleanByVA_PoU((word_t)pdSlot, addrFromPPtr(pdSlot));
        flushTable(pd, asid, vaddr, pt);
    }
}

void
copyGlobalMappings(pde_t *newPD)
{
# 1318 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
}

exception_t
handleVMFault(tcb_t *thread, vm_fault_type_t vm_faultType)
{
    switch (vm_faultType) {
    case ARMDataAbort: {
        word_t addr, fault;


        addr = getHDFAR();
        addr = (addressTranslateS1CPR(addr) & ~((1ul << (12))-1ul)) | (addr & ((1ul << (12))-1ul));
        /* MSBs tell us that this was a DataAbort */
        fault = getHSR() & 0x3ffffff;
# 1350 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
        current_fault = seL4_Fault_VMFault_new(addr, fault, false);
        return EXCEPTION_FAULT;
    }

    case ARMPrefetchAbort: {
        word_t pc, fault;

        pc = getRestartPC(thread);


        pc = (addressTranslateS1CPR(pc) & ~((1ul << (12))-1ul)) | (pc & ((1ul << (12))-1ul));
        /* MSBs tell us that this was a PrefetchAbort */
        fault = getHSR() & 0x3ffffff;
# 1382 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
        current_fault = seL4_Fault_VMFault_new(pc, fault, true);
        return EXCEPTION_FAULT;
    }

    default:
        _fail("Invalid VM fault type", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1387, __func__);
    }
}

void
deleteASIDPool(asid_t asid_base, asid_pool_t* pool)
{
    unsigned int offset;

    /* Haskell error: "ASID pool's base must be aligned" */
    if(!((asid_base & ((1ul << (asidLowBits))-1ul)) == 0)) _assert_fail("(asid_base & MASK(asidLowBits)) == 0", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1397, __FUNCTION__);

    if (armKSASIDTable[asid_base >> asidLowBits] == pool) {
        for (offset = 0; offset < (1ul << (asidLowBits)); offset++) {
            if (pool->array[offset]) {
                flushSpace(asid_base + offset);
                invalidateASIDEntry(asid_base + offset);
            }
        }
        armKSASIDTable[asid_base >> asidLowBits] = ((void *)0);
        setVMRoot(ksCurThread);
    }
}

void
deleteASID(asid_t asid, pde_t* pd)
{
    asid_pool_t *poolPtr;

    poolPtr = armKSASIDTable[asid >> asidLowBits];

    if (poolPtr != ((void *)0) && poolPtr->array[asid & ((1ul << (asidLowBits))-1ul)] == pd) {
        flushSpace(asid);
        invalidateASIDEntry(asid);
        poolPtr->array[asid & ((1ul << (asidLowBits))-1ul)] = ((void *)0);
        setVMRoot(ksCurThread);
    }
}
# 1440 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
void
unmapPage(vm_page_size_t page_size, asid_t asid, vptr_t vptr, void *pptr)
{
    findPDForASID_ret_t find_ret;
    paddr_t addr = addrFromPPtr(pptr);

    find_ret = findPDForASID(asid);
    if (__builtin_expect(!!(find_ret.status != EXCEPTION_NONE), 0)) {
        return;
    }

    switch (page_size) {
    case ARMSmallPage: {
        lookupPTSlot_ret_t lu_ret;

        lu_ret = lookupPTSlot(find_ret.pd, vptr);
        if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
            return;
        }

        if (__builtin_expect(!!(pte_ptr_get_pteType(lu_ret.ptSlot) != pte_pte_small), 0)) {
            return;
        }

        if (__builtin_expect(!!(pte_pte_small_ptr_get_contiguous_hint(lu_ret.ptSlot) != 0), 0)) {
            return;
        }

        if (__builtin_expect(!!(pte_pte_small_ptr_get_address(lu_ret.ptSlot) != addr), 0)) {
            return;
        }

        *(lu_ret.ptSlot) = pte_pte_invalid_new();
        cleanByVA_PoU((word_t)lu_ret.ptSlot, addrFromPPtr(lu_ret.ptSlot));

        break;
    }

    case ARMLargePage: {
        lookupPTSlot_ret_t lu_ret;
        word_t i;

        lu_ret = lookupPTSlot(find_ret.pd, vptr);
        if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
            return;
        }
# 1494 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
        if (__builtin_expect(!!(pte_ptr_get_pteType(lu_ret.ptSlot) != pte_pte_small), 0)) {
            return;
        }
        if (__builtin_expect(!!(pte_pte_small_ptr_get_contiguous_hint(lu_ret.ptSlot) != 1), 0)) {
            return;
        }
        if (__builtin_expect(!!(pte_pte_small_ptr_get_address(lu_ret.ptSlot) != addr), 0)) {
            return;
        }


        for (i = 0; i < (1ul << (ARMLargePageBits - ARMSmallPageBits)); i++) {
            lu_ret.ptSlot[i] = pte_pte_invalid_new();
        }
        cleanCacheRange_PoU((word_t)&lu_ret.ptSlot[0],
                            ((word_t)&(lu_ret.ptSlot)[((1ul << (ARMLargePageBits - ARMSmallPageBits)))-1] + ((1ul << (3))-1)),
                            addrFromPPtr(&lu_ret.ptSlot[0]));

        break;
    }

    case ARMSection: {
        pde_t *pd;

        pd = lookupPDSlot(find_ret.pd, vptr);

        if (__builtin_expect(!!(pde_ptr_get_pdeType(pd) != pde_pde_section), 0)) {
            return;
        }



        if (__builtin_expect(!!(pde_pde_section_ptr_get_contiguous_hint(pd) != 0), 0)) {

            return;
        }
        if (__builtin_expect(!!(pde_pde_section_ptr_get_address(pd) != addr), 0)) {
            return;
        }

        *pd = pde_pde_invalid_new(0, 0);
        cleanByVA_PoU((word_t)pd, addrFromPPtr(pd));

        break;
    }

    case ARMSuperSection: {
        pde_t *pd;
        word_t i;

        pd = lookupPDSlot(find_ret.pd, vptr);

        if (__builtin_expect(!!(pde_ptr_get_pdeType(pd) != pde_pde_section), 0)) {
            return;
        }



        if (__builtin_expect(!!(pde_pde_section_ptr_get_contiguous_hint(pd) != 1), 0)) {

            return;
        }
        if (__builtin_expect(!!(pde_pde_section_ptr_get_address(pd) != addr), 0)) {
            return;
        }

        for (i = 0; i < (1ul << (ARMSuperSectionBits - ARMSectionBits)); i++) {
            pd[i] = pde_pde_invalid_new(0, 0);
        }
        cleanCacheRange_PoU((word_t)&pd[0], ((word_t)&(pd)[((1ul << (ARMSuperSectionBits - ARMSectionBits)))-1] + ((1ul << (3))-1)),
                            addrFromPPtr(&pd[0]));

        break;
    }

    default:
        _fail("Invalid ARM page type", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1570, __func__);
        break;
    }

    /* Flush the page now that the mapping has been updated */
    flushPage(page_size, find_ret.pd, asid, vptr);
}

void
flushPage(vm_page_size_t page_size, pde_t* pd, asid_t asid, word_t vptr)
{
    pde_t stored_hw_asid;
    word_t base_addr;
    bool_t root_switched;

    if(!((vptr & ((1ul << (pageBitsForSize(page_size)))-1ul)) == 0)) _assert_fail("(vptr & MASK(pageBitsForSize(page_size))) == 0", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1585, __FUNCTION__);

    /* Switch to the address space to allow a cache clean by VA */
    root_switched = setVMRootForFlush(pd, asid);
    stored_hw_asid = loadHWASID(asid);

    if (pde_pde_invalid_get_stored_asid_valid(stored_hw_asid)) {
        base_addr = vptr & ~((1ul << (12))-1ul);

        /* Do the TLB flush */
        invalidateTranslationSingle(base_addr | pde_pde_invalid_get_stored_hw_asid(stored_hw_asid));

        if (root_switched) {
            setVMRoot(ksCurThread);
        }
    }
}

void
flushTable(pde_t* pd, asid_t asid, word_t vptr, pte_t* pt)
{
    pde_t stored_hw_asid;
    bool_t root_switched;

    if(!((vptr & ((1ul << (9 + ARMSmallPageBits))-1ul)) == 0)) _assert_fail("(vptr & MASK(PT_INDEX_BITS + ARMSmallPageBits)) == 0", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1609, __FUNCTION__);

    /* Switch to the address space to allow a cache clean by VA */
    root_switched = setVMRootForFlush(pd, asid);
    stored_hw_asid = loadHWASID(asid);

    if (pde_pde_invalid_get_stored_asid_valid(stored_hw_asid)) {
        invalidateTranslationASID(pde_pde_invalid_get_stored_hw_asid(stored_hw_asid));
        if (root_switched) {
            setVMRoot(ksCurThread);
        }
    }
}

void
flushSpace(asid_t asid)
{
    pde_t stored_hw_asid;

    stored_hw_asid = loadHWASID(asid);

    /* Clean the entire data cache, to guarantee that any VAs mapped
     * in the deleted space are clean (because we can't clean by VA after
     * deleting the space) */
    cleanCaches_PoU();

    /* If the given ASID doesn't have a hardware ASID
     * assigned, then it can't have any mappings in the TLB */
    if (!pde_pde_invalid_get_stored_asid_valid(stored_hw_asid)) {
        return;
    }

    /* Do the TLB flush */
    invalidateTranslationASID(pde_pde_invalid_get_stored_hw_asid(stored_hw_asid));
}

void
invalidateTLBByASID(asid_t asid)
{
    pde_t stored_hw_asid;

    stored_hw_asid = loadHWASID(asid);

    /* If the given ASID doesn't have a hardware ASID
     * assigned, then it can't have any mappings in the TLB */
    if (!pde_pde_invalid_get_stored_asid_valid(stored_hw_asid)) {
        return;
    }

    /* Do the TLB flush */
    invalidateTranslationASID(pde_pde_invalid_get_stored_hw_asid(stored_hw_asid));
}

static inline bool_t __attribute__((__const__))
checkVPAlignment(vm_page_size_t sz, word_t w)
{
    return (w & ((1ul << (pageBitsForSize(sz)))-1ul)) == 0;
}

struct create_mappings_pte_return {
    exception_t status;
    pte_t pte;
    pte_range_t pte_entries;
};
typedef struct create_mappings_pte_return create_mappings_pte_return_t;

struct create_mappings_pde_return {
    exception_t status;
    pde_t pde;
    pde_range_t pde_entries;
};
typedef struct create_mappings_pde_return create_mappings_pde_return_t;

static create_mappings_pte_return_t
createSafeMappingEntries_PTE
(paddr_t base, word_t vaddr, vm_page_size_t frameSize,
 vm_rights_t vmRights, vm_attributes_t attr, pde_t *pd)
{

    create_mappings_pte_return_t ret;
    lookupPTSlot_ret_t lu_ret;
    word_t i;

    switch (frameSize) {

    case ARMSmallPage:

        ret.pte_entries.base = ((void *)0); /* to avoid uninitialised warning */
        ret.pte_entries.length = 1;

        ret.pte = makeUserPTE(ARMSmallPage, base,
                              vm_attributes_get_armPageCacheable(attr),
                              vm_attributes_get_armExecuteNever(attr),
                              vmRights);

        lu_ret = lookupPTSlot(pd, vaddr);
        if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
            current_syscall_error.type =
                seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource =
                false;
            ret.status = EXCEPTION_SYSCALL_ERROR;
            /* current_lookup_fault will have been set by
             * lookupPTSlot */
            return ret;
        }

        ret.pte_entries.base = lu_ret.ptSlot;




        if (__builtin_expect(!!(pte_ptr_get_pteType(ret.pte_entries.base) == pte_pte_small && pte_pte_small_ptr_get_contiguous_hint(ret.pte_entries.base)), 0)
                                                                                    ) {

            current_syscall_error.type =
                seL4_DeleteFirst;

            ret.status = EXCEPTION_SYSCALL_ERROR;
            return ret;
        }

        ret.status = EXCEPTION_NONE;
        return ret;

    case ARMLargePage:

        ret.pte_entries.base = ((void *)0); /* to avoid uninitialised warning */
        ret.pte_entries.length = (1ul << (ARMLargePageBits - ARMSmallPageBits));

        ret.pte = makeUserPTE(ARMLargePage, base,
                              vm_attributes_get_armPageCacheable(attr),
                              vm_attributes_get_armExecuteNever(attr),
                              vmRights);

        lu_ret = lookupPTSlot(pd, vaddr);
        if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
            current_syscall_error.type =
                seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource =
                false;
            ret.status = EXCEPTION_SYSCALL_ERROR;
            /* current_lookup_fault will have been set by
             * lookupPTSlot */
            return ret;
        }

        ret.pte_entries.base = lu_ret.ptSlot;

        for (i = 0; i < (1ul << (ARMLargePageBits - ARMSmallPageBits)); i++) {
            if (__builtin_expect(!!(pte_get_pteType(ret.pte_entries.base[i]) == pte_pte_small), 0)


                    && !pte_pte_small_get_contiguous_hint(ret.pte_entries.base[i])

               ) {
                current_syscall_error.type =
                    seL4_DeleteFirst;

                ret.status = EXCEPTION_SYSCALL_ERROR;
                return ret;
            }
        }

        ret.status = EXCEPTION_NONE;
        return ret;

    default:
        _fail("Invalid or unexpected ARM page type.", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1777, __func__);

    }
}

static create_mappings_pde_return_t
createSafeMappingEntries_PDE
(paddr_t base, word_t vaddr, vm_page_size_t frameSize,
 vm_rights_t vmRights, vm_attributes_t attr, pde_t *pd)
{

    create_mappings_pde_return_t ret;
    pde_tag_t currentPDEType;
    word_t i;

    switch (frameSize) {

    /* PDE mappings */
    case ARMSection:
        ret.pde_entries.base = lookupPDSlot(pd, vaddr);
        ret.pde_entries.length = 1;

        ret.pde = makeUserPDE(ARMSection, base,
                              vm_attributes_get_armParityEnabled(attr),
                              vm_attributes_get_armPageCacheable(attr),
                              vm_attributes_get_armExecuteNever(attr),
                              0,
                              vmRights);

        currentPDEType =
            pde_ptr_get_pdeType(ret.pde_entries.base);
        if (__builtin_expect(!!(currentPDEType != pde_pde_invalid && (currentPDEType != pde_pde_section || pde_pde_section_ptr_get_contiguous_hint(ret.pde_entries.base) != 0)), 0)




                                                                                          ) {

            current_syscall_error.type =
                seL4_DeleteFirst;
            ret.status = EXCEPTION_SYSCALL_ERROR;

            return ret;
        }

        ret.status = EXCEPTION_NONE;
        return ret;

    case ARMSuperSection:
        ret.pde_entries.base = lookupPDSlot(pd, vaddr);
        ret.pde_entries.length = (1ul << (ARMSuperSectionBits - ARMSectionBits));

        ret.pde = makeUserPDE(ARMSuperSection, base,
                              vm_attributes_get_armParityEnabled(attr),
                              vm_attributes_get_armPageCacheable(attr),
                              vm_attributes_get_armExecuteNever(attr),
                              0,
                              vmRights);

        for (i = 0; i < (1ul << (ARMSuperSectionBits - ARMSectionBits)); i++) {
            currentPDEType =
                pde_get_pdeType(ret.pde_entries.base[i]);
            if (__builtin_expect(!!(currentPDEType != pde_pde_invalid && (currentPDEType != pde_pde_section || pde_pde_section_get_contiguous_hint(ret.pde_entries.base[i]) != 1)), 0)




                                                                                             ) {

                current_syscall_error.type =
                    seL4_DeleteFirst;
                ret.status = EXCEPTION_SYSCALL_ERROR;

                return ret;
            }
        }

        ret.status = EXCEPTION_NONE;
        return ret;

    default:
        _fail("Invalid or unexpected ARM page type.", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1858, __func__);

    }
}

static inline vptr_t
pageBase(vptr_t vaddr, vm_page_size_t size)
{
    return vaddr & ~((1ul << (pageBitsForSize(size)))-1ul);
}

static bool_t __attribute__((__pure__))
pteCheckIfMapped(pte_t *pte)
{
    return pte_ptr_get_pteType(pte) != pte_pte_invalid;
}

static bool_t __attribute__((__pure__))
pdeCheckIfMapped(pde_t *pde)
{
    return pde_ptr_get_pdeType(pde) != pde_pde_invalid;
}

static void
doFlush(int invLabel, vptr_t start, vptr_t end, paddr_t pstart)
{
    /** GHOSTUPD: "((gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
            \<or> \<acute>end - \<acute>start <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state)
        \<and> \<acute>start <= \<acute>end, id)" */
    if (1) {
        /* The hypervisor does not share an AS with userspace so we must flush
         * by kernel MVA instead. ARMv7 caches are PIPT so it makes no difference */
        end = (vptr_t)ptrFromPAddr(pstart) + (end - start);
        start = (vptr_t)ptrFromPAddr(pstart);
    }
    switch (invLabel) {
    case ARMPDClean_Data:
    case ARMPageClean_Data:
        cleanCacheRange_RAM(start, end, pstart);
        break;
    case ARMPDInvalidate_Data:
    case ARMPageInvalidate_Data:
        invalidateCacheRange_RAM(start, end, pstart);
        break;
    case ARMPDCleanInvalidate_Data:
    case ARMPageCleanInvalidate_Data:
        cleanInvalidateCacheRange_RAM(start, end, pstart);
        break;
    case ARMPDUnify_Instruction:
    case ARMPageUnify_Instruction:
        /* First clean data lines to point of unification
           (L2 cache)... */
        cleanCacheRange_PoU(start, end, pstart);
        /* Ensure it's been written. */
        dsb();
        /* ...then invalidate the corresponding instruction lines
           to point of unification... */
        invalidateCacheRange_I(start, end, pstart);
        /* ...then invalidate branch predictors. */
        branchFlushRange(start, end, pstart);
        /* Ensure new instructions come from fresh cache lines. */
        isb();
        break;
    default:
        _fail("Invalid operation, shouldn't get here.\n", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 1922, __func__);
    }
}

/* ================= INVOCATION HANDLING STARTS HERE ================== */

static exception_t
performPDFlush(int invLabel, pde_t *pd, asid_t asid, vptr_t start,
               vptr_t end, paddr_t pstart)
{
    bool_t root_switched;

    /* Flush if given a non zero range */
    if (start < end) {
        root_switched = setVMRootForFlush(pd, asid);

        doFlush(invLabel, start, end, pstart);

        if (root_switched) {
            setVMRoot(ksCurThread);
        }
    }

    return EXCEPTION_NONE;
}

static exception_t
performPageTableInvocationMap(cap_t cap, cte_t *ctSlot,
                              pde_t pde, pde_t *pdSlot)
{
    ctSlot->cap = cap;
    *pdSlot = pde;
    cleanByVA_PoU((word_t)pdSlot, addrFromPPtr(pdSlot));

    return EXCEPTION_NONE;
}

static exception_t
performPageTableInvocationUnmap(cap_t cap, cte_t *ctSlot)
{
    if (cap_page_table_cap_get_capPTIsMapped(cap)) {
        pte_t *pt = ((pte_t *)cap_page_table_cap_get_capPTBasePtr(cap));
        unmapPageTable(
            cap_page_table_cap_get_capPTMappedASID(cap),
            cap_page_table_cap_get_capPTMappedAddress(cap),
            pt);
        clearMemory((void *)pt, cap_get_capSizeBits(cap));
    }
    cap_page_table_cap_ptr_set_capPTIsMapped(&(ctSlot->cap), 0);

    return EXCEPTION_NONE;
}

static exception_t
performPageInvocationMapPTE(asid_t asid, cap_t cap, cte_t *ctSlot, pte_t pte,
                            pte_range_t pte_entries)
{
    word_t i, j __attribute__((unused));
    bool_t tlbflush_required;

    ctSlot->cap = cap;

    /* we only need to check the first entries because of how createSafeMappingEntries
     * works to preserve the consistency of tables */
    tlbflush_required = pteCheckIfMapped(pte_entries.base);

    j = pte_entries.length;
    /** GHOSTUPD: "(\<acute>j <= 16, id)" */


    word_t base_address = pte_pte_small_get_address(pte);

    for (i = 0; i < pte_entries.length; i++) {

        pte = pte_pte_small_set_address(pte, base_address + i * (1ul << (pageBitsForSize(ARMSmallPage))));

        pte_entries.base[i] = pte;
    }
    cleanCacheRange_PoU((word_t)pte_entries.base,
                        ((word_t)&(pte_entries.base)[(pte_entries.length)-1] + ((1ul << (3))-1)),
                        addrFromPPtr(pte_entries.base));
    if (__builtin_expect(!!(tlbflush_required), 0)) {
        invalidateTLBByASID(asid);
    }

    return EXCEPTION_NONE;
}

static exception_t
performPageInvocationMapPDE(asid_t asid, cap_t cap, cte_t *ctSlot, pde_t pde,
                            pde_range_t pde_entries)
{
    word_t i, j __attribute__((unused));
    bool_t tlbflush_required;

    ctSlot->cap = cap;

    /* we only need to check the first entries because of how createSafeMappingEntries
     * works to preserve the consistency of tables */
    tlbflush_required = pdeCheckIfMapped(pde_entries.base);

    j = pde_entries.length;
    /** GHOSTUPD: "(\<acute>j <= 16, id)" */


    word_t base_address = pde_pde_section_get_address(pde);

    for (i = 0; i < pde_entries.length; i++) {

        pde = pde_pde_section_set_address(pde, base_address + i * (1ul << (pageBitsForSize(ARMSection))));

        pde_entries.base[i] = pde;
    }
    cleanCacheRange_PoU((word_t)pde_entries.base,
                        ((word_t)&(pde_entries.base)[(pde_entries.length)-1] + ((1ul << (3))-1)),
                        addrFromPPtr(pde_entries.base));
    if (__builtin_expect(!!(tlbflush_required), 0)) {
        invalidateTLBByASID(asid);
    }

    return EXCEPTION_NONE;
}

static exception_t
performPageInvocationRemapPTE(asid_t asid, pte_t pte, pte_range_t pte_entries)
{
    word_t i, j __attribute__((unused));
    bool_t tlbflush_required;

    /* we only need to check the first entries because of how createSafeMappingEntries
     * works to preserve the consistency of tables */
    tlbflush_required = pteCheckIfMapped(pte_entries.base);

    j = pte_entries.length;
    /** GHOSTUPD: "(\<acute>j <= 16, id)" */


    word_t base_address = pte_pte_small_get_address(pte);

    for (i = 0; i < pte_entries.length; i++) {

        pte = pte_pte_small_set_address(pte, base_address + i * (1ul << (pageBitsForSize(ARMSmallPage))));

        pte_entries.base[i] = pte;
    }
    cleanCacheRange_PoU((word_t)pte_entries.base,
                        ((word_t)&(pte_entries.base)[(pte_entries.length)-1] + ((1ul << (3))-1)),
                        addrFromPPtr(pte_entries.base));
    if (__builtin_expect(!!(tlbflush_required), 0)) {
        invalidateTLBByASID(asid);
    }

    return EXCEPTION_NONE;
}

static exception_t
performPageInvocationRemapPDE(asid_t asid, pde_t pde, pde_range_t pde_entries)
{
    word_t i, j __attribute__((unused));
    bool_t tlbflush_required;

    /* we only need to check the first entries because of how createSafeMappingEntries
     * works to preserve the consistency of tables */
    tlbflush_required = pdeCheckIfMapped(pde_entries.base);

    j = pde_entries.length;
    /** GHOSTUPD: "(\<acute>j <= 16, id)" */


    word_t base_address = pde_pde_section_get_address(pde);

    for (i = 0; i < pde_entries.length; i++) {

        pde = pde_pde_section_set_address(pde, base_address + i * (1ul << (pageBitsForSize(ARMSection))));

        pde_entries.base[i] = pde;
    }
    cleanCacheRange_PoU((word_t)pde_entries.base,
                        ((word_t)&(pde_entries.base)[(pde_entries.length)-1] + ((1ul << (3))-1)),
                        addrFromPPtr(pde_entries.base));
    if (__builtin_expect(!!(tlbflush_required), 0)) {
        invalidateTLBByASID(asid);
    }

    return EXCEPTION_NONE;
}

static exception_t
performPageInvocationUnmap(cap_t cap, cte_t *ctSlot)
{
    if (generic_frame_cap_get_capFIsMapped(cap)) {
        unmapPage(generic_frame_cap_get_capFSize(cap),
                  generic_frame_cap_get_capFMappedASID(cap),
                  generic_frame_cap_get_capFMappedAddress(cap),
                  (void *)generic_frame_cap_get_capFBasePtr(cap));
    }

    generic_frame_cap_ptr_set_capFMappedAddress(&ctSlot->cap, asidInvalid, 0);

    return EXCEPTION_NONE;
}

static exception_t
performPageFlush(int invLabel, pde_t *pd, asid_t asid, vptr_t start,
                 vptr_t end, paddr_t pstart)
{
    bool_t root_switched;

    /* now we can flush. But only if we were given a non zero range */
    if (start < end) {
        root_switched = setVMRootForFlush(pd, asid);

        doFlush(invLabel, start, end, pstart);

        if (root_switched) {
            setVMRoot(ksCurThread);
        }
    }

    return EXCEPTION_NONE;
}

static exception_t
performPageGetAddress(void *vbase_ptr)
{
    paddr_t capFBasePtr;

    /* Get the physical address of this frame. */
    capFBasePtr = addrFromPPtr(vbase_ptr);

    /* return it in the first message register */
    setRegister(ksCurThread, msgRegisters[0], capFBasePtr);
    setRegister(ksCurThread, msgInfoRegister,
                wordFromMessageInfo(seL4_MessageInfo_new(0, 0, 0, 1)));

    return EXCEPTION_NONE;
}

static exception_t
performASIDPoolInvocation(asid_t asid, asid_pool_t *poolPtr,
                          cte_t *pdCapSlot)
{
    cap_page_directory_cap_ptr_set_capPDMappedASID(&pdCapSlot->cap, asid);
    cap_page_directory_cap_ptr_set_capPDIsMapped(&pdCapSlot->cap, 1);
    poolPtr->array[asid & ((1ul << (asidLowBits))-1ul)] =
        ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(pdCapSlot->cap)));

    return EXCEPTION_NONE;
}

static exception_t
performASIDControlInvocation(void *frame, cte_t *slot,
                             cte_t *parent, asid_t asid_base)
{

    /** AUXUPD: "(True, typ_region_bytes (ptr_val \<acute>frame) 12)" */
    /** GHOSTUPD: "(True, gs_clear_region (ptr_val \<acute>frame) 12)" */
    cap_untyped_cap_ptr_set_capFreeIndex(&(parent->cap),
                                         ((1ul << ((cap_untyped_cap_get_capBlockSize(parent->cap)) - 4))));

    memzero(frame, 1 << ARMSmallPageBits);
    /** AUXUPD: "(True, ptr_retyps 1 (Ptr (ptr_val \<acute>frame) :: asid_pool_C ptr))" */

    cteInsert(cap_asid_pool_cap_new(asid_base, ((word_t)(frame))),
              parent, slot);;
    /* Haskell error: "ASID pool's base must be aligned" */
    if(!((asid_base & ((1ul << (asidLowBits))-1ul)) == 0)) _assert_fail("(asid_base & MASK(asidLowBits)) == 0", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 2188, __FUNCTION__);
    armKSASIDTable[asid_base >> asidLowBits] = (asid_pool_t *)frame;

    return EXCEPTION_NONE;
}

static exception_t
decodeARMPageDirectoryInvocation(word_t invLabel, word_t length,
                                 cptr_t cptr, cte_t *cte, cap_t cap,
                                 extra_caps_t excaps, word_t *buffer)
{
    switch (invLabel) {
    case ARMPDClean_Data:
    case ARMPDInvalidate_Data:
    case ARMPDCleanInvalidate_Data:
    case ARMPDUnify_Instruction: {
        vptr_t start, end;
        paddr_t pstart;
        findPDForASID_ret_t find_ret;
        asid_t asid;
        pde_t *pd;
        resolve_ret_t resolve_ret;

        if (length < 2) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2212, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("PD Flush: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }

        start = getSyscallArg(0, buffer);
        end = getSyscallArg(1, buffer);

        /* Check sanity of arguments */
        if (end <= start) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2222, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("PD Flush: Invalid range"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidArgument;
            current_syscall_error.invalidArgumentNumber = 1;
            return EXCEPTION_SYSCALL_ERROR;
        }

        /* Don't let applications flush kernel regions. */
        if (start >= 0xe0000000 || end > 0xe0000000) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2230, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("PD Flush: Overlaps kernel region."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }

        if (__builtin_expect(!!(cap_get_capType(cap) != cap_page_directory_cap || !cap_page_directory_cap_get_capPDIsMapped(cap)), 0)
                                                                    ) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2237, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("PD Flush: Invalid cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }


        /* Make sure that the supplied pd is ok */
        pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(cap)));
        asid = cap_page_directory_cap_get_capPDMappedASID(cap);

        find_ret = findPDForASID(asid);
        if (__builtin_expect(!!(find_ret.status != EXCEPTION_NONE), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2250, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("PD Flush: No PD for ASID"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = false;
            return EXCEPTION_SYSCALL_ERROR;
        }

        if (__builtin_expect(!!(find_ret.pd != pd), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2257, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("PD Flush: Invalid PD Cap"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        /* Look up the frame containing 'start'. */
        resolve_ret = resolveVAddr(pd, start);

        /* Check that there's actually something there. */
        if (!resolve_ret.valid) {
            /* Fail silently, as there can't be any stale cached data (for the
             * given address space), and getting a syscall error because the
             * relevant page is non-resident would be 'astonishing'. */
            setThreadState(ksCurThread, ThreadState_Restart);
            return EXCEPTION_NONE;
        }

        /* Refuse to cross a page boundary. */
        if (pageBase(start, resolve_ret.frameSize) !=
                pageBase(end - 1, resolve_ret.frameSize)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2278, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("PD Flush: Range is across page boundary."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_RangeError;
            current_syscall_error.rangeErrorMin = start;
            current_syscall_error.rangeErrorMax =
                pageBase(start, resolve_ret.frameSize) +
                ((1ul << (pageBitsForSize(resolve_ret.frameSize)))-1ul);
            return EXCEPTION_SYSCALL_ERROR;
        }


        /* Calculate the physical start address. */
        pstart = resolve_ret.frameBase
                 + (start & ((1ul << (pageBitsForSize(resolve_ret.frameSize)))-1ul));


        setThreadState(ksCurThread, ThreadState_Restart);
        return performPDFlush(invLabel, pd, asid, start, end - 1, pstart);
    }

    default:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2298, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("PD: Invalid invocation number"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

}

static exception_t
decodeARMPageTableInvocation(word_t invLabel, word_t length,
                             cte_t *cte, cap_t cap, extra_caps_t excaps,
                             word_t *buffer)
{
    word_t vaddr, pdIndex;




    cap_t pdCap;
    pde_t *pd, *pdSlot;
    pde_t pde;
    asid_t asid;
    paddr_t paddr;

    if (invLabel == ARMPageTableUnmap) {
        if (__builtin_expect(!!(! isFinalCapability(cte)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2323, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageTableUnmap: Cannot unmap if more than one cap exists."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_RevokeFirst;
            return EXCEPTION_SYSCALL_ERROR;
        }
        setThreadState(ksCurThread, ThreadState_Restart);
        return performPageTableInvocationUnmap (cap, cte);
    }

    if (__builtin_expect(!!(invLabel != ARMPageTableMap), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2332, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageTable: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (__builtin_expect(!!(length < 2 || excaps.excaprefs[0] == ((void *)0)), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2338, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageTableMap: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (__builtin_expect(!!(cap_page_table_cap_get_capPTIsMapped(cap)), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2344, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageTableMap: Page table is already mapped to page directory."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type =
            seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;

        return EXCEPTION_SYSCALL_ERROR;
    }

    vaddr = getSyscallArg(0, buffer);



    pdCap = excaps.excaprefs[0]->cap;

    if (__builtin_expect(!!(cap_get_capType(pdCap) != cap_page_directory_cap || !cap_page_directory_cap_get_capPDIsMapped(pdCap)), 0)
                                                                  ) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2360, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageTableMap: Invalid PD cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 1;

        return EXCEPTION_SYSCALL_ERROR;
    }

    pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(pdCap)));
    asid = cap_page_directory_cap_get_capPDMappedASID(pdCap);

    if (__builtin_expect(!!(vaddr >= 0xe0000000), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2371, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageTableMap: Virtual address cannot be in kernel window. vaddr: 0x%08lx, kernelBase: 0x%08x", vaddr, 0xe0000000); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 0;

        return EXCEPTION_SYSCALL_ERROR;
    }

    {
        findPDForASID_ret_t find_ret;

        find_ret = findPDForASID(asid);
        if (__builtin_expect(!!(find_ret.status != EXCEPTION_NONE), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2383, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageTableMap: ASID lookup failed."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = false;

            return EXCEPTION_SYSCALL_ERROR;
        }

        if (__builtin_expect(!!(find_ret.pd != pd), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2391, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageTableMap: ASID lookup failed."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 1;

            return EXCEPTION_SYSCALL_ERROR;
        }
    }

    pdIndex = vaddr >> (12 + 9);
    pdSlot = &pd[pdIndex];
    if (__builtin_expect(!!(pde_ptr_get_pdeType(pdSlot) != pde_pde_invalid), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2403, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageTableMap: Page directory already has entry for supplied address."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_DeleteFirst;

        return EXCEPTION_SYSCALL_ERROR;
    }

    paddr = addrFromPPtr(
                ((pte_t *)cap_page_table_cap_get_capPTBasePtr(cap)));







    pde = pde_pde_coarse_new(paddr);


    cap = cap_page_table_cap_set_capPTIsMapped(cap, 1);
    cap = cap_page_table_cap_set_capPTMappedASID(cap, asid);
    cap = cap_page_table_cap_set_capPTMappedAddress(cap, vaddr);

    setThreadState(ksCurThread, ThreadState_Restart);
    return performPageTableInvocationMap(cap, cte, pde, pdSlot);
}

static exception_t
decodeARMFrameInvocation(word_t invLabel, word_t length,
                         cte_t *cte, cap_t cap, extra_caps_t excaps,
                         word_t *buffer)
{
    switch (invLabel) {
    case ARMPageMap: {
        word_t vaddr, vtop, w_rightsMask;
        paddr_t capFBasePtr;
        cap_t pdCap;
        pde_t *pd;
        asid_t asid;
        vm_rights_t capVMRights, vmRights;
        vm_page_size_t frameSize;
        vm_attributes_t attr;

        if (__builtin_expect(!!(length < 3 || excaps.excaprefs[0] == ((void *)0)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2446, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageMap: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_TruncatedMessage;

            return EXCEPTION_SYSCALL_ERROR;
        }

        vaddr = getSyscallArg(0, buffer);
        w_rightsMask = getSyscallArg(1, buffer);
        attr = vmAttributesFromWord(getSyscallArg(2, buffer));
        pdCap = excaps.excaprefs[0]->cap;

        frameSize = generic_frame_cap_get_capFSize(cap);
        capVMRights = generic_frame_cap_get_capFVMRights(cap);

        if (__builtin_expect(!!(generic_frame_cap_get_capFIsMapped(cap)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2462, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageMap: Cap already has mapping."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;

            return EXCEPTION_SYSCALL_ERROR;
        }

        if (__builtin_expect(!!(cap_get_capType(pdCap) != cap_page_directory_cap || !cap_page_directory_cap_get_capPDIsMapped(pdCap)), 0)
                                                                      ) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2472, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageMap: Bad PageDirectory cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 1;

            return EXCEPTION_SYSCALL_ERROR;
        }
        pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr( pdCap)))
                                ;
        asid = cap_page_directory_cap_get_capPDMappedASID(pdCap);

        {
            findPDForASID_ret_t find_ret;

            find_ret = findPDForASID(asid);
            if (__builtin_expect(!!(find_ret.status != EXCEPTION_NONE), 0)) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2488, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageMap: No PD for ASID"); kprintf(">>" "\033[0m" "\n"); } while (0);
                current_syscall_error.type =
                    seL4_FailedLookup;
                current_syscall_error.failedLookupWasSource =
                    false;

                return EXCEPTION_SYSCALL_ERROR;
            }

            if (__builtin_expect(!!(find_ret.pd != pd), 0)) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2498, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageMap: ASID lookup failed."); kprintf(">>" "\033[0m" "\n"); } while (0);
                current_syscall_error.type =
                    seL4_InvalidCapability;
                current_syscall_error.invalidCapNumber = 1;

                return EXCEPTION_SYSCALL_ERROR;
            }
        }

        vtop = vaddr + (1ul << (pageBitsForSize(frameSize))) - 1;

        if (__builtin_expect(!!(vtop >= 0xe0000000), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2510, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageMap: Cannot map frame over kernel window. vaddr: 0x%08lx, kernelBase: 0x%08x", vaddr, 0xe0000000); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_InvalidArgument;
            current_syscall_error.invalidArgumentNumber = 0;

            return EXCEPTION_SYSCALL_ERROR;
        }

        vmRights =
            maskVMRights(capVMRights, rightsFromWord(w_rightsMask));

        if (__builtin_expect(!!(!checkVPAlignment(frameSize, vaddr)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2522, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageMap: Virtual address has incorrect alignment."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_AlignmentError;

            return EXCEPTION_SYSCALL_ERROR;
        }

        capFBasePtr = addrFromPPtr((void *)
                                   generic_frame_cap_get_capFBasePtr(cap));

        cap = generic_frame_cap_set_capFMappedAddress(cap, asid,
                                                      vaddr);
        if (frameSize == ARMSmallPage || frameSize == ARMLargePage) {
            create_mappings_pte_return_t map_ret;
            map_ret = createSafeMappingEntries_PTE(capFBasePtr, vaddr,
                                                   frameSize, vmRights,
                                                   attr, pd);
            if (__builtin_expect(!!(map_ret.status != EXCEPTION_NONE), 0)) {

                if (current_syscall_error.type == seL4_DeleteFirst) {
                    do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2542, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageMap: Page table entry was not free."); kprintf(">>" "\033[0m" "\n"); } while (0);
                }

                return map_ret.status;
            }

            setThreadState(ksCurThread, ThreadState_Restart);
            return performPageInvocationMapPTE(asid, cap, cte,
                                               map_ret.pte,
                                               map_ret.pte_entries);
        } else {
            create_mappings_pde_return_t map_ret;
            map_ret = createSafeMappingEntries_PDE(capFBasePtr, vaddr,
                                                   frameSize, vmRights,
                                                   attr, pd);
            if (__builtin_expect(!!(map_ret.status != EXCEPTION_NONE), 0)) {

                if (current_syscall_error.type == seL4_DeleteFirst) {
                    do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2560, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageMap: Page directory entry was not free."); kprintf(">>" "\033[0m" "\n"); } while (0);
                }

                return map_ret.status;
            }

            setThreadState(ksCurThread, ThreadState_Restart);
            return performPageInvocationMapPDE(asid, cap, cte,
                                               map_ret.pde,
                                               map_ret.pde_entries);
        }
    }

    case ARMPageRemap: {
        word_t vaddr, w_rightsMask;
        paddr_t capFBasePtr;
        cap_t pdCap;
        pde_t *pd;
        asid_t mappedASID;
        vm_rights_t capVMRights, vmRights;
        vm_page_size_t frameSize;
        vm_attributes_t attr;
# 2592 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
        if (__builtin_expect(!!(length < 2 || excaps.excaprefs[0] == ((void *)0)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2593, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageRemap: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_TruncatedMessage;

            return EXCEPTION_SYSCALL_ERROR;
        }

        w_rightsMask = getSyscallArg(0, buffer);
        attr = vmAttributesFromWord(getSyscallArg(1, buffer));
        pdCap = excaps.excaprefs[0]->cap;

        if (__builtin_expect(!!(cap_get_capType(pdCap) != cap_page_directory_cap || !cap_page_directory_cap_get_capPDIsMapped(pdCap)), 0)
                                                                      ) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2606, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageRemap: Invalid pd cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 1;

            return EXCEPTION_SYSCALL_ERROR;
        }

        if (__builtin_expect(!!(!generic_frame_cap_get_capFIsMapped(cap)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2615, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageRemap: Cap is not mapped"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;

            return EXCEPTION_SYSCALL_ERROR;
        }

        pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(pdCap)));
        vaddr = generic_frame_cap_get_capFMappedAddress(cap);

        {
            findPDForASID_ret_t find_ret;

            mappedASID = generic_frame_cap_get_capFMappedASID(cap);

            find_ret = findPDForASID(mappedASID);
            if (__builtin_expect(!!(find_ret.status != EXCEPTION_NONE), 0)) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2633, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageRemap: No PD for ASID"); kprintf(">>" "\033[0m" "\n"); } while (0);
                current_syscall_error.type =
                    seL4_FailedLookup;
                current_syscall_error.failedLookupWasSource = false;

                return EXCEPTION_SYSCALL_ERROR;
            }

            if (__builtin_expect(!!(find_ret.pd != pd || cap_page_directory_cap_get_capPDMappedASID(pdCap) != mappedASID), 0)

                                    ) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2644, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageRemap: Failed ASID lookup."); kprintf(">>" "\033[0m" "\n"); } while (0);
                current_syscall_error.type =
                    seL4_InvalidCapability;
                current_syscall_error.invalidCapNumber = 1;

                return EXCEPTION_SYSCALL_ERROR;
            }
        }

        frameSize = generic_frame_cap_get_capFSize(cap);
        capVMRights = generic_frame_cap_get_capFVMRights(cap);
        vmRights =
            maskVMRights(capVMRights, rightsFromWord(w_rightsMask));

        if (__builtin_expect(!!(!checkVPAlignment(frameSize, vaddr)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2659, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageRemap: Virtual address has incorrect alignment."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_AlignmentError;

            return EXCEPTION_SYSCALL_ERROR;
        }

        capFBasePtr = addrFromPPtr((void *)
                                   generic_frame_cap_get_capFBasePtr(cap));

        if (frameSize == ARMSmallPage || frameSize == ARMLargePage) {
            create_mappings_pte_return_t map_ret;
            map_ret = createSafeMappingEntries_PTE(capFBasePtr, vaddr,
                                                   frameSize, vmRights,
                                                   attr, pd);
            if (map_ret.status != EXCEPTION_NONE) {

                if (current_syscall_error.type == seL4_FailedLookup) {
                    do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2677, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageRemap: Page directory entry did not contain a page table."); kprintf(">>" "\033[0m" "\n"); } while (0);
                } else if (current_syscall_error.type == seL4_DeleteFirst) {
                    do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2679, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageRemap: Page table entry was not free."); kprintf(">>" "\033[0m" "\n"); } while (0);
                }

                return map_ret.status;
            }

            setThreadState(ksCurThread, ThreadState_Restart);
            return performPageInvocationRemapPTE(mappedASID, map_ret.pte,
                                                 map_ret.pte_entries);
        } else {
            create_mappings_pde_return_t map_ret;
            map_ret = createSafeMappingEntries_PDE(capFBasePtr, vaddr,
                                                   frameSize, vmRights,
                                                   attr, pd);
            if (map_ret.status != EXCEPTION_NONE) {

                if (current_syscall_error.type == seL4_DeleteFirst) {
                    do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2696, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPageRemap: Page directory entry was not free."); kprintf(">>" "\033[0m" "\n"); } while (0);
                }

                return map_ret.status;
            }

            setThreadState(ksCurThread, ThreadState_Restart);
            return performPageInvocationRemapPDE(mappedASID, map_ret.pde,
                                                 map_ret.pde_entries);
        }
    }

    case ARMPageUnmap: {






        {
            setThreadState(ksCurThread, ThreadState_Restart);
            return performPageInvocationUnmap(cap, cte);
        }
    }







    case ARMPageClean_Data:
    case ARMPageInvalidate_Data:
    case ARMPageCleanInvalidate_Data:
    case ARMPageUnify_Instruction: {
        asid_t asid;
        vptr_t vaddr;
        findPDForASID_ret_t pd;
        vptr_t start, end;
        paddr_t pstart;
        word_t page_size;
        word_t page_base;

        if (length < 2) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2740, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Page Flush: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }

        asid = generic_frame_cap_get_capFMappedASID(cap);

        /* Must use kernel vaddr in hyp mode. */
        vaddr = generic_frame_cap_get_capFBasePtr(cap);




        if (__builtin_expect(!!(!generic_frame_cap_get_capFIsMapped(cap)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2754, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Page Flush: Frame is not mapped."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }

        pd = findPDForASID(asid);
        if (__builtin_expect(!!(pd.status != EXCEPTION_NONE), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2761, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Page Flush: No PD for ASID"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type =
                seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = false;
            return EXCEPTION_SYSCALL_ERROR;
        }

        start = getSyscallArg(0, buffer);
        end = getSyscallArg(1, buffer);

        /* check that the range is sane */
        if (end <= start) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2773, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("PageFlush: Invalid range"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidArgument;
            current_syscall_error.invalidArgumentNumber = 1;
            return EXCEPTION_SYSCALL_ERROR;
        }


        /* start and end are currently relative inside this page */
        page_size = 1 << pageBitsForSize(generic_frame_cap_get_capFSize(cap));
        page_base = addrFromPPtr((void*)generic_frame_cap_get_capFBasePtr(cap));

        if (start >= page_size || end > page_size) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2785, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Page Flush: Requested range not inside page"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidArgument;
            current_syscall_error.invalidArgumentNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        /* turn start and end into absolute addresses */
        pstart = page_base + start;
        start += vaddr;
        end += vaddr;

        setThreadState(ksCurThread, ThreadState_Restart);
        return performPageFlush(invLabel, pd.pd, asid, start, end - 1, pstart);
    }

    case ARMPageGetAddress: {


        /* Check that there are enough message registers */
        if(!(n_msgRegisters >= 1)) _assert_fail("n_msgRegisters >= 1", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 2804, __FUNCTION__);

        setThreadState(ksCurThread, ThreadState_Restart);
        return performPageGetAddress((void*)generic_frame_cap_get_capFBasePtr(cap));
    }

    default:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2811, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ARMPage: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;

        return EXCEPTION_SYSCALL_ERROR;
    }
}

exception_t
decodeARMMMUInvocation(word_t invLabel, word_t length, cptr_t cptr,
                       cte_t *cte, cap_t cap, extra_caps_t excaps,
                       word_t *buffer)
{
    switch (cap_get_capType(cap)) {
    case cap_page_directory_cap:
        return decodeARMPageDirectoryInvocation(invLabel, length, cptr, cte,
                                                cap, excaps, buffer);

    case cap_page_table_cap:
        return decodeARMPageTableInvocation (invLabel, length, cte,
                                             cap, excaps, buffer);

    case cap_small_frame_cap:
    case cap_frame_cap:
        return decodeARMFrameInvocation (invLabel, length, cte,
                                         cap, excaps, buffer);

    case cap_asid_control_cap: {
        word_t i;
        asid_t asid_base;
        word_t index, depth;
        cap_t untyped, root;
        cte_t *parentSlot, *destSlot;
        lookupSlot_ret_t lu_ret;
        void *frame;
        exception_t status;

        if (__builtin_expect(!!(invLabel != ARMASIDControlMakePool), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2848, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDControl: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;

            return EXCEPTION_SYSCALL_ERROR;
        }

        if (__builtin_expect(!!(length < 2 || excaps.excaprefs[0] == ((void *)0) || excaps.excaprefs[1] == ((void *)0)), 0)
                                                    ) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2856, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDControlMakePool: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_TruncatedMessage;

            return EXCEPTION_SYSCALL_ERROR;
        }

        index = getSyscallArg(0, buffer);
        depth = getSyscallArg(1, buffer);
        parentSlot = excaps.excaprefs[0];
        untyped = parentSlot->cap;
        root = excaps.excaprefs[1]->cap;

        /* Find first free pool */
        for (i = 0; i < (1ul << (asidHighBits)) && armKSASIDTable[i]; i++);

        if (__builtin_expect(!!(i == (1ul << (asidHighBits))), 0)) { /* If no unallocated pool is found */
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2872, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDControlMakePool: No free pools found."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_DeleteFirst;

            return EXCEPTION_SYSCALL_ERROR;
        }

        asid_base = i << asidLowBits;

        if (__builtin_expect(!!(cap_get_capType(untyped) != cap_untyped_cap || cap_untyped_cap_get_capBlockSize(untyped) != 12), 0)

                                        || cap_untyped_cap_get_capIsDevice(untyped)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2883, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDControlMakePool: Invalid untyped cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 1;

            return EXCEPTION_SYSCALL_ERROR;
        }

        status = ensureNoChildren(parentSlot);
        if (__builtin_expect(!!(status != EXCEPTION_NONE), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2892, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDControlMakePool: Untyped has children. Revoke first."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return status;
        }

        frame = ((word_t *)(cap_untyped_cap_get_capPtr(untyped)));

        lu_ret = lookupTargetSlot(root, index, depth);
        if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2900, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDControlMakePool: Failed to lookup destination slot."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return lu_ret.status;
        }
        destSlot = lu_ret.slot;

        status = ensureEmptySlot(destSlot);
        if (__builtin_expect(!!(status != EXCEPTION_NONE), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2907, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDControlMakePool: Destination slot not empty."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return status;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return performASIDControlInvocation(frame, destSlot,
                                            parentSlot, asid_base);
    }

    case cap_asid_pool_cap: {
        cap_t pdCap;
        cte_t *pdCapSlot;
        asid_pool_t *pool;
        word_t i;
        asid_t asid;

        if (__builtin_expect(!!(invLabel != ARMASIDPoolAssign), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2924, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDPool: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;

            return EXCEPTION_SYSCALL_ERROR;
        }

        if (__builtin_expect(!!(excaps.excaprefs[0] == ((void *)0)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2931, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDPoolAssign: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_TruncatedMessage;

            return EXCEPTION_SYSCALL_ERROR;
        }

        pdCapSlot = excaps.excaprefs[0];
        pdCap = pdCapSlot->cap;

        if (__builtin_expect(!!(cap_get_capType(pdCap) != cap_page_directory_cap || cap_page_directory_cap_get_capPDIsMapped(pdCap)), 0)

                                                                    ) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2943, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDPoolAssign: Invalid page directory cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 1;

            return EXCEPTION_SYSCALL_ERROR;
        }

        pool = armKSASIDTable[cap_asid_pool_cap_get_capASIDBase(cap) >>
                              asidLowBits];
        if (__builtin_expect(!!(!pool), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2953, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDPoolAssign: Failed to lookup pool."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = false;
            current_lookup_fault = lookup_fault_invalid_root_new();

            return EXCEPTION_SYSCALL_ERROR;
        }

        if (__builtin_expect(!!(pool != ((asid_pool_t *)cap_asid_pool_cap_get_capASIDPool(cap))), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2962, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDPoolAssign: Failed to lookup pool."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;

            return EXCEPTION_SYSCALL_ERROR;
        }

        /* Find first free ASID */
        asid = cap_asid_pool_cap_get_capASIDBase(cap);
        for (i = 0; i < (1 << asidLowBits) && (asid + i == 0 || pool->array[i]); i++);

        if (__builtin_expect(!!(i == 1 << asidLowBits), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 2974, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("ASIDPoolAssign: No free ASID."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_DeleteFirst;

            return EXCEPTION_SYSCALL_ERROR;
        }

        asid += i;

        setThreadState(ksCurThread, ThreadState_Restart);
        return performASIDPoolInvocation(asid, pool, pdCapSlot);
    }

    default:
        _fail("Invalid ARM arch cap type", "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c", 2987, __func__);
    }
}
# 3057 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
void kernelPrefetchAbort(word_t pc) __attribute__((externally_visible));
void kernelDataAbort(word_t pc) __attribute__((externally_visible));



void kernelUndefinedInstruction(word_t pc) __attribute__((externally_visible));

void
kernelPrefetchAbort(word_t pc)
{
    word_t __attribute__((unused)) sr = getHSR();

    kprintf("\n\nKERNEL PREFETCH ABORT!\n");
    kprintf("Faulting instruction: 0x%x\n", (unsigned int)pc);
    kprintf("HSR: 0x%x\n", (unsigned int)sr);

    halt();
}

void
kernelDataAbort(word_t pc)
{
    word_t __attribute__((unused)) far = getHDFAR();
    word_t __attribute__((unused)) sr = getHSR();

    kprintf("\n\nKERNEL DATA ABORT!\n");
    kprintf("Faulting instruction: 0x%x\n", (unsigned int)pc);
    kprintf("HDFAR: 0x%x HSR: 0x%x\n", (unsigned int)far, (unsigned int)sr);

    halt();
}

void
kernelUndefinedInstruction(word_t pc)
{
    word_t __attribute__((unused)) sr = getHSR();

    kprintf("\n\nKERNEL UNDEFINED INSTRUCTION!\n");
    kprintf("Faulting instruction: 0x%x\n", (unsigned int)pc);
    kprintf("HSR: 0x%x\n", (unsigned int)sr);

    halt();
}
# 3132 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
typedef struct readWordFromVSpace_ret {
    exception_t status;
    word_t value;
} readWordFromVSpace_ret_t;

static readWordFromVSpace_ret_t
readWordFromVSpace(pde_t *pd, word_t vaddr)
{
    readWordFromVSpace_ret_t ret;
    lookupPTSlot_ret_t ptSlot;
    pde_t *pdSlot;
    paddr_t paddr;
    word_t offset;
    pptr_t kernel_vaddr;
    word_t *value;

    pdSlot = lookupPDSlot(pd, vaddr);
    if (pde_ptr_get_pdeType(pdSlot) == pde_pde_section) {
        paddr = pde_pde_section_ptr_get_address(pdSlot);
        offset = vaddr & ((1ul << (ARMSectionBits))-1ul);
    } else {
        ptSlot = lookupPTSlot(pd, vaddr);

        if (ptSlot.status == EXCEPTION_NONE && pte_ptr_get_pteType(ptSlot.ptSlot) == pte_pte_small) {
            paddr = pte_pte_small_ptr_get_address(ptSlot.ptSlot);
            if (pte_pte_small_ptr_get_contiguous_hint(ptSlot.ptSlot)) {
                offset = vaddr & ((1ul << (ARMLargePageBits))-1ul);
            } else {
                offset = vaddr & ((1ul << (ARMSmallPageBits))-1ul);
            }
# 3170 "/home/sel4/work/work2/kernel/src/arch/arm/32/kernel/vspace.c"
        } else {
            ret.status = EXCEPTION_LOOKUP_FAULT;
            return ret;
        }
    }


    kernel_vaddr = (word_t)ptrFromPAddr(paddr);
    value = (word_t*)(kernel_vaddr + offset);
    ret.status = EXCEPTION_NONE;
    ret.value = *value;
    return ret;
}

void
Arch_userStackTrace(tcb_t *tptr)
{
    cap_t threadRoot;
    pde_t *pd;
    word_t sp;
    int i;

    threadRoot = (((cte_t *)((word_t)(tptr)&~((1ul << (10))-1ul)))+(tcbVTable))->cap;

    /* lookup the PD */
    if (cap_get_capType(threadRoot) != cap_page_directory_cap) {
        kprintf("Invalid vspace\n");
        return;
    }

    pd = (pde_t*)(pptr_t)cap_get_capPtr(threadRoot);

    sp = getRegister(tptr, SP);
    /* check for alignment so we don't have to worry about accessing
     * words that might be on two different pages */
    if (!(!((sp) & ((1ul << (2))-1ul)))) {
        kprintf("SP not aligned\n");
        return;
    }

    for (i = 0; i < 16; i++) {
        word_t address = sp + (i * sizeof(word_t));
        readWordFromVSpace_ret_t result;
        result = readWordFromVSpace(pd, address);
        if (result.status == EXCEPTION_NONE) {
            kprintf("0x%lx: 0x%lx\n", (long)address, (long)result.value);
        } else {
            kprintf("0x%lx: INVALID\n", (long)address);
        }
    }
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */


# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/capdl.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/capdl.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c" 2
# 29 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c"
static int getDecodedChar(unsigned char *result)
{
    unsigned char c;
    c = getDebugChar();
    if (c == 0xff) {
        return 1;
    }
    if (c == 0xaa) {
        c = getDebugChar();
        if (c == 0xff) {
            return 1;
        }
        switch (c) {
        case 0xa1:
            *result = 0xaa;
            break;
        case 0xa0:
            *result = 0xff;
            break;
        case 0xa2:
            *result = 0xbb;
            break;
        default:
            if (c >= 20 && c < 40) {
                *result = c - 20;
            }
        }
        return 0;
    } else {
        *result = c;
        return 0;
    }
}

static void putEncodedChar(unsigned char c)
{
    switch (c) {
    case 0xaa:
        putDebugChar(0xaa);
        putDebugChar(0xa1);
        break;
    case 0xff:
        putDebugChar(0xaa);
        putDebugChar(0xa0);
        break;
    case 0xbb:
        putDebugChar(0xaa);
        putDebugChar(0xa2);
        break;
    default:
        if (c < 20) {
            putDebugChar(0xaa);
            putDebugChar(c + 20);
        } else {
            putDebugChar(c);
        }
    }
}

static int getArg32(unsigned int *res)
{
    unsigned char b1 = 0;
    unsigned char b2 = 0;
    unsigned char b3 = 0;
    unsigned char b4 = 0;
    if (getDecodedChar(&b1)) {
        return 1;
    }
    if (getDecodedChar(&b2)) {
        return 1;
    }
    if (getDecodedChar(&b3)) {
        return 1;
    }
    if (getDecodedChar(&b4)) {
        return 1;
    }
    *res = (b1 << 24 ) | (b2 << 16) | (b3 << 8) | b4;
    return 0;
}

static void sendWord(unsigned int word)
{
    putEncodedChar(word & 0xff);
    putEncodedChar((word >> 8) & 0xff);
    putEncodedChar((word >> 16) & 0xff);
    putEncodedChar((word >> 24) & 0xff);
}

static cte_t *getMDBParent(cte_t *slot)
{
    cte_t *oldSlot = ((cte_t *)(mdb_node_get_mdbPrev(slot->cteMDBNode)));

    while (oldSlot != 0 && !isMDBParentOf(oldSlot, slot)) {
        oldSlot = ((cte_t *)(mdb_node_get_mdbPrev(oldSlot->cteMDBNode)));
    }

    return oldSlot;
}

static void sendPD(unsigned int address)
{
    word_t i, exists;
    pde_t *start = (pde_t *)address;
    for (i = 0; i < (1ul << (11)); i++) {
        pde_t pde = start[i];
        exists = 0;
        if (pde_get_pdeType(pde) == pde_pde_coarse && pde_pde_coarse_get_address(pde) != 0) {
            exists = 1;
        } else if (pde_get_pdeType(pde) == pde_pde_section && (pde_pde_section_get_address(pde) != 0 ||

                                                               pde_pde_section_get_HAP(pde))) {



            exists = 1;
        }
        if (exists != 0 && i < 0xe0000000 >> pageBitsForSize(ARMSection)) {
            sendWord(i);
            sendWord(pde.words[0]);
        }
    }
}

static void sendPT(unsigned int address)
{
    word_t i, exists;
    pte_t *start = (pte_t *)address;
    for (i = 0; i < (1ul << (9)); i++) {
        pte_t pte = start[i];
        exists = 0;

        if (pte_get_pteType(pte) == pte_pte_small && (pte_pte_small_get_address(pte) != 0 ||
                                                      pte_pte_small_get_HAP(pte))) {
            exists = 1;
        }
# 174 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/capdl.c"
        if (exists != 0) {
            sendWord(i);
            sendWord(pte.words[0]);
        }
    }
}

static void sendASIDPool(unsigned int address)
{
    word_t i;
    pde_t **start = (pde_t **)address;
    for (i = 0; i < (1ul << (10)); i++) {
        pde_t *pde = start[i];
        if (pde != 0) {
            sendWord(i);
            sendWord((unsigned int)pde);
        }
    }
}

static void sendRunqueues(void)
{
    word_t i;
    sendWord((unsigned int) ksCurThread);
    for (i = 0; i < (1 * 256); i++) {
        tcb_t *current = ksReadyQueues[i].head;
        if (current != 0) {
            while (current != ksReadyQueues[i].end) {
                sendWord((unsigned int)current);
                current = current -> tcbSchedNext;
            }
            sendWord((unsigned int)current);
        }
    }
}

static void sendEPQueue(unsigned int epptr)
{
    tcb_t *current = (tcb_t *)endpoint_ptr_get_epQueue_head((endpoint_t *)epptr);
    tcb_t *tail = (tcb_t *)endpoint_ptr_get_epQueue_tail((endpoint_t *)epptr);
    if (current == 0) {
        return;
    }
    while (current != tail) {
        sendWord((unsigned int)current);
        current = current->tcbEPNext;
    }
    sendWord((unsigned int)current);
}

static void sendCNode(unsigned int address, unsigned int sizebits)
{
    word_t i;
    cte_t *start = (cte_t *)address;
    for (i = 0; i < (1 << sizebits); i++) {
        cap_t cap = start[i].cap;
        if (cap_get_capType(cap) != cap_null_cap) {
            cte_t *parent = getMDBParent(&start[i]);
            sendWord(i);
            sendWord(cap.words[0]);
            sendWord(cap.words[1]);
            sendWord((unsigned int)parent);
        }
    }
}

static void sendIRQNode(void)
{
    sendCNode((unsigned int)intStateIRQNode, 8);
}

static void sendVersion(void)
{
    sendWord(0xe0);
    sendWord(0);
}

void capDL(void)
{
    int result;
    int done = 0;
    while (done == 0) {
        unsigned char c;
        do {
            c = getDebugChar();
        } while (c != 0xff);
        do {
            result = getDecodedChar(&c);
            if (result) {
                continue;
            }
            switch (c) {
            case 0xf0: {
                /*pgdir */
                unsigned int arg;
                result = getArg32(&arg);
                if (result) {
                    continue;
                }
                sendPD(arg);
                putDebugChar(0xbb);
            }
            break;
            case 0xf5: {
                /*pg table */
                unsigned int arg;
                result = getArg32(&arg);
                if (result) {
                    continue;
                }
                sendPT(arg);
                putDebugChar(0xbb);
            }
            break;
            case 0xf6: {
                /*asid pool */
                unsigned int arg;
                result = getArg32(&arg);
                if (result) {
                    continue;
                }
                sendASIDPool(arg);
                putDebugChar(0xbb);
            }
            break;
            case 0xf1: {
                /*runqueues */
                sendRunqueues();
                putDebugChar(0xbb);
                result = 0;
            }
            break;
            case 0xf2: {
                /*endpoint waiters */
                unsigned int arg;
                result = getArg32(&arg);
                if (result) {
                    continue;
                }
                sendEPQueue(arg);
                putDebugChar(0xbb);
            }
            break;
            case 0xf3: {
                /*cnode */
                unsigned int address, sizebits;
                result = getArg32(&address);
                if (result) {
                    continue;
                }
                result = getArg32(&sizebits);
                if (result) {
                    continue;
                }

                sendCNode(address, sizebits);
                putDebugChar(0xbb);
            }
            break;
            case 0xf4: {
                sendIRQNode();
                putDebugChar(0xbb);
                result = 0;
            }
            break;
            case 0xf9: {
                sendVersion();
                putDebugChar(0xbb);
            }
            break;
            case 0xfa: {
                done = 1;
                putDebugChar(0xbb);
            }
            default:
                result = 0;
                break;
            }
        } while (result);
    }
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/fpu.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/fpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/fpu.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/fpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/fpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/fpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/fpu.c" 2

/* We cache the following value to avoid reading the coprocessor when isFpuEnable()
 * is called. enableFpu() and disableFpu(), the value is set to cache/reflect the
 * actual HW FPU enable/disable state.
 */
bool_t isFPUEnabledCached[1];


/*
 * The following function checks if the subarchitecture support asynchronous exceptions
 */
__attribute__((__section__(".boot.text"))) static inline bool_t supportsAsyncExceptions(void)
{
    word_t fpexc;

    /* Set FPEXC.EX=1 */
    __asm__ volatile("mrc  " " p10, 7,  %0, cr8, cr0, 0" /* 32-bit Floating-Point Exception Control register */ : "=r"(fpexc));
    fpexc |= (1ul << (31));
    do { word_t _v = fpexc; __asm__ volatile("mcr  " " p10, 7,  %0, cr8, cr0, 0" /* 32-bit Floating-Point Exception Control register */ :: "r" (_v)); }while(0);

    /* Read back the FPEXC register*/
    __asm__ volatile("mrc  " " p10, 7,  %0, cr8, cr0, 0" /* 32-bit Floating-Point Exception Control register */ : "=r"(fpexc));

    return !!(fpexc & (1ul << (31)));
}

/* This variable is set at boot/init time to true if the FPU supports 32 registers (d0-d31).
 * otherwise it only supports 16 registers (d0-d15).
 * We cache this value in the following variable to avoid reading the coprocessor
 * on every FPU context switch, since it shouldn't change for one platform on run-time.
 */
bool_t isFPUD32SupportedCached;

__attribute__((__section__(".boot.text"))) static inline bool_t isFPUD32Supported(void)
{
    word_t mvfr0;
    __asm__ volatile (".word 0xeef73a10 \n" /* vmrs    r3, mvfr0 */
                  "mov %0, r3       \n"
                  : "=r" (mvfr0)
                  :
                  : "r3");
    return ((mvfr0 & 0xf) == 2);
}

/* Initialise the FP/SIMD for this machine. */
__attribute__((__section__(".boot.text"))) bool_t
fpsimd_init(void)
{
    word_t cpacr;

    __asm__ volatile("mrc  " " p15, 0,  %0,  c1,  c0, 2" /* 32-bit Architectural Feature Access Control Register */ : "=r"(cpacr));
    cpacr |= (0x3 << 20 |
              0x3 << 22);
    do { word_t _v = cpacr; __asm__ volatile("mcr  " " p15, 0,  %0,  c1,  c0, 2" /* 32-bit Architectural Feature Access Control Register */ :: "r" (_v)); }while(0);

    isb();

    if (supportsAsyncExceptions()) {
        /* In the future, when we've targets that support asynchronous FPU exceptions, we've to support them */
        kprintf("Error: seL4 doesn't support FPU subarchitectures that support asynchronous exceptions\n");
        return false;
    }

    isFPUD32SupportedCached = isFPUD32Supported();
    /* Set the FPU to lazy switch mode */
    disableFpu();

    return true;
}


__attribute__((__section__(".boot.text"))) bool_t
fpsimd_HWCapTest(void)
{
    word_t cpacr, fpsid;

    /* Change permissions of CP10 and CP11 to read control/status registers */
    __asm__ volatile("mrc  " " p15, 0,  %0,  c1,  c0, 2" /* 32-bit Architectural Feature Access Control Register */ : "=r"(cpacr));
    cpacr |= (0x3 << 20 |
              0x3 << 22);
    do { word_t _v = cpacr; __asm__ volatile("mcr  " " p15, 0,  %0,  c1,  c0, 2" /* 32-bit Architectural Feature Access Control Register */ :: "r" (_v)); }while(0);

    isb();

    /* Check of this platform supports HW FP instructions */
    __asm__ volatile (".word 0xeef00a10  \n" /* vmrs    r0, fpsid */
                  "mov %0, r0        \n"
                  : "=r" (fpsid) :
                  : "r0");
    if (fpsid & (1ul << (23))) {
        return false;
    }


    word_t fpsid_subarch;

    if (supportsAsyncExceptions()) {
        /* In the future, when we've targets that support asynchronous FPU exceptions, we've to support them */
        kprintf("Error: seL4 doesn't support FPU subarchitectures that support asynchronous exceptions\n");
        return false;
    }
    /* Check for subarchitectures we support */
    fpsid_subarch = (fpsid >> 16) & 0x7f;

    switch (fpsid_subarch) {
    /* We only support the following subarch values */
    case 0x2:
    case 0x3:
    case 0x4:
        break;
    default: {
        kprintf("Error: seL4 doesn't support this VFP subarchitecture\n");
        return false;
    }

    }


    return true;
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/hardware.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/hardware.c" 2

word_t __attribute__((__pure__))
getRestartPC(tcb_t *thread)
{
    return getRegister(thread, FaultInstruction);
}

void
setNextPC(tcb_t *thread, word_t v)
{
    setRegister(thread, LR_svc, v);
}

__attribute__((__section__(".boot.text"))) int
get_num_avail_p_regs(void)
{
    return sizeof(avail_p_regs) / sizeof(p_region_t);
}

__attribute__((__section__(".boot.text"))) int
get_num_dev_p_regs(void)
{
    return sizeof(dev_p_regs) / sizeof(p_region_t);
}

__attribute__((__section__(".boot.text"))) p_region_t get_dev_p_reg(word_t i)
{
    return dev_p_regs[i];
}

__attribute__((__section__(".boot.text"))) p_region_t get_avail_p_reg(word_t i)
{
    return avail_p_regs[i];
}

__attribute__((__section__(".boot.text"))) void
map_kernel_devices(void)
{
    for (int i = 0; i < (sizeof(kernel_devices) / sizeof(kernel_devices[0])); i++) {
        map_kernel_frame(kernel_devices[i].paddr,
                         kernel_devices[i].pptr,
                         VMKernelOnly,
                         vm_attributes_new(kernel_devices[i].armExecuteNever,
                                           false, false));
    }
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/registerset.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/32/machine/registerset.c" 2

const register_t msgRegisters[] = {
    R2, R3, R4, R5
};

const register_t frameRegisters[] = {
    FaultInstruction, SP, CPSR,
    R0, R1, R8, R9, R10, R11, R12
};

const register_t gpRegisters[] = {
    R2, R3, R4, R5, R6, R7, R14
};
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug_conf.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c" 2







/* The top level asid mapping table */
asid_pool_t *armKSASIDTable[(1ul << (asidHighBits))];

/* The hardware ASID to virtual ASID mapping table */
asid_t armKSHWASIDTable[(1ul << (hwASIDBits))];
hw_asid_t armKSNextASID;
# 46 "/home/sel4/work/work2/kernel/src/arch/arm/32/model/statedata.c"
/* The global, hypervisor, level 1 page table */
pdeS1_t armHSGlobalPGD[(1ul << (2))] __attribute__((__aligned__((1ul << ((2 + 3)))))) __attribute__((__section__(".bss.aligned")));
/* The global, hypervisor, level 2 page table */
pdeS1_t armHSGlobalPD[(1ul << (9))] __attribute__((__aligned__((1ul << (12))))) __attribute__((__section__(".bss.aligned")));
/* The global, hypervisor, level 3 page table */
pteS1_t armHSGlobalPT[(1ul << (9))] __attribute__((__aligned__((1ul << (12))))) __attribute__((__section__(".bss.aligned")));
/* Global user space mappings, which are empty as there is no hared kernel region */
pde_t armUSGlobalPD[(1ul << (11))] __attribute__((__aligned__((1ul << (14))))) __attribute__((__section__(".bss.aligned")));;




/* Current VCPU */
vcpu_t *armHSCurVCPU;
/* Whether the current loaded VCPU is enabled in the hardware or not */
bool_t armHSVCPUActive;



/* Null state for the Debug coprocessor's break/watchpoint registers */
user_breakpoint_state_t armKSNullBreakpointState;
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/model/statedata.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/tlb.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c" 2

# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/vcpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c" 2


bool_t
Arch_isFrameType(word_t type)
{
    switch (type) {
    case seL4_ARM_SmallPageObject:
        return true;
    case seL4_ARM_LargePageObject:
        return true;
    case seL4_ARM_SectionObject:
        return true;
    case seL4_ARM_SuperSectionObject:
        return true;
    default:
        return false;
    }
}

deriveCap_ret_t
Arch_deriveCap(cte_t *slot, cap_t cap)
{
    deriveCap_ret_t ret;

    switch (cap_get_capType(cap)) {
    case cap_page_table_cap:
        if (cap_page_table_cap_get_capPTIsMapped(cap)) {
            ret.cap = cap;
            ret.status = EXCEPTION_NONE;
        } else {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 52, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Deriving an unmapped PT cap"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            ret.cap = cap_null_cap_new();
            ret.status = EXCEPTION_SYSCALL_ERROR;
        }
        return ret;

    case cap_page_directory_cap:
        if (cap_page_directory_cap_get_capPDIsMapped(cap)) {
            ret.cap = cap;
            ret.status = EXCEPTION_NONE;
        } else {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 64, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Deriving a PD cap without an assigned ASID"); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            ret.cap = cap_null_cap_new();
            ret.status = EXCEPTION_SYSCALL_ERROR;
        }
        return ret;

    /* This is a deviation from haskell, which has only
     * one frame cap type on ARM */
    case cap_small_frame_cap:
        ret.cap = cap_small_frame_cap_set_capFMappedASID(cap, asidInvalid);
        ret.status = EXCEPTION_NONE;
        return ret;

    case cap_frame_cap:
        ret.cap = cap_frame_cap_set_capFMappedASID(cap, asidInvalid);
        ret.status = EXCEPTION_NONE;
        return ret;

    case cap_asid_control_cap:
    case cap_asid_pool_cap:
        ret.cap = cap;
        ret.status = EXCEPTION_NONE;
        return ret;


    case cap_vcpu_cap:
        ret.cap = cap;
        ret.status = EXCEPTION_NONE;
        return ret;
# 114 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c"
    default:
        /* This assert has no equivalent in haskell,
         * as the options are restricted by type */
        _fail("Invalid arch cap", "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c", 117, __func__);
    }
}

cap_t __attribute__((__const__))
Arch_updateCapData(bool_t preserve, word_t data, cap_t cap)
{
    return cap;
}

cap_t __attribute__((__const__))
Arch_maskCapRights(seL4_CapRights_t cap_rights_mask, cap_t cap)
{
    if (cap_get_capType(cap) == cap_small_frame_cap) {
        vm_rights_t vm_rights;

        vm_rights = vmRightsFromWord(
                        cap_small_frame_cap_get_capFVMRights(cap));
        vm_rights = maskVMRights(vm_rights, cap_rights_mask);
        return cap_small_frame_cap_set_capFVMRights(cap,
                                                    wordFromVMRights(vm_rights));
    } else if (cap_get_capType(cap) == cap_frame_cap) {
        vm_rights_t vm_rights;

        vm_rights = vmRightsFromWord(
                        cap_frame_cap_get_capFVMRights(cap));
        vm_rights = maskVMRights(vm_rights, cap_rights_mask);
        return cap_frame_cap_set_capFVMRights(cap,
                                              wordFromVMRights(vm_rights));
    } else {
        return cap;
    }
}

cap_t
Arch_finaliseCap(cap_t cap, bool_t final)
{
    switch (cap_get_capType(cap)) {
    case cap_asid_pool_cap:
        if (final) {
            deleteASIDPool(cap_asid_pool_cap_get_capASIDBase(cap),
                           ((asid_pool_t *)cap_asid_pool_cap_get_capASIDPool(cap)));
        }
        break;

    case cap_page_directory_cap:
        if (final && cap_page_directory_cap_get_capPDIsMapped(cap)) {
            deleteASID(cap_page_directory_cap_get_capPDMappedASID(cap),
                       ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(cap))));
        }
        break;

    case cap_page_table_cap:
        if (final && cap_page_table_cap_get_capPTIsMapped(cap)) {
            unmapPageTable(
                cap_page_table_cap_get_capPTMappedASID(cap),
                cap_page_table_cap_get_capPTMappedAddress(cap),
                ((pte_t *)cap_page_table_cap_get_capPTBasePtr(cap)));
        }
        break;

    case cap_small_frame_cap:
        if (cap_small_frame_cap_get_capFMappedASID(cap)) {







            unmapPage(ARMSmallPage,
                      cap_small_frame_cap_get_capFMappedASID(cap),
                      cap_small_frame_cap_get_capFMappedAddress(cap),
                      (void *)cap_small_frame_cap_get_capFBasePtr(cap));
        }
        break;

    case cap_frame_cap:
        if (cap_frame_cap_get_capFMappedASID(cap)) {
# 220 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c"
            unmapPage(cap_frame_cap_get_capFSize(cap),
                      cap_frame_cap_get_capFMappedASID(cap),
                      cap_frame_cap_get_capFMappedAddress(cap),
                      (void *)cap_frame_cap_get_capFBasePtr(cap));
        }
        break;


    case cap_vcpu_cap:
        if (final) {
            vcpu_finalise(((struct vcpu *)(cap_vcpu_cap_get_capVCPUPtr(cap))));
        }
        break;
# 249 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c"
    default:
        break;
    }

    return cap_null_cap_new();
}

bool_t __attribute__((__const__))
Arch_sameRegionAs(cap_t cap_a, cap_t cap_b)
{
    switch (cap_get_capType(cap_a)) {
    case cap_small_frame_cap:
    case cap_frame_cap:
        if (cap_get_capType(cap_b) == cap_small_frame_cap ||
                cap_get_capType(cap_b) == cap_frame_cap) {
            word_t botA, botB, topA, topB;
            botA = generic_frame_cap_get_capFBasePtr(cap_a);
            botB = generic_frame_cap_get_capFBasePtr(cap_b);
            topA = botA + ((1ul << (pageBitsForSize(generic_frame_cap_get_capFSize(cap_a))))-1ul);
            topB = botB + ((1ul << (pageBitsForSize(generic_frame_cap_get_capFSize(cap_b))))-1ul) ;
            return ((botA <= botB) && (topA >= topB) && (botB <= topB));
        }
        break;

    case cap_page_table_cap:
        if (cap_get_capType(cap_b) == cap_page_table_cap) {
            return cap_page_table_cap_get_capPTBasePtr(cap_a) ==
                   cap_page_table_cap_get_capPTBasePtr(cap_b);
        }
        break;

    case cap_page_directory_cap:
        if (cap_get_capType(cap_b) == cap_page_directory_cap) {
            return cap_page_directory_cap_get_capPDBasePtr(cap_a) ==
                   cap_page_directory_cap_get_capPDBasePtr(cap_b);
        }
        break;

    case cap_asid_control_cap:
        if (cap_get_capType(cap_b) == cap_asid_control_cap) {
            return true;
        }
        break;

    case cap_asid_pool_cap:
        if (cap_get_capType(cap_b) == cap_asid_pool_cap) {
            return cap_asid_pool_cap_get_capASIDPool(cap_a) ==
                   cap_asid_pool_cap_get_capASIDPool(cap_b);
        }
        break;


    case cap_vcpu_cap:
        if (cap_get_capType(cap_b) == cap_vcpu_cap) {
            return cap_vcpu_cap_get_capVCPUPtr(cap_a) ==
                   cap_vcpu_cap_get_capVCPUPtr(cap_b);
        }
        break;
# 324 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c"
    }

    return false;
}

bool_t __attribute__((__const__))
Arch_sameObjectAs(cap_t cap_a, cap_t cap_b)
{
    if (cap_get_capType(cap_a) == cap_small_frame_cap) {
        if (cap_get_capType(cap_b) == cap_small_frame_cap) {
            return ((cap_small_frame_cap_get_capFBasePtr(cap_a) ==
                     cap_small_frame_cap_get_capFBasePtr(cap_b)) &&
                    ((cap_small_frame_cap_get_capFIsDevice(cap_a) == 0) ==
                     (cap_small_frame_cap_get_capFIsDevice(cap_b) == 0)));
        } else if (cap_get_capType(cap_b) == cap_frame_cap) {
            return false;
        }
    }
    if (cap_get_capType(cap_a) == cap_frame_cap) {
        if (cap_get_capType(cap_b) == cap_frame_cap) {
            return ((cap_frame_cap_get_capFBasePtr(cap_a) ==
                     cap_frame_cap_get_capFBasePtr(cap_b)) &&
                    (cap_frame_cap_get_capFSize(cap_a) ==
                     cap_frame_cap_get_capFSize(cap_b)) &&
                    ((cap_frame_cap_get_capFIsDevice(cap_a) == 0) ==
                     (cap_frame_cap_get_capFIsDevice(cap_b) == 0)));
        } else if (cap_get_capType(cap_b) == cap_small_frame_cap) {
            return false;
        }
    }
    return Arch_sameRegionAs(cap_a, cap_b);
}

word_t
Arch_getObjectSize(word_t t)
{
    switch (t) {
    case seL4_ARM_SmallPageObject:
        return ARMSmallPageBits;
    case seL4_ARM_LargePageObject:
        return ARMLargePageBits;
    case seL4_ARM_SectionObject:
        return ARMSectionBits;
    case seL4_ARM_SuperSectionObject:
        return ARMSuperSectionBits;
    case seL4_ARM_PageTableObject:
        return 3 + 9;
    case seL4_ARM_PageDirectoryObject:
        return 3 + 11;





    case seL4_ARM_VCPUObject:
        return 12;

    default:
        _fail("Invalid object type", "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c", 382, __func__);
        return 0;
    }
}

cap_t
Arch_createObject(object_t t, void *regionBase, word_t userSize, bool_t deviceMemory)
{
    switch (t) {
    case seL4_ARM_SmallPageObject:
        if (deviceMemory) {
            /** AUXUPD: "(True, ptr_retyps 1
                     (Ptr (ptr_val \<acute>regionBase) :: user_data_device_C ptr))" */
            /** GHOSTUPD: "(True, gs_new_frames vmpage_size.ARMSmallPage
                                                    (ptr_val \<acute>regionBase)
                                                    (unat ARMSmallPageBits))" */
        } else {
            /** AUXUPD: "(True, ptr_retyps 1
                     (Ptr (ptr_val \<acute>regionBase) :: user_data_C ptr))" */
            /** GHOSTUPD: "(True, gs_new_frames vmpage_size.ARMSmallPage
                                                    (ptr_val \<acute>regionBase)
                                                    (unat ARMSmallPageBits))" */
        }
        return cap_small_frame_cap_new(
                   (asidInvalid & ((1ul << (asidLowBits))-1ul)), VMReadWrite,
                   0, !!deviceMemory,



                   ((asidInvalid >> asidLowBits) & ((1ul << (asidHighBits))-1ul)),
                   (word_t)regionBase);

    case seL4_ARM_LargePageObject:
        if (deviceMemory) {
            /** AUXUPD: "(True, ptr_retyps 16
                     (Ptr (ptr_val \<acute>regionBase) :: user_data_device_C ptr))" */
            /** GHOSTUPD: "(True, gs_new_frames vmpage_size.ARMLargePage
                                                    (ptr_val \<acute>regionBase)
                                                    (unat ARMLargePageBits))" */
        } else {
            /** AUXUPD: "(True, ptr_retyps 16
                     (Ptr (ptr_val \<acute>regionBase) :: user_data_C ptr))" */
            /** GHOSTUPD: "(True, gs_new_frames vmpage_size.ARMLargePage
                                                    (ptr_val \<acute>regionBase)
                                                    (unat ARMLargePageBits))" */
        }
        return cap_frame_cap_new(
                   ARMLargePage, (asidInvalid & ((1ul << (asidLowBits))-1ul)), VMReadWrite,
                   0, !!deviceMemory, ((asidInvalid >> asidLowBits) & ((1ul << (asidHighBits))-1ul)),
                   (word_t)regionBase);

    case seL4_ARM_SectionObject:
        if (deviceMemory) {

            /** AUXUPD: "(True, ptr_retyps 512
                 (Ptr (ptr_val \<acute>regionBase) :: user_data_device_C ptr))" */




            /** GHOSTUPD: "(True, gs_new_frames vmpage_size.ARMSection
                                            (ptr_val \<acute>regionBase)
                                            (unat ARMSectionBits))" */
        } else {

            /** AUXUPD: "(True, ptr_retyps 512
                 (Ptr (ptr_val \<acute>regionBase) :: user_data_C ptr))" */




            /** GHOSTUPD: "(True, gs_new_frames vmpage_size.ARMSection
                                            (ptr_val \<acute>regionBase)
                                            (unat ARMSectionBits))" */
        }
        return cap_frame_cap_new(
                   ARMSection, (asidInvalid & ((1ul << (asidLowBits))-1ul)), VMReadWrite,
                   0, !!deviceMemory, ((asidInvalid >> asidLowBits) & ((1ul << (asidHighBits))-1ul)),
                   (word_t)regionBase);

    case seL4_ARM_SuperSectionObject:
        if (deviceMemory) {

            /** AUXUPD: "(True, ptr_retyps 8192
                    (Ptr (ptr_val \<acute>regionBase) :: user_data_device_C ptr))" */




            /** GHOSTUPD: "(True, gs_new_frames vmpage_size.ARMSuperSection
                                                (ptr_val \<acute>regionBase)
                                                (unat ARMSuperSectionBits))" */
        } else {

            /** AUXUPD: "(True, ptr_retyps 8192
                    (Ptr (ptr_val \<acute>regionBase) :: user_data_C ptr))" */




            /** GHOSTUPD: "(True, gs_new_frames vmpage_size.ARMSuperSection
                                                (ptr_val \<acute>regionBase)
                                                (unat ARMSuperSectionBits))" */
        }
        return cap_frame_cap_new(
                   ARMSuperSection, (asidInvalid & ((1ul << (asidLowBits))-1ul)), VMReadWrite,
                   0, !!deviceMemory, ((asidInvalid >> asidLowBits) & ((1ul << (asidHighBits))-1ul)),
                   (word_t)regionBase);

    case seL4_ARM_PageTableObject:

        /** AUXUPD: "(True, ptr_retyps 1
              (Ptr (ptr_val \<acute>regionBase) :: (pte_C[512]) ptr))" */





        return cap_page_table_cap_new(false, asidInvalid, 0,
                                      (word_t)regionBase);

    case seL4_ARM_PageDirectoryObject:

        /** AUXUPD: "(True, ptr_retyps 1
              (Ptr (ptr_val \<acute>regionBase) :: (pde_C[2048]) ptr))" */




        copyGlobalMappings((pde_t *)regionBase);
        cleanCacheRange_PoU((word_t)regionBase,
                            (word_t)regionBase + (1 << (11 + 3)) - 1,
                            addrFromPPtr(regionBase));

        return cap_page_directory_cap_new(false, asidInvalid,
                                          (word_t)regionBase);

    case seL4_ARM_VCPUObject:
        /** AUXUPD: "(True, ptr_retyp
          (Ptr (ptr_val \<acute>regionBase) :: vcpu_C ptr))" */
        vcpu_init(((struct vcpu *)(regionBase)));
        return cap_vcpu_cap_new(((unsigned int)(regionBase)));
# 535 "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c"
    default:
        /*
         * This is a conflation of the haskell error: "Arch.createNewCaps
         * got an API type" and the case where an invalid object type is
         * passed (which is impossible in haskell).
         */
        _fail("Arch_createObject got an API type or invalid object type", "/home/sel4/work/work2/kernel/src/arch/arm/32/object/objecttype.c", 541, __func__);
    }
}

exception_t
Arch_decodeInvocation(word_t invLabel, word_t length, cptr_t cptr,
                      cte_t *slot, cap_t cap, extra_caps_t excaps,
                      bool_t call, word_t *buffer)
{
    /* The C parser cannot handle a switch statement with only a default
     * case. So we need to do some gymnastics to remove the switch if
     * there are no other cases */

    switch (cap_get_capType(cap)) {







    case cap_vcpu_cap:
        return decodeARMVCPUInvocation(invLabel, length, cptr, slot, cap, excaps, call, buffer);

    default:



    return decodeARMMMUInvocation(invLabel, length, cptr, slot, cap, excaps, buffer);
}
}

void
Arch_prepareThreadDelete(tcb_t * thread) {

    if (thread->tcbArch.tcbVCPU) {
        dissociateVCPUTCB(thread->tcbArch.tcbVCPU, thread);
    }



}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/api/faults.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/faults.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/api/faults.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/arch/arm/api/faults.c" 2

bool_t
Arch_handleFaultReply(tcb_t *receiver, tcb_t *sender, word_t faultType)
{
    switch (faultType) {
    case seL4_Fault_VMFault:
        return true;


    case seL4_Fault_VGICMaintenance:
        return true;
    case seL4_Fault_VCPUFault:
        return true;

    default:
        _fail("Invalid fault", "/home/sel4/work/work2/kernel/src/arch/arm/api/faults.c", 34, __func__);
    }
}

word_t
Arch_setMRs_fault(tcb_t *sender, tcb_t* receiver, word_t *receiveIPCBuffer, word_t faultType)
{
    switch (faultType) {
    case seL4_Fault_VMFault: {
        if (1) {
            word_t ipa, va;
            va = getRestartPC(sender);
            ipa = (addressTranslateS1CPR(va) & ~((1ul << (12))-1ul)) | (va & ((1ul << (12))-1ul));
            setMR(receiver, receiveIPCBuffer, seL4_VMFault_IP, ipa);
        } else {
            setMR(receiver, receiveIPCBuffer, seL4_VMFault_IP, getRestartPC(sender));
        }
        setMR(receiver, receiveIPCBuffer, seL4_VMFault_Addr,
              seL4_Fault_VMFault_get_address(sender->tcbFault));
        setMR(receiver, receiveIPCBuffer, seL4_VMFault_PrefetchFault,
              seL4_Fault_VMFault_get_instructionFault(sender->tcbFault));
        return setMR(receiver, receiveIPCBuffer, seL4_VMFault_FSR,
                     seL4_Fault_VMFault_get_FSR(sender->tcbFault));
    }


    case seL4_Fault_VGICMaintenance:
        if (seL4_Fault_VGICMaintenance_get_idxValid(sender->tcbFault)) {
            return setMR(receiver, receiveIPCBuffer, seL4_VGICMaintenance_IDX,
                         seL4_Fault_VGICMaintenance_get_idx(sender->tcbFault));
        } else {
            return setMR(receiver, receiveIPCBuffer, seL4_VGICMaintenance_IDX, -1);
        }
    case seL4_Fault_VCPUFault:
        return setMR(receiver, receiveIPCBuffer, seL4_VCPUFault_HSR, seL4_Fault_VCPUFault_get_hsr(sender->tcbFault));


    default:
        _fail("Invalid fault", "/home/sel4/work/work2/kernel/src/arch/arm/api/faults.c", 72, __func__);
    }
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/armv/armv7-a/benchmark.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/armv/armv7-a/benchmark.c" 2
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/armv/armv7-a/cache.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/armv/armv7-a/cache.c" 2

static inline void invalidateByWSL(word_t wsl)
{
    __asm__ volatile("mcr p15, 0, %0, c7, c6, 2" : : "r"(wsl));
}

static inline void cleanByWSL(word_t wsl)
{
    __asm__ volatile("mcr p15, 0, %0, c7, c10, 2" : : "r"(wsl));
}

static inline void cleanInvalidateByWSL(word_t wsl)
{
    __asm__ volatile("mcr p15, 0, %0, c7, c14, 2" : : "r"(wsl));
}


static inline word_t readCLID(void)
{
    word_t CLID;
    __asm__ volatile("mrc p15, 1, %0, c0, c0, 1" : "=r"(CLID));
    return CLID;
}






enum arm_cache_type {
    ARMCacheNone = 0,
    ARMCacheI = 1,
    ARMCacheD = 2,
    ARMCacheID = 3,
    ARMCacheU = 4,
};


static inline word_t readCacheSize(int level, bool_t instruction)
{
    word_t size_unique_name, csselr_old;
    /* Save CSSELR */
    __asm__ volatile("mrc p15, 2, %0, c0, c0, 0" : "=r"(csselr_old));
    /* Select cache level */
    __asm__ volatile("mcr p15, 2, %0, c0, c0, 0" : : "r"((level << 1) | instruction));
    /* Read 'size' */
    __asm__ volatile("mrc p15, 1, %0, c0, c0, 0" : "=r"(size_unique_name));
    /* Restore CSSELR */
    __asm__ volatile("mcr p15, 2, %0, c0, c0, 0" : : "r"(csselr_old));
    return size_unique_name;
}

/* Number of bits to index within a cache line.  The field is log2(nwords) - 2
 * , and thus by adding 4 we get log2(nbytes). */

/* Associativity, field is assoc - 1. */

/* Number of sets, field is nsets - 1. */



void
clean_D_PoU(void)
{
    int clid = readCLID();
    int lou = (((clid) >> 27) & ((1ul << (3))-1ul));
    int l;

    for (l = 0; l < lou; l++) {
        if ((((clid) >> (l*3)) & ((1ul << (3))-1ul)) > ARMCacheI) {
            word_t s = readCacheSize(l, 0);
            int lbits = (( (s) & ((1ul << (3))-1ul)) + 4);
            int assoc = ((((s) >> 3) & ((1ul << (10))-1ul)) + 1);
            int assoc_bits = (1 << 5) - clzl(assoc - 1);
            int nsets = ((((s) >> 13) & ((1ul << (15))-1ul)) + 1);
            int w;

            for (w = 0; w < assoc; w++) {
                int v;

                for (v = 0; v < nsets; v++) {
                    cleanByWSL((w << (32 - assoc_bits)) |
                               (v << lbits) | (l << 1));
                }
            }
        }
    }
}


void
cleanInvalidate_D_PoC(void)
{
    int clid = readCLID();
    int loc = (((clid) >> 24) & ((1ul << (3))-1ul));
    int l;

    for (l = 0; l < loc; l++) {
        if ((((clid) >> (l*3)) & ((1ul << (3))-1ul)) > ARMCacheI) {
            word_t s = readCacheSize(l, 0);
            int lbits = (( (s) & ((1ul << (3))-1ul)) + 4);
            int assoc = ((((s) >> 3) & ((1ul << (10))-1ul)) + 1);
            int assoc_bits = (1 << 5) - clzl(assoc - 1);
            int nsets = ((((s) >> 13) & ((1ul << (15))-1ul)) + 1);
            int w;

            for (w = 0; w < assoc; w++) {
                int v;

                for (v = 0; v < nsets; v++) {
                    cleanInvalidateByWSL((w << (32 - assoc_bits)) |
                                         (v << lbits) | (l << 1));
                }
            }
        }
    }
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/armv/armv7-a/user_access.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/armv/armv7-a/user_access.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/user_access.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




void armv_init_user_access(void);
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/armv/armv7-a/user_access.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/debug.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/debug.h" 2


/* Not guaranteed in v7, only v7.1+ */
# 33 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/debug.h"
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 34 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/debug.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 35 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/debug.h" 2

void debug_init(void) __attribute__((externally_visible));

typedef void (*break_handler_t)(user_context_t *context);

void software_breakpoint(uint32_t va, user_context_t *context) __attribute__((externally_visible));
void breakpoint_multiplexer(uint32_t va, user_context_t *context) __attribute__((externally_visible));

int set_breakpoint(uint32_t va, break_handler_t handler) __attribute__((externally_visible));
void clear_breakpoint(uint32_t va) __attribute__((externally_visible));

enum vector_ids {
    VECTOR_RESET = 0,
    VECTOR_UNDEFINED = 1,
    VECTOR_SWI = 2,
    VECTOR_PREFETCH_ABORT = 3,
    VECTOR_DATA_ABORT = 4,
    VECTOR_IRQ = 6,
    VECTOR_FIQ = 7
};
typedef uint32_t vector_t;

typedef void (*catch_handler_t)(user_context_t *context, vector_t vector);

void set_catch_handler(catch_handler_t handler) __attribute__((externally_visible));
void catch_vector(vector_t vector) __attribute__((externally_visible));
void uncatch_vector(vector_t vector) __attribute__((externally_visible));


/*********************************/
/*** cp14 register definitions ***/
/*********************************/

/* Debug ID Register */
# 79 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/debug.h"
static inline uint32_t
getDIDR(void)
{
    uint32_t x;

    __asm__ volatile("mrc p14, 0, %0, c0, c0, 0" : "=r"(x));

    return x;
}
# 105 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/debug.h"
/* Debug Status and Control Register */
# 121 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/debug.h"
/* Vector Catch Register */
# 131 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/debug.h"
static inline uint32_t
getVCR(void)
{
    uint32_t x;

    __asm__ volatile("mrc p14, 0, %0, c0, c7, 0" : "=r"(x));

    return x;
}

static inline void
setVCR(uint32_t x)
{
    __asm__ volatile("mcr p14, 0, %0, c0, c7, 0" : : "r"(x));
}



/* Breakpoint Control Registers */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/armv/armv7-a/user_access.c" 2
# 29 "/home/sel4/work/work2/kernel/src/arch/arm/armv/armv7-a/user_access.c"
static void
check_export_pmu(void)
{
# 45 "/home/sel4/work/work2/kernel/src/arch/arm/armv/armv7-a/user_access.c"
}


static void
check_export_arch_timer(void)
{
    uint32_t v;
    __asm__ volatile("mrc  " " p15, 0,  %0, c14,  c1, 0" /* 32-bit RW Timer PL1 Control register */ : "=r"(v));

    v |= (1ul << (0));


    v |= (1ul << (1));

    do { word_t _v = v; __asm__ volatile("mcr  " " p15, 0,  %0, c14,  c1, 0" /* 32-bit RW Timer PL1 Control register */ :: "r" (_v)); }while(0);
}


void
armv_init_user_access(void)
{
    uint32_t v;
    /* Performance Monitoring Unit */
    __asm__ volatile("mrc  " " p15, 0,  %0,  c0,  c1, 2" /* 32-bit RO Debug feature register */ : "=r"(v));
    if ((v & (0xful << 28)) != (0xful << 28)) {
        check_export_pmu();
    }
    /* Arch timers */
    __asm__ volatile("mrc  " " p15, 0,  %0,  c0,  c1, 1" /* 32-bit RO CPU feature register */ : "=r"(v));
    if (v & (1ul << (16))) {
        check_export_arch_timer();
    }
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/benchmark/benchmark.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/traps.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/vcpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/fpu.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c" 2

# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track_types.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */
# 21 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c" 2

void __attribute__((externally_visible)) __attribute__((__noreturn__))
c_handle_undefined_instruction(void)
{
    do {} while (0);
    c_entry_hook();


    ksKernelEntry.path = Entry_UserLevelFault;
    ksKernelEntry.word = getRegister(ksCurThread, LR_svc);



    /* We assume the first fault is a FP exception and enable FPU, if not already enabled */
    if (!isFpuEnable()) {
        handleFPUFault();

        /* Restart the FP instruction that cause the fault */
        setNextPC(ksCurThread, getRestartPC(ksCurThread));
    } else {
        handleUserLevelFault(0, 0);
    }

    restore_user_context();
    __builtin_unreachable();


    /* There's only one user-level fault on ARM, and the code is (0,0) */
    handleUserLevelFault(0, 0);
    restore_user_context();
    __builtin_unreachable();
}
# 69 "/home/sel4/work/work2/kernel/src/arch/arm/c_traps.c"
static inline void __attribute__((__noreturn__))
c_handle_vm_fault(vm_fault_type_t type)
{
    do {} while (0);
    c_entry_hook();


    ksKernelEntry.path = Entry_VMFault;
    ksKernelEntry.word = getRegister(ksCurThread, LR_svc);


    handleVMFaultEvent(type);
    restore_user_context();
    __builtin_unreachable();
}

void __attribute__((externally_visible)) __attribute__((__noreturn__))
c_handle_data_fault(void)
{
    c_handle_vm_fault(0);
}

void __attribute__((externally_visible)) __attribute__((__noreturn__))
c_handle_instruction_fault(void)
{
    c_handle_vm_fault(1);
}

void __attribute__((externally_visible)) __attribute__((__noreturn__))
c_handle_interrupt(void)
{
    do {} while (0);
    c_entry_hook();


    ksKernelEntry.path = Entry_Interrupt;
    ksKernelEntry.word = getActiveIRQ();


    handleInterruptEntry();
    restore_user_context();
}

void __attribute__((__noreturn__))
slowpath(syscall_t syscall)
{

    ksKernelEntry.is_fastpath = 0;

    handleSyscall(syscall);

    restore_user_context();
    __builtin_unreachable();
}

void __attribute__((externally_visible))
c_handle_syscall(word_t cptr, word_t msgInfo, syscall_t syscall)
{
    do {} while (0);

    c_entry_hook();

    benchmark_debug_syscall_start(cptr, msgInfo, syscall);
    ksKernelEntry.is_fastpath = 1;



    if (syscall == SysCall) {
        fastpath_call(cptr, msgInfo);
        __builtin_unreachable();
    } else if (syscall == SysReplyRecv) {
        fastpath_reply_recv(cptr, msgInfo);
        __builtin_unreachable();
    }


    if (__builtin_expect(!!(syscall < (-8) || syscall > (-1)), 0)) {

        ksKernelEntry.path = Entry_UnknownSyscall;
        /* ksKernelEntry.word word is already set to syscall */

        handleUnknownSyscall(syscall);
        restore_user_context();
        __builtin_unreachable();
    } else {
        slowpath(syscall);
        __builtin_unreachable();
    }
}


__attribute__((externally_visible)) __attribute__((__noreturn__)) void
c_handle_vcpu_fault(word_t hsr)
{
    c_entry_hook();


    ksKernelEntry.path = Entry_VCPUFault;
    ksKernelEntry.word = hsr;

    handleVCPUFault(hsr);
    restore_user_context();
    __builtin_unreachable();
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/boot.h" 2

cap_t create_unmapped_it_frame_cap(pptr_t pptr, bool_t use_large);
cap_t create_mapped_it_frame_cap(cap_t pd_cap, pptr_t pptr, vptr_t vptr, asid_t asid, bool_t use_large, bool_t executable);

void init_kernel(
    paddr_t ui_p_reg_start,
    paddr_t ui_p_reg_end,
    sword_t pv_offset,
    vptr_t v_entry
);
# 19 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/benchmark.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/user_access.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/iospace.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/timer.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */



void resetTimer(void);
void initTimer(void);
# 27 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/fpu.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 28 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/tlb.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 29 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c" 2

/* pointer to the end of boot code/data in kernel image */
/* need a fake array to get the pointer from the linker script */
extern char ki_boot_end[1];
/* pointer to end of kernel image */
extern char ki_end[1];







/**
 * Split mem_reg about reserved_reg. If memory exists in the lower
 * segment, insert it. If memory exists in the upper segment, return it.
 */
__attribute__((__section__(".boot.text"))) static region_t
insert_region_excluded(region_t mem_reg, region_t reserved_reg)
{
    region_t residual_reg = mem_reg;
    bool_t result __attribute__((unused));

    if (reserved_reg.start < mem_reg.start) {
        /* Reserved region is below the provided mem_reg. */
        mem_reg.end = 0;
        mem_reg.start = 0;
        /* Fit the residual around the reserved region */
        if (reserved_reg.end > residual_reg.start) {
            residual_reg.start = reserved_reg.end;
        }
    } else if (mem_reg.end > reserved_reg.start) {
        /* Split mem_reg around reserved_reg */
        mem_reg.end = reserved_reg.start;
        residual_reg.start = reserved_reg.end;
    } else {
        /* reserved_reg is completely above mem_reg */
        residual_reg.start = 0;
        residual_reg.end = 0;
    }
    /* Add the lower region if it exists */
    if (mem_reg.start < mem_reg.end) {
        result = insert_region(mem_reg);
        if(!(result)) _assert_fail("result", "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c", 72, __FUNCTION__);
    }
    /* Validate the upper region */
    if (residual_reg.start > residual_reg.end) {
        residual_reg.start = residual_reg.end;
    }

    return residual_reg;
}

__attribute__((__section__(".boot.text"))) static region_t
get_reserved_region(int i, pptr_t res_reg_end)
{
    region_t res_reg = mode_reserved_region[i];

    /* Force ordering and exclusivity of reserved regions. */
    if(!(res_reg.start < res_reg.end)) _assert_fail("res_reg.start < res_reg.end", "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c", 88, __FUNCTION__);
    if(!(res_reg_end <= res_reg.start)) _assert_fail("res_reg_end <= res_reg.start", "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c", 89, __FUNCTION__);
    return res_reg;
}

__attribute__((__section__(".boot.text"))) static int
get_num_reserved_region(void)
{
    return sizeof(mode_reserved_region) / sizeof(region_t);
}

__attribute__((__section__(".boot.text"))) static void
init_freemem(region_t ui_reg)
{
    word_t i;
    bool_t result __attribute__((unused));
    region_t cur_reg;
    region_t res_reg[] = {
        {
            .start = 0xe0000000,
            .end = (pptr_t)ki_end
        },
        {
            .start = ui_reg.start,
            .end = ui_reg.end
        },
    };

    for (i = 0; i < 2; i++) {
        ndks_boot.freemem[i] = (region_t){ .start = 0, .end = 0 };
    }

    /* Force ordering and exclusivity of reserved regions. */
    if(!(res_reg[0].start < res_reg[0].end)) _assert_fail("res_reg[0].start < res_reg[0].end", "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c", 121, __FUNCTION__);
    if(!(res_reg[1].start < res_reg[1].end)) _assert_fail("res_reg[1].start < res_reg[1].end", "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c", 122, __FUNCTION__);
    if(!(res_reg[0].end <= res_reg[1].start)) _assert_fail("res_reg[0].end <= res_reg[1].start", "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c", 123, __FUNCTION__);
    for (i = 0; i < get_num_avail_p_regs(); i++) {
        cur_reg = paddr_to_pptr_reg(get_avail_p_reg(i));
        /* Adjust region if it exceeds the kernel window
         * Note that we compare physical address in case of overflow.
         */
        if (addrFromPPtr((void*)cur_reg.end) > (0xfff00000 - (0xe0000000 - 0x60000000))) {
            cur_reg.end = 0xfff00000;
        }
        if (addrFromPPtr((void*)cur_reg.start) > (0xfff00000 - (0xe0000000 - 0x60000000))) {
            cur_reg.start = 0xfff00000;
        }

        cur_reg = insert_region_excluded(cur_reg, res_reg[0]);
        cur_reg = insert_region_excluded(cur_reg, res_reg[1]);

        /* Check any reserved mode specific reagion */
        region_t mode_res_reg = res_reg[1];
        for (int m = 0; m < get_num_reserved_region(); m++) {
            mode_res_reg = get_reserved_region(i, mode_res_reg.end);
            cur_reg = insert_region_excluded(cur_reg, mode_res_reg);
        }

        if (cur_reg.start != cur_reg.end) {
            result = insert_region(cur_reg);
            if(!(result)) _assert_fail("result", "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c", 148, __FUNCTION__);
        }
    }
}

__attribute__((__section__(".boot.text"))) static void
init_irqs(cap_t root_cnode_cap)
{
    irq_t i;

    for (i = 0; i <= maxIRQ; i++) {
        setIRQState(IRQInactive, i);
    }
    setIRQState(IRQTimer, INTERRUPT_CNTHPIRQ);

    setIRQState(IRQReserved, INTERRUPT_VGIC_MAINTENANCE);
# 182 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c"
    /* provide the IRQ control cap */
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapIRQControl)), cap_irq_control_cap_new());
}

__attribute__((__section__(".boot.text"))) static bool_t
create_untypeds(cap_t root_cnode_cap, region_t boot_mem_reuse_reg)
{
    seL4_SlotPos slot_pos_before;
    seL4_SlotPos slot_pos_after;
    region_t dev_reg;
    word_t i;

    slot_pos_before = ndks_boot.slot_pos_cur;
    create_kernel_untypeds(root_cnode_cap, boot_mem_reuse_reg, slot_pos_before);
    for (i = 0; i < get_num_dev_p_regs(); i++) {
        dev_reg = paddr_to_pptr_reg(get_dev_p_reg(i));
        if (!create_untypeds_for_region(root_cnode_cap, true,
                                        dev_reg, slot_pos_before)) {
            return false;
        }
    }

    slot_pos_after = ndks_boot.slot_pos_cur;
    ndks_boot.bi_frame->untyped = (seL4_SlotRegion) {
        slot_pos_before, slot_pos_after
    };
    return true;

}

/** This and only this function initialises the CPU.
 *
 * It does NOT initialise any kernel state.
 * @return For the verification build, this currently returns true always.
 */
__attribute__((__section__(".boot.text"))) static bool_t
init_cpu(void)
{
    bool_t haveHWFPU;

    activate_global_pd();
    if (1) {
        vcpu_boot_init();
    }
# 235 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c"
    /* Setup kernel stack pointer.
     * On ARM SMP, the array index here is the CPU ID
     */

    word_t stack_top = ((word_t) kernel_stack_alloc[0]) + (1ul << (12));
    setKernelStack(stack_top);







    haveHWFPU = fpsimd_HWCapTest();

    /* Disable FPU to avoid channels where a platform has an FPU but doesn't make use of it */
    if (haveHWFPU) {
        disableFpu();
    }


    if (haveHWFPU) {
        if (!fpsimd_init()) {
            return false;
        }
    } else {
        kprintf("Platform claims to have FP hardware, but does not!");
        return false;
    }


    cpu_initLocalIRQController();





    /* Export selected CPU features for access by PL0 */
    armv_init_user_access();

    initTimer();

    return true;
}

/* This and only this function initialises the platform. It does NOT initialise any kernel state. */

__attribute__((__section__(".boot.text"))) static void
init_plat(void)
{
    initIRQController();
    initL2Cache();
}
# 331 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c"
/* Main kernel initialisation function. */

static __attribute__((__section__(".boot.text"))) bool_t
try_init_kernel(
    paddr_t ui_p_reg_start,
    paddr_t ui_p_reg_end,
    sword_t pv_offset,
    vptr_t v_entry
)
{
    cap_t root_cnode_cap;
    cap_t it_ap_cap;
    cap_t it_pd_cap;
    cap_t ipcbuf_cap;
    region_t ui_reg = paddr_to_pptr_reg((p_region_t) {
        ui_p_reg_start, ui_p_reg_end
    });
    pptr_t bi_frame_pptr;
    vptr_t bi_frame_vptr;
    vptr_t ipcbuf_vptr;
    create_frames_of_region_ret_t create_frames_ret;

    /* convert from physical addresses to userland vptrs */
    v_region_t ui_v_reg;
    v_region_t it_v_reg;
    ui_v_reg.start = ui_p_reg_start - pv_offset;
    ui_v_reg.end = ui_p_reg_end - pv_offset;

    ipcbuf_vptr = ui_v_reg.end;
    bi_frame_vptr = ipcbuf_vptr + (1ul << (12));

    /* The region of the initial thread is the user image + ipcbuf and boot info */
    it_v_reg.start = ui_v_reg.start;
    it_v_reg.end = bi_frame_vptr + (1ul << (12));

    if (it_v_reg.end > 0xe0000000) {
        kprintf("Userland image virtual end address too high\n");
        return false;
    }

    /* setup virtual memory for the kernel */
    map_kernel_window();

    /* initialise the CPU */
    if (!init_cpu()) {
        return false;
    }

    /* debug output via serial port is only available from here */
    kprintf("Bootstrapping kernel\n");

    /* initialise the platform */
    init_plat();

    /* make the free memory available to alloc_region() */
    init_freemem(ui_reg);

    /* create the root cnode */
    root_cnode_cap = create_root_cnode();
    if (cap_get_capType(root_cnode_cap) == cap_null_cap) {
        return false;
    }

    /* create the cap for managing thread domains */
    create_domain_cap(root_cnode_cap);

    /* create the IRQ CNode */
    if (!create_irq_cnode()) {
        return false;
    }

    /* initialise the IRQ states and provide the IRQ control cap */
    init_irqs(root_cnode_cap);

    /* create the bootinfo frame */
    bi_frame_pptr = allocate_bi_frame(0, 1, ipcbuf_vptr);
    if (!bi_frame_pptr) {
        return false;
    }

    if (0) {
        ndks_boot.bi_frame->ioSpaceCaps = create_iospace_caps(root_cnode_cap);
        if (ndks_boot.bi_frame->ioSpaceCaps.start == 0 &&
                ndks_boot.bi_frame->ioSpaceCaps.end == 0) {
            return false;
        }
    } else {
        ndks_boot.bi_frame->ioSpaceCaps = (seL4_SlotRegion){ .start = 0, .end = 0 };
    }

    /* Construct an initial address space with enough virtual addresses
     * to cover the user image + ipc buffer and bootinfo frames */
    it_pd_cap = create_it_address_space(root_cnode_cap, it_v_reg);
    if (cap_get_capType(it_pd_cap) == cap_null_cap) {
        return false;
    }

    /* Create and map bootinfo frame cap */
    create_bi_frame_cap(
        root_cnode_cap,
        it_pd_cap,
        bi_frame_pptr,
        bi_frame_vptr
    );

    /* create the initial thread's IPC buffer */
    ipcbuf_cap = create_ipcbuf_frame(root_cnode_cap, it_pd_cap, ipcbuf_vptr);
    if (cap_get_capType(ipcbuf_cap) == cap_null_cap) {
        return false;
    }

    /* create all userland image frames */
    create_frames_ret =
        create_frames_of_region(
            root_cnode_cap,
            it_pd_cap,
            ui_reg,
            true,
            pv_offset
        );
    if (!create_frames_ret.success) {
        return false;
    }
    ndks_boot.bi_frame->userImageFrames = create_frames_ret.region;

    /* create/initialise the initial thread's ASID pool */
    it_ap_cap = create_it_asid_pool(root_cnode_cap);
    if (cap_get_capType(it_ap_cap) == cap_null_cap) {
        return false;
    }
    write_it_asid_pool(it_ap_cap, it_pd_cap);

    /* create the idle thread */
    if (!create_idle_thread()) {
        return false;
    }

    /* Before creating the initial thread (which also switches to it)
     * we clean the cache so that any page table information written
     * as a result of calling create_frames_of_region will be correctly
     * read by the hardware page table walker */
    cleanInvalidateL1Caches();

    /* create the initial thread */
    tcb_t *initial = create_initial_thread(
                         root_cnode_cap,
                         it_pd_cap,
                         v_entry,
                         bi_frame_vptr,
                         ipcbuf_vptr,
                         ipcbuf_cap
                     );

    if (initial == ((void *)0)) {
        return false;
    }

    init_core_state(initial);

    /* create all of the untypeds. Both devices and kernel window memory */
    if (!create_untypeds(
                root_cnode_cap,
    (region_t) {
    0xe0000000, (pptr_t)ki_boot_end
    } /* reusable boot code/data */
            )) {
        return false;
    }

    /* no shared-frame caps (ARM has no multikernel support) */
    ndks_boot.bi_frame->sharedFrames = (seL4_SlotRegion){ .start = 0, .end = 0 };

    /* finalise the bootinfo frame */
    bi_finalise();

    /* make everything written by the kernel visible to userland. Cleaning to PoC is not
     * strictly neccessary, but performance is not critical here so clean and invalidate
     * everything to PoC */
    cleanInvalidateL1Caches();
    invalidateLocalTLB();
    if (1) {
        invalidateHypTLB();
    }


    ksNumCPUs = 1;

    /* initialize BKL before booting up other cores */
    ;
    ;

    /* grab BKL before leaving the kernel */
    do {} while (0);

    kprintf("Booting all finished, dropped to user space\n");

    /* kernel successfully initialized */
    return true;
}

__attribute__((__section__(".boot.text"))) __attribute__((externally_visible)) void
init_kernel(
    paddr_t ui_p_reg_start,
    paddr_t ui_p_reg_end,
    sword_t pv_offset,
    vptr_t v_entry
)
{
    bool_t result;
# 553 "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c"
    result = try_init_kernel(ui_p_reg_start,
                             ui_p_reg_end,
                             pv_offset,
                             v_entry);



    if (!result) {
        _fail("Kernel init failed for some reason :(", "/home/sel4/work/work2/kernel/src/arch/arm/kernel/boot.c", 561, __func__);
    }

    schedule();
    activateThread();
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/machine/cache.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/machine/cache.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/machine/cache.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/machine/cache.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/l2c_310.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/*
 * ARM L2 Cache controller L2C-310
 */




# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/l2c_310.h" 2


void initL2Cache(void);

void plat_cleanInvalidateCache(void);
void plat_cleanCache(void);
void plat_cleanL2Range(paddr_t start, paddr_t end);
void plat_invalidateL2Range(paddr_t start, paddr_t end);
void plat_cleanInvalidateL2Range(paddr_t start, paddr_t end);
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/machine/cache.c" 2





static void
cleanCacheRange_PoC(vptr_t start, vptr_t end, paddr_t pstart)
{
    vptr_t line;
    word_t index;

    for (index = ((((start) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */); index < ((((end) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */) + 1; index++) {
        line = index << 6 /* 64 bytes */;
        cleanByVA(line, pstart + (line - start));
    }
}

void
cleanInvalidateCacheRange_RAM(vptr_t start, vptr_t end, paddr_t pstart)
{
    vptr_t line;
    word_t index;
    /** GHOSTUPD: "((gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
            \<or> \<acute>end - \<acute>start <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state)
        \<and> \<acute>start <= \<acute>end, id)" */

    /* First clean the L1 range */
    cleanCacheRange_PoC(start, end, pstart);

    /* ensure operation completes and visible in L2 */
    dsb();

    /* Now clean and invalidate the L2 range */
    plat_cleanInvalidateL2Range(pstart, pstart + (end - start));

    /* Finally clean and invalidate the L1 range. The extra clean is only strictly neccessary
     * in a multiprocessor environment to prevent a write being lost if another core is
     * attempting a store at the same time. As the range should already be clean asking
     * it to clean again should not affect performance */
    for (index = ((((start) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */); index < ((((end) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */) + 1; index++) {
        line = index << 6 /* 64 bytes */;
        cleanInvalByVA(line, pstart + (line - start));
    }
    /* ensure clean and invalidate complete */
    dsb();
}

void
cleanCacheRange_RAM(vptr_t start, vptr_t end, paddr_t pstart)
{
    /** GHOSTUPD: "((gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
            \<or> \<acute>end - \<acute>start <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state)
        \<and> \<acute>start <= \<acute>end
        \<and> \<acute>pstart <= \<acute>pstart + (\<acute>end - \<acute>start), id)" */

    /* clean l1 to l2 */
    cleanCacheRange_PoC(start, end, pstart);

    /* ensure cache operation completes before cleaning l2 */
    dsb();

    /** GHOSTUPD: "((gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
            \<or> \<acute>end - \<acute>start <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state)
        \<and> \<acute>start <= \<acute>end
        \<and> \<acute>pstart <= \<acute>pstart + (\<acute>end - \<acute>start), id)" */

    /* now clean l2 to RAM */
    plat_cleanL2Range(pstart, pstart + (end - start));
}

void
cleanCacheRange_PoU(vptr_t start, vptr_t end, paddr_t pstart)
{
    vptr_t line;
    word_t index;

    /** GHOSTUPD: "((gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
            \<or> \<acute>end - \<acute>start <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state)
        \<and> \<acute>start <= \<acute>end
        \<and> \<acute>pstart <= \<acute>pstart + (\<acute>end - \<acute>start), id)" */

    for (index = ((((start) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */); index < ((((end) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */) + 1; index++) {
        line = index << 6 /* 64 bytes */;
        cleanByVA_PoU(line, pstart + (line - start));
    }
}

void
invalidateCacheRange_RAM(vptr_t start, vptr_t end, paddr_t pstart)
{
    vptr_t line;
    word_t index;

    /* If the start and end are not aligned to a cache line boundary
     * then we need to clean the line first to prevent invalidating
     * bytes we didn't mean to. Calling the functions in this way is
     * not the most efficient method, but we assume the user will
     * rarely be this silly */
    if (start != (((start) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))) {
        cleanCacheRange_RAM(start, start, pstart);
    }
    if (end + 1 != (((end + 1) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))) {
        line = (((end) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */));
        cleanCacheRange_RAM(line, line, pstart + (line - start));
    }

    /** GHOSTUPD: "((gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
            \<or> \<acute>end - \<acute>start <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state)
        \<and> \<acute>start <= \<acute>end
        \<and> \<acute>pstart <= \<acute>pstart + (\<acute>end - \<acute>start), id)" */

    /* Invalidate L2 range. Invalidating the L2 before the L1 is the order
     * given in the l2c_310 manual, as an L1 line might be allocated from the L2
     * before the L2 can be invalidated. */
    plat_invalidateL2Range(pstart, pstart + (end - start));

    /** GHOSTUPD: "((gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
            \<or> \<acute>end - \<acute>start <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state)
        \<and> \<acute>start <= \<acute>end
        \<and> \<acute>pstart <= \<acute>pstart + (\<acute>end - \<acute>start), id)" */

    /* Now invalidate L1 range */
    for (index = ((((start) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */); index < ((((end) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */) + 1; index++) {
        line = index << 6 /* 64 bytes */;
        invalidateByVA(line, pstart + (line - start));
    }
    /* Ensure invalidate completes */
    dsb();
}

void
invalidateCacheRange_I(vptr_t start, vptr_t end, paddr_t pstart)
{
    vptr_t line;
    word_t index;

    for (index = ((((start) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */); index < ((((end) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */) + 1; index++) {
        line = index << 6 /* 64 bytes */;
        invalidateByVA_I(line, pstart + (line - start));
    }
}

void
branchFlushRange(vptr_t start, vptr_t end, paddr_t pstart)
{
    vptr_t line;
    word_t index;

    for (index = ((((start) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */); index < ((((end) >> (6 /* 64 bytes */)) << (6 /* 64 bytes */))>>6 /* 64 bytes */) + 1; index++) {
        line = index << 6 /* 64 bytes */;
        branchFlush(line, pstart + (line - start));
    }
}

void
cleanCaches_PoU(void)
{
    dsb();
    clean_D_PoU();
    dsb();
    invalidate_I_PoU();
    dsb();
}

void
cleanInvalidateL1Caches(void)
{
    dsb();
    cleanInvalidate_D_PoC();
    dsb();
    invalidate_I_PoU();
    dsb();
}

void
arch_clean_invalidate_caches(void)
{
    cleanCaches_PoU();
    plat_cleanInvalidateCache();
    cleanInvalidateL1Caches();
    isb();
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c" 2
# 179 "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c"
/** Generates read functions for the CP14 control and value registers.
 */
# 240 "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c"
/** Generates write functions for the CP14 control and value registers.
 */
# 299 "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c"
static word_t readBcrCp(uint16_t bp_num) { word_t ret; switch (bp_num) { case 1: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "1" ", " "5" : "=r"(ret)); return ret; case 2: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "2" ", " "5" : "=r"(ret)); return ret; case 3: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "3" ", " "5" : "=r"(ret)); return ret; case 4: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "4" ", " "5" : "=r"(ret)); return ret; case 5: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "5" ", " "5" : "=r"(ret)); return ret; case 6: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "6" ", " "5" : "=r"(ret)); return ret; case 7: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "7" ", " "5" : "=r"(ret)); return ret; case 8: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "8" ", " "5" : "=r"(ret)); return ret; case 9: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "9" ", " "5" : "=r"(ret)); return ret; case 10: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "10" ", " "5" : "=r"(ret)); return ret; case 11: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "11" ", " "5" : "=r"(ret)); return ret; case 12: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "12" ", " "5" : "=r"(ret)); return ret; case 13: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "13" ", " "5" : "=r"(ret)); return ret; case 14: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "14" ", " "5" : "=r"(ret)); return ret; case 15: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "15" ", " "5" : "=r"(ret)); return ret; default: if(!(bp_num == 0)) _assert_fail("bp_num == 0", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 299, __FUNCTION__); __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "0" ", " "5" : "=r"(ret)); return ret; } }
static word_t readBvrCp(uint16_t bp_num) { word_t ret; switch (bp_num) { case 1: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "1" ", " "4" : "=r"(ret)); return ret; case 2: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "2" ", " "4" : "=r"(ret)); return ret; case 3: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "3" ", " "4" : "=r"(ret)); return ret; case 4: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "4" ", " "4" : "=r"(ret)); return ret; case 5: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "5" ", " "4" : "=r"(ret)); return ret; case 6: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "6" ", " "4" : "=r"(ret)); return ret; case 7: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "7" ", " "4" : "=r"(ret)); return ret; case 8: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "8" ", " "4" : "=r"(ret)); return ret; case 9: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "9" ", " "4" : "=r"(ret)); return ret; case 10: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "10" ", " "4" : "=r"(ret)); return ret; case 11: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "11" ", " "4" : "=r"(ret)); return ret; case 12: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "12" ", " "4" : "=r"(ret)); return ret; case 13: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "13" ", " "4" : "=r"(ret)); return ret; case 14: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "14" ", " "4" : "=r"(ret)); return ret; case 15: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "15" ", " "4" : "=r"(ret)); return ret; default: if(!(bp_num == 0)) _assert_fail("bp_num == 0", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 300, __FUNCTION__); __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "0" ", " "4" : "=r"(ret)); return ret; } }
static word_t readWcrCp(uint16_t bp_num) { word_t ret; switch (bp_num) { case 1: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "1" ", " "7" : "=r"(ret)); return ret; case 2: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "2" ", " "7" : "=r"(ret)); return ret; case 3: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "3" ", " "7" : "=r"(ret)); return ret; case 4: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "4" ", " "7" : "=r"(ret)); return ret; case 5: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "5" ", " "7" : "=r"(ret)); return ret; case 6: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "6" ", " "7" : "=r"(ret)); return ret; case 7: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "7" ", " "7" : "=r"(ret)); return ret; case 8: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "8" ", " "7" : "=r"(ret)); return ret; case 9: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "9" ", " "7" : "=r"(ret)); return ret; case 10: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "10" ", " "7" : "=r"(ret)); return ret; case 11: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "11" ", " "7" : "=r"(ret)); return ret; case 12: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "12" ", " "7" : "=r"(ret)); return ret; case 13: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "13" ", " "7" : "=r"(ret)); return ret; case 14: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "14" ", " "7" : "=r"(ret)); return ret; case 15: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "15" ", " "7" : "=r"(ret)); return ret; default: if(!(bp_num == 0)) _assert_fail("bp_num == 0", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 301, __FUNCTION__); __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "0" ", " "7" : "=r"(ret)); return ret; } }
static word_t readWvrCp(uint16_t bp_num) { word_t ret; switch (bp_num) { case 1: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "1" ", " "6" : "=r"(ret)); return ret; case 2: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "2" ", " "6" : "=r"(ret)); return ret; case 3: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "3" ", " "6" : "=r"(ret)); return ret; case 4: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "4" ", " "6" : "=r"(ret)); return ret; case 5: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "5" ", " "6" : "=r"(ret)); return ret; case 6: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "6" ", " "6" : "=r"(ret)); return ret; case 7: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "7" ", " "6" : "=r"(ret)); return ret; case 8: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "8" ", " "6" : "=r"(ret)); return ret; case 9: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "9" ", " "6" : "=r"(ret)); return ret; case 10: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "10" ", " "6" : "=r"(ret)); return ret; case 11: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "11" ", " "6" : "=r"(ret)); return ret; case 12: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "12" ", " "6" : "=r"(ret)); return ret; case 13: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "13" ", " "6" : "=r"(ret)); return ret; case 14: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "14" ", " "6" : "=r"(ret)); return ret; case 15: __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "15" ", " "6" : "=r"(ret)); return ret; default: if(!(bp_num == 0)) _assert_fail("bp_num == 0", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 302, __FUNCTION__); __asm__ volatile("mrc  " "p14, 0, %0, c" "0" ", c" "0" ", " "6" : "=r"(ret)); return ret; } }
static void writeBcrCp(uint16_t bp_num, word_t val) { switch (bp_num) { case 1: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "1" ", " "5" :: "r" (_v)); }while(0); return; case 2: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "2" ", " "5" :: "r" (_v)); }while(0); return; case 3: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "3" ", " "5" :: "r" (_v)); }while(0); return; case 4: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "4" ", " "5" :: "r" (_v)); }while(0); return; case 5: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "5" ", " "5" :: "r" (_v)); }while(0); return; case 6: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "6" ", " "5" :: "r" (_v)); }while(0); return; case 7: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "7" ", " "5" :: "r" (_v)); }while(0); return; case 8: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "8" ", " "5" :: "r" (_v)); }while(0); return; case 9: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "9" ", " "5" :: "r" (_v)); }while(0); return; case 10: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "10" ", " "5" :: "r" (_v)); }while(0); return; case 11: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "11" ", " "5" :: "r" (_v)); }while(0); return; case 12: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "12" ", " "5" :: "r" (_v)); }while(0); return; case 13: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "13" ", " "5" :: "r" (_v)); }while(0); return; case 14: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "14" ", " "5" :: "r" (_v)); }while(0); return; case 15: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "15" ", " "5" :: "r" (_v)); }while(0); return; default: if(!(bp_num == 0)) _assert_fail("bp_num == 0", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 303, __FUNCTION__); do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "0" ", " "5" :: "r" (_v)); }while(0); return; } }
static void writeBvrCp(uint16_t bp_num, word_t val) { switch (bp_num) { case 1: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "1" ", " "4" :: "r" (_v)); }while(0); return; case 2: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "2" ", " "4" :: "r" (_v)); }while(0); return; case 3: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "3" ", " "4" :: "r" (_v)); }while(0); return; case 4: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "4" ", " "4" :: "r" (_v)); }while(0); return; case 5: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "5" ", " "4" :: "r" (_v)); }while(0); return; case 6: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "6" ", " "4" :: "r" (_v)); }while(0); return; case 7: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "7" ", " "4" :: "r" (_v)); }while(0); return; case 8: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "8" ", " "4" :: "r" (_v)); }while(0); return; case 9: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "9" ", " "4" :: "r" (_v)); }while(0); return; case 10: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "10" ", " "4" :: "r" (_v)); }while(0); return; case 11: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "11" ", " "4" :: "r" (_v)); }while(0); return; case 12: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "12" ", " "4" :: "r" (_v)); }while(0); return; case 13: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "13" ", " "4" :: "r" (_v)); }while(0); return; case 14: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "14" ", " "4" :: "r" (_v)); }while(0); return; case 15: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "15" ", " "4" :: "r" (_v)); }while(0); return; default: if(!(bp_num == 0)) _assert_fail("bp_num == 0", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 304, __FUNCTION__); do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "0" ", " "4" :: "r" (_v)); }while(0); return; } }
static void writeWcrCp(uint16_t bp_num, word_t val) { switch (bp_num) { case 1: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "1" ", " "7" :: "r" (_v)); }while(0); return; case 2: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "2" ", " "7" :: "r" (_v)); }while(0); return; case 3: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "3" ", " "7" :: "r" (_v)); }while(0); return; case 4: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "4" ", " "7" :: "r" (_v)); }while(0); return; case 5: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "5" ", " "7" :: "r" (_v)); }while(0); return; case 6: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "6" ", " "7" :: "r" (_v)); }while(0); return; case 7: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "7" ", " "7" :: "r" (_v)); }while(0); return; case 8: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "8" ", " "7" :: "r" (_v)); }while(0); return; case 9: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "9" ", " "7" :: "r" (_v)); }while(0); return; case 10: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "10" ", " "7" :: "r" (_v)); }while(0); return; case 11: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "11" ", " "7" :: "r" (_v)); }while(0); return; case 12: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "12" ", " "7" :: "r" (_v)); }while(0); return; case 13: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "13" ", " "7" :: "r" (_v)); }while(0); return; case 14: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "14" ", " "7" :: "r" (_v)); }while(0); return; case 15: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "15" ", " "7" :: "r" (_v)); }while(0); return; default: if(!(bp_num == 0)) _assert_fail("bp_num == 0", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 305, __FUNCTION__); do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "0" ", " "7" :: "r" (_v)); }while(0); return; } }
static void writeWvrCp(uint16_t bp_num, word_t val) { switch (bp_num) { case 1: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "1" ", " "6" :: "r" (_v)); }while(0); return; case 2: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "2" ", " "6" :: "r" (_v)); }while(0); return; case 3: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "3" ", " "6" :: "r" (_v)); }while(0); return; case 4: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "4" ", " "6" :: "r" (_v)); }while(0); return; case 5: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "5" ", " "6" :: "r" (_v)); }while(0); return; case 6: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "6" ", " "6" :: "r" (_v)); }while(0); return; case 7: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "7" ", " "6" :: "r" (_v)); }while(0); return; case 8: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "8" ", " "6" :: "r" (_v)); }while(0); return; case 9: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "9" ", " "6" :: "r" (_v)); }while(0); return; case 10: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "10" ", " "6" :: "r" (_v)); }while(0); return; case 11: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "11" ", " "6" :: "r" (_v)); }while(0); return; case 12: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "12" ", " "6" :: "r" (_v)); }while(0); return; case 13: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "13" ", " "6" :: "r" (_v)); }while(0); return; case 14: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "14" ", " "6" :: "r" (_v)); }while(0); return; case 15: do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "15" ", " "6" :: "r" (_v)); }while(0); return; default: if(!(bp_num == 0)) _assert_fail("bp_num == 0", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 306, __FUNCTION__); do { word_t _v = val; __asm__ volatile("mcr  " "p14, 0, %0, c" "0" ", c" "0" ", " "6" :: "r" (_v)); }while(0); return; } }

/* These next few functions (read*Context()/write*Context()) read from TCB
 * context and not from the hardware registers.
 */
static word_t
readBcrContext(tcb_t *t, uint16_t index)
{
    if(!(index < (6))) _assert_fail("index < seL4_NumExclusiveBreakpoints", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 314, __FUNCTION__);
    return t->tcbArch.tcbContext.breakpointState.breakpoint[index].cr;
}

static word_t
readBvrContext(tcb_t *t, uint16_t index)
{
    if(!(index < (6))) _assert_fail("index < seL4_NumExclusiveBreakpoints", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 321, __FUNCTION__);
    return t->tcbArch.tcbContext.breakpointState.breakpoint[index].vr;
}

static word_t
readWcrContext(tcb_t *t, uint16_t index)
{
    if(!(index < (4))) _assert_fail("index < seL4_NumExclusiveWatchpoints", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 328, __FUNCTION__);
    return t->tcbArch.tcbContext.breakpointState.watchpoint[index].cr;
}

static word_t
readWvrContext(tcb_t *t, uint16_t index)
{
    if(!(index < (4))) _assert_fail("index < seL4_NumExclusiveWatchpoints", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 335, __FUNCTION__);
    return t->tcbArch.tcbContext.breakpointState.watchpoint[index].vr;
}

static void
writeBcrContext(tcb_t *t, uint16_t index, word_t val)
{
    if(!(index < (6))) _assert_fail("index < seL4_NumExclusiveBreakpoints", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 342, __FUNCTION__);
    t->tcbArch.tcbContext.breakpointState.breakpoint[index].cr = val;
}

static void
writeBvrContext(tcb_t *t, uint16_t index, word_t val)
{
    if(!(index < (6))) _assert_fail("index < seL4_NumExclusiveBreakpoints", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 349, __FUNCTION__);
    t->tcbArch.tcbContext.breakpointState.breakpoint[index].vr = val;
}

static void
writeWcrContext(tcb_t *t, uint16_t index, word_t val)
{
    if(!(index < (4))) _assert_fail("index < seL4_NumExclusiveWatchpoints", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 356, __FUNCTION__);
    t->tcbArch.tcbContext.breakpointState.watchpoint[index].cr = val;
}

static void
writeWvrContext(tcb_t *t, uint16_t index, word_t val)
{
    if(!(index < (4))) _assert_fail("index < seL4_NumExclusiveWatchpoints", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 363, __FUNCTION__);
    t->tcbArch.tcbContext.breakpointState.watchpoint[index].vr = val;
}
# 1193 "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c"
/** Mirrors Arch_initFpuContext.
 *
 * Zeroes out the BVR thread context and preloads reserved bit values from the
 * control regs into the thread context so we can operate solely on the values
 * cached in RAM in API calls, rather than retrieving the values from the
 * coprocessor.
 */
void
Arch_initBreakpointContext(user_context_t *uc)
{
    uc->breakpointState = armKSNullBreakpointState;
}

void
loadAllDisabledBreakpointState(void)
{
    int i;

    /* We basically just want to read-modify-write each reg to ensure its
     * "ENABLE" bit is clear. We did preload the register context with the
     * reserved values from the control registers, so we can read our
     * initial values from either the coprocessor or the thread's register
     * context.
     *
     * Both are perfectly fine, and the only discriminant factor is performance.
     * I suspect that reading from RAM is faster than reading from the
     * coprocessor, but I can't be sure.
     */
    for (i = 0; i < (6); i++) {
        writeBcrCp(i, readBcrCp(i) & ~((1ul << (0))));
    }
    for (i = 0; i < (4); i++) {
        writeWcrCp(i, readWcrCp(i) & ~((1ul << (0))));
    }
}

/* We only need to save the breakpoint state in the hypervisor
 * build, and only for threads that have an associated VCPU.
 *
 * When the normal kernel is running with the debug API, all
 * changes to the debug regs are done through the debug API.
 * In the hypervisor build, the guest VM has full access to the
 * debug regs in PL1, so we need to save its values on vmexit.
 *
 * When saving the debug regs we will always save all of them.
 * When restoring, we will restore only those that have been used
 * for native threads; and we will restore all of them
 * unconditionally for VCPUs (because we don't know which of
 * them have been changed by the guest).
 *
 * To ensure that all the debug regs are restored unconditionally,
 * we just set the "used_breakpoints_bf" bitfield to all 1s in
 * associateVcpu.
 */
void
saveAllBreakpointState(tcb_t *t)
{
    int i;

    if(!(t != ((void *)0))) _assert_fail("t != NULL", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 1252, __FUNCTION__);

    for (i = 0; i < (6); i++) {
        writeBvrContext(t, i, readBvrCp(i));
        writeBcrContext(t, i, readBcrCp(i));
    }

    for (i = 0; i < (4); i++) {
        writeWvrContext(t, i, readWvrCp(i));
        writeWcrContext(t, i, readWcrCp(i));
    }
}


void
Arch_debugAssociateVCPUTCB(tcb_t *t)
{
    /* Don't attempt to shift beyond end of word. */
    if(!((10) < sizeof(word_t) * 8)) _assert_fail("seL4_NumHWBreakpoints < sizeof(word_t) * 8", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 1270, __FUNCTION__);

    /* Set all the bits to 1, so loadBreakpointState() will
     * restore all the debug regs unconditionally.
     */
    t->tcbArch.tcbContext.breakpointState.used_breakpoints_bf = ((1ul << ((10)))-1ul);
}

void
Arch_debugDissociateVCPUTCB(tcb_t *t)
{
    t->tcbArch.tcbContext.breakpointState.used_breakpoints_bf = 0;
}


static void
loadBreakpointState(tcb_t *t)
{
    int i;

    if(!(t != ((void *)0))) _assert_fail("t != NULL", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 1290, __FUNCTION__);

    for (i = 0; i < (6); i++) {
        if (t->tcbArch.tcbContext.breakpointState.used_breakpoints_bf & (1ul << (i))) {
            writeBvrCp(i, readBvrContext(t, i));
            writeBcrCp(i, readBcrContext(t, i));
        } else {
            /* If the thread isn't using the BP, then just load
             * a default "disabled" state.
             */
            writeBcrCp(i, readBcrCp(i) & ~((1ul << (0))));
        }
    }

    for (i = 0; i < (4); i++) {
        if (t->tcbArch.tcbContext.breakpointState.used_breakpoints_bf &
                (1ul << (i + (6)))) {
            writeWvrCp(i, readWvrContext(t, i));
            writeWcrCp(i, readWcrContext(t, i));
        } else {
            writeWcrCp(i, readWcrCp(i) & ~((1ul << (0))));
        }
    }
}

/** Pops debug register context for a thread into the CPU.
 *
 * Mirrors the idea of restore_user_context.
 */
void
restore_user_debug_context(tcb_t *target_thread)
{
    if(!(target_thread != ((void *)0))) _assert_fail("target_thread != NULL", "/home/sel4/work/work2/kernel/src/arch/arm/machine/debug.c", 1322, __FUNCTION__);

    if (target_thread->tcbArch.tcbContext.breakpointState.used_breakpoints_bf == 0) {
        loadAllDisabledBreakpointState();
    } else {
        loadBreakpointState(target_thread);
    }

    /* ARMv6 manual, sec D3.3.7:
     * "The update of a BVR or a BCR is only guaranteed to be visible to
     * subsequent instructions after the execution of a PrefetchFlush operation,
     * the taking of an exception, or the return from an exception."
     *
     * So we don't need to execute ISB here because we're about to RFE.
     */
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/machine/errata.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/machine/errata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/machine/errata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/machine/errata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/machine/errata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/machine/errata.c" 2

/* Prototyped here as this is referenced from assembly */
void arm_errata(void);
# 49 "/home/sel4/work/work2/kernel/src/arch/arm/machine/errata.c"
/*
 * There is an errata for Cortex-A15 up to r0p4 where the loop buffer
 * may deliver incorrect instructions. The work around is to disable
 * the loop buffer. Errata is number 773022.
 */
__attribute__((__section__(".boot.text"))) static void errata_armA15_773022(void)
{
    /* Fetch the processor primary part number. */
    uint32_t proc_id = getProcessorID();
    uint32_t variant = (proc_id >> 20) & ((1ul << (4))-1ul);
    uint32_t revision = proc_id & ((1ul << (4))-1ul);
    uint32_t part = (proc_id >> 4) & ((1ul << (12))-1ul);

    /* Check that we are running A15 and a revision upto r0p4. */
    if (part == 0xc0f && variant == 0 && revision <= 4) {
        /* Disable loop buffer in the auxiliary control register */
        writeAuxiliaryControlRegister(
            readAuxiliaryControlRegister() | (1ul << (1)));
    }
}


__attribute__((__section__(".boot.text"))) void __attribute__((externally_visible)) arm_errata(void)
{




    errata_armA15_773022();

}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/machine/gic_pl390.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/machine/gic_pl390.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/gic_pl390.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/*
 * ARM Generic Interrupt Controller PL-390
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/machine/gic_pl390.c" 2
# 23 "/home/sel4/work/work2/kernel/src/arch/arm/machine/gic_pl390.c"
/* Shift positions for GICD_SGIR register */







volatile struct gic_dist_map * const gic_dist =
    (volatile struct gic_dist_map*)(0xfff04000);





volatile struct gic_cpu_iface_map * const gic_cpuiface =
    (volatile struct gic_cpu_iface_map*)(0xfff05000);


uint32_t active_irq[1] = {1023u};

__attribute__((__section__(".boot.text"))) static void
dist_init(void)
{
    word_t i;
    int nirqs = 32 * ((gic_dist->ic_type & 0x1f) + 1);
    gic_dist->enable = 0;

    for (i = 0; i < nirqs; i += 32) {
        /* disable */
        gic_dist->enable_clr[i >> 5] = 0xffffffff;;
        /* clear pending */
        gic_dist->pending_clr[i >> 5] = 0xffffffff;;
    }

    /* reset interrupts priority */
    for (i = 32; i < nirqs; i += 4) {
        if (1) {
            gic_dist->priority[i >> 2] = 0x80808080;
        } else {
            gic_dist->priority[i >> 2] = 0;
        }
    }

    /*
     * reset int target to cpu 0
     * (Should really query which processor we're running on and use that)
     */
    for (i = 0; i < nirqs; i += 4) {
        gic_dist->targets[i >> 2] = ( ( (((1ul << (0)))&0xff)<<0u ) | ( (((1ul << (0)))&0xff)<<8u ) | ( (((1ul << (0)))&0xff)<<16u ) | ( (((1ul << (0)))&0xff)<<24u ) );
    }

    /* level-triggered, 1-N */
    for (i = 64; i < nirqs; i += 32) {
        gic_dist->config[i >> 5] = 0x55555555;
    }

    /* group 0 for secure; group 1 for non-secure */
    for (i = 0; i < nirqs; i += 32) {
        if (1) {
            gic_dist->security[i >> 5] = 0xffffffff;
        } else {
            gic_dist->security[i >> 5] = 0;
        }
    }
    /* enable the int controller */
    gic_dist->enable = 1;
}

__attribute__((__section__(".boot.text"))) static void
cpu_iface_init(void)
{
    uint32_t i;

    /* For non-Exynos4, the registers are banked per CPU, need to clear them */
    gic_dist->enable_clr[0] = 0xffffffff;;
    gic_dist->pending_clr[0] = 0xffffffff;;

    /* put everything in group 0; group 1 if in hyp mode */
    if (1) {
        gic_dist->security[0] = 0xffffffff;
        gic_dist->priority[0] = 0x80808080;
    } else {
        gic_dist->security[0] = 0;
        gic_dist->priority[0] = 0x0;
    }

    /* clear any software generated interrupts */
    for (i = 0; i < 16; i += 4) {
        gic_dist->sgi_pending_clr[i >> 2] = 0xffffffff;;
    }

    gic_cpuiface->icontrol = 0;
    /* the write to priority mask is ignored if the kernel is
     * in non-secure mode and the priority mask is already configured
     * by secure mode software. the elfloader should config the
     * interrupt routing properly to ensure that the hyp-mode kernel
     * can get interrupts
     */
    gic_cpuiface->pri_msk_c = 0x000000f0;
    gic_cpuiface->pb_c = 0x00000003;

    i = gic_cpuiface->int_ack;
    while ((i & ((1ul << (10u))-1ul)) != 1023u) {
        gic_cpuiface->eoi = i;
        i = gic_cpuiface->int_ack;
    }
    gic_cpuiface->icontrol = 1;
}

__attribute__((__section__(".boot.text"))) void
initIRQController(void)
{
    dist_init();
}

__attribute__((__section__(".boot.text"))) void cpu_initLocalIRQController(void)
{
    cpu_iface_init();
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/machine/io.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/machine/io.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/machine/io.c" 2


void
putConsoleChar(unsigned char c)
{
    putDebugChar(c);
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/object/interrupt.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/object/interrupt.c" 2

# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/object/interrupt.c" 2

exception_t
Arch_decodeIRQControlInvocation(word_t invLabel, word_t length,
                                cte_t *srcSlot, extra_caps_t excaps,
                                word_t *buffer)
{
    current_syscall_error.type = seL4_IllegalOperation;
    return EXCEPTION_SYSCALL_ERROR;
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/object/iospace.c"
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/object/iospace.c" 2
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/object/tcb.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/arch/arm/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/constants.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/object/tcb.c" 2

word_t __attribute__((__const__))
Arch_decodeTransfer(word_t flags)
{
    return 0;
}

exception_t __attribute__((__const__))
Arch_performTransfer(word_t arch, tcb_t *tcb_src, tcb_t *tcb_dest)
{
    return EXCEPTION_NONE;
}
# 44 "/home/sel4/work/work2/kernel/src/arch/arm/object/tcb.c"
void
Arch_setTCBIPCBuffer(tcb_t *thread, word_t bufferAddr)
{


    setRegister(thread, TPIDRURW, bufferAddr);



}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c" 2



# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/vcpu.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/devices.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine/debug_conf.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c" 2
# 50 "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c"
/* Trap WFI/WFE/SMC and override CPSR.AIF */


/* Allow native tasks to run at PL1, but restrict access */




/* Amongst other things we set the caches to enabled by default. This
 * may cause problems when booting guests that expect caches to be
 * disabled */
# 85 "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c"
struct gich_vcpu_ctrl_map {
    uint32_t hcr; /* 0x000 RW 0x00000000 Hypervisor Control Register */
    uint32_t vtr; /* 0x004 RO IMPLEMENTATION DEFINED VGIC Type Register */
    /* Save restore on VCPU switch */
    uint32_t vmcr; /* 0x008 RW IMPLEMENTATION DEFINED Virtual Machine Control Register */
    uint32_t res1[1];
    /* IRQ pending flags */
    uint32_t misr; /* 0x010 RO 0x00000000 Maintenance Interrupt Status Register */
    uint32_t res2[3];
    /* Bitfield of list registers that have EOI */
    uint32_t eisr0; /* 0x020 RO 0x00000000 End of Interrupt Status Registers 0 and 1, see EISRn */
    uint32_t eisr1; /* 0x024 RO 0x00000000 */
    uint32_t res3[2];
    /* Bitfield of list registers that are empty */
    uint32_t elsr0; /* 0x030 RO IMPLEMENTATION DEFINED a */
    uint32_t elsr1; /* 0x034 RO IMPLEMENTATION DEFINED a Empty List Register Status Registers 0 and 1, see ELRSRn */
    uint32_t res4[46];
    /* Active priority: bitfield of active priorities */
    uint32_t apr; /* 0x0F0 RW 0x00000000 Active Priorities Register */
    uint32_t res5[3];
    uint32_t lr[64]; /* 0x100 RW 0x00000000 List Registers 0-63, see LRn */
};




static volatile struct gich_vcpu_ctrl_map *gic_vcpu_ctrl =
    (volatile struct gich_vcpu_ctrl_map*)(0xfff06000);


static unsigned int gic_vcpu_num_list_regs;

static inline word_t
get_lr_svc(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], lr_svc" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_lr_svc(word_t val)
{
    __asm__ ("msr lr_svc, %[val]" :: [val]"r"(val));
}

static inline word_t
get_sp_svc(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], sp_svc" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_sp_svc(word_t val)
{
    __asm__ ("msr sp_svc, %[val]" :: [val]"r"(val));
}

static inline word_t
get_lr_abt(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], lr_abt" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_lr_abt(word_t val)
{
    __asm__ ("msr lr_abt, %[val]" :: [val]"r"(val));
}

static inline word_t
get_sp_abt(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], sp_abt" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_sp_abt(word_t val)
{
    __asm__ ("msr sp_abt, %[val]" :: [val]"r"(val));
}

static inline word_t
get_lr_und(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], lr_und" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_lr_und(word_t val)
{
    __asm__ ("msr lr_und, %[val]" :: [val]"r"(val));
}

static inline word_t
get_sp_und(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], sp_und" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_sp_und(word_t val)
{
    __asm__ ("msr sp_und, %[val]" :: [val]"r"(val));
}

static inline word_t
get_lr_irq(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], lr_irq" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_lr_irq(word_t val)
{
    __asm__ ("msr lr_irq, %[val]" :: [val]"r"(val));
}

static inline word_t
get_sp_irq(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], sp_irq" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_sp_irq(word_t val)
{
    __asm__ ("msr sp_irq, %[val]" :: [val]"r"(val));
}

static inline word_t
get_lr_fiq(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], lr_fiq" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_lr_fiq(word_t val)
{
    __asm__ ("msr lr_fiq, %[val]" :: [val]"r"(val));
}

static inline word_t
get_sp_fiq(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], sp_fiq" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_sp_fiq(word_t val)
{
    __asm__ ("msr sp_fiq, %[val]" :: [val]"r"(val));
}

static inline word_t
get_r8_fiq(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], r8_fiq" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_r8_fiq(word_t val)
{
    __asm__ ("msr r8_fiq, %[val]" :: [val]"r"(val));
}

static inline word_t
get_r9_fiq(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], r9_fiq" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_r9_fiq(word_t val)
{
    __asm__ ("msr r9_fiq, %[val]" :: [val]"r"(val));
}

static inline word_t
get_r10_fiq(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], r10_fiq" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_r10_fiq(word_t val)
{
    __asm__ ("msr r10_fiq, %[val]" :: [val]"r"(val));
}

static inline word_t
get_r11_fiq(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], r11_fiq" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_r11_fiq(word_t val)
{
    __asm__ ("msr r11_fiq, %[val]" :: [val]"r"(val));
}

static inline word_t
get_r12_fiq(void)
{
    word_t ret;
    __asm__ ("mrs %[ret], r12_fiq" : [ret]"=r"(ret));
    return ret;
}

static inline void
set_r12_fiq(word_t val)
{
    __asm__ ("msr r12_fiq, %[val]" :: [val]"r"(val));
}

static inline uint32_t
get_gic_vcpu_ctrl_hcr(void)
{
    return gic_vcpu_ctrl->hcr;
}

static inline void
set_gic_vcpu_ctrl_hcr(uint32_t hcr)
{
    gic_vcpu_ctrl->hcr = hcr;
}

static inline uint32_t
get_gic_vcpu_ctrl_vmcr(void)
{
    return gic_vcpu_ctrl->vmcr;
}

static inline void
set_gic_vcpu_ctrl_vmcr(uint32_t vmcr)
{
    gic_vcpu_ctrl->vmcr = vmcr;
}

static inline uint32_t
get_gic_vcpu_ctrl_apr(void)
{
    return gic_vcpu_ctrl->apr;
}

static inline void
set_gic_vcpu_ctrl_apr(uint32_t apr)
{
    gic_vcpu_ctrl->apr = apr;
}

static inline uint32_t
get_gic_vcpu_ctrl_vtr(void)
{
    return gic_vcpu_ctrl->vtr;
}

static inline uint32_t
get_gic_vcpu_ctrl_eisr0(void)
{
    return gic_vcpu_ctrl->eisr0;
}

static inline uint32_t
get_gic_vcpu_ctrl_eisr1(void)
{
    return gic_vcpu_ctrl->eisr1;
}

static inline uint32_t
get_gic_vcpu_ctrl_misr(void)
{
    return gic_vcpu_ctrl->misr;
}

static inline virq_t
get_gic_vcpu_ctrl_lr(int num)
{
    virq_t virq;
    virq.words[0] = gic_vcpu_ctrl->lr[num];
    return virq;
}

static inline void
set_gic_vcpu_ctrl_lr(int num, virq_t lr)
{
    gic_vcpu_ctrl->lr[num] = lr.words[0];
}

static void
vcpu_enable(vcpu_t *vcpu)
{
    setSCTLR(vcpu->cpx.sctlr);
    setHCR((( (1ul << (19)) /* Trap SMC instructions          */ | (1ul << (14)) /* Trap WFE                       */ | (1ul << (13)) /* Trap WFI                       */ | (1ul << (5)) /* CPSR.A override enable         */ | (1ul << (4)) /* CPSR.I override enable         */ | (1ul << (3)) /* CPSR.F override enable         */ | (1ul << (12)) /* Default cacheable              */ | (1ul << (0)) /* Virtualization MMU enable      */)));
    isb();

    /* Turn on the VGIC */
    set_gic_vcpu_ctrl_hcr(vcpu->vgic.hcr);


    /* This is guarded by an #ifNdef (negation) ARM_CP14_SAVE_AND_RESTORE_NATIVE_THREADS
     * because if it wasn't, we'd be calling restore_user_debug_context twice
     * on a debug-API build; recall that restore_user_debug_context is called
     * in restore_user_context.
     *
     * We call restore_user_debug_context here, because vcpu_restore calls this
     * function (vcpu_enable). It's better to embed the
     * restore_user_debug_context call in here than to call it in the outer
     * level caller (vcpu_switch), because if the structure of this VCPU code
     * changes later on, it will be less likely that the person who changes
     * the code will be able to omit the debug register context restore, if
     * it's done here.
     */
    restore_user_debug_context(vcpu->vcpuTCB);







}

static void
vcpu_disable(vcpu_t *vcpu)
{
    uint32_t hcr;
    word_t SCTLR;
    dsb();
    if (__builtin_expect(!!(vcpu), 1)) {
        hcr = get_gic_vcpu_ctrl_hcr();
        SCTLR = getSCTLR();
        vcpu->vgic.hcr = hcr;
        vcpu->cpx.sctlr = SCTLR;
        isb();
    }
    /* Turn off the VGIC */
    set_gic_vcpu_ctrl_hcr(0);
    isb();

    /* Stage 1 MMU off */
    setSCTLR(0xc5187c);
    setHCR(( ( (1ul << (19)) /* Trap SMC instructions          */ | (1ul << (14)) /* Trap WFE                       */ | (1ul << (13)) /* Trap WFI                       */ | (1ul << (5)) /* CPSR.A override enable         */ | (1ul << (4)) /* CPSR.I override enable         */ | (1ul << (3)) /* CPSR.F override enable         */ | (1ul << (12)) /* Default cacheable              */ | (1ul << (0)) /* Virtualization MMU enable      */) | (1ul << (27)) /* Trap general exceptions        */ | (1ul << (26)) /* Trap MMU access                */ | (1ul << (25)) /* Trap TLB operations            */ | ((1ul << (24)) /* Trap cache maintenance         */ | (1ul << (23)) /* Trap cache maintenance PoC     */ | (1ul << (22)) /* Trap cache maintenance set/way */) | (1ul << (21)) /* Trap ACTLR access              */ | (1ul << (1)) /* set/way invalidate override    */));


    /* Disable all breakpoint registers from triggering their
     * respective events, so that when we switch from a guest VM
     * to a native thread, the native thread won't trigger events
     * that were caused by things the guest VM did.
     */
    loadAllDisabledBreakpointState();







    isb();
}

__attribute__((__section__(".boot.text"))) void
vcpu_boot_init(void)
{
    gic_vcpu_num_list_regs = ((((get_gic_vcpu_ctrl_vtr()) >> 0) & 0x3f) + 1);
    if (gic_vcpu_num_list_regs > 64) {
        kprintf("Warning: VGIC is reporting more list registers than we support. Truncating\n");
        gic_vcpu_num_list_regs = 64;
    }
    vcpu_disable(((void *)0));
    armHSCurVCPU = ((void *)0);
    armHSVCPUActive = false;
# 504 "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c"
}

static void
vcpu_save(vcpu_t *vcpu, bool_t active)
{
    word_t i;
    unsigned int lr_num;

    if(!(vcpu)) _assert_fail("vcpu", "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c", 512, __FUNCTION__);
    dsb();
    /* If we aren't active then this state already got stored when
     * we were disabled */
    if (active) {
        vcpu->cpx.sctlr = getSCTLR();
        vcpu->vgic.hcr = get_gic_vcpu_ctrl_hcr();
    }
    /* Store VCPU state */
    vcpu->cpx.actlr = getACTLR();

    /* Store GIC VCPU control state */
    vcpu->vgic.vmcr = get_gic_vcpu_ctrl_vmcr();
    vcpu->vgic.apr = get_gic_vcpu_ctrl_apr();
    lr_num = gic_vcpu_num_list_regs;
    for (i = 0; i < lr_num; i++) {
        vcpu->vgic.lr[i] = get_gic_vcpu_ctrl_lr(i);
    }

    /* save banked registers */
    vcpu->lr_svc = get_lr_svc();
    vcpu->sp_svc = get_sp_svc();
    vcpu->lr_abt = get_lr_abt();
    vcpu->sp_abt = get_sp_abt();
    vcpu->lr_und = get_lr_und();
    vcpu->sp_und = get_sp_und();
    vcpu->lr_irq = get_lr_irq();
    vcpu->sp_irq = get_sp_irq();
    vcpu->lr_fiq = get_lr_fiq();
    vcpu->sp_fiq = get_sp_fiq();
    vcpu->r8_fiq = get_r8_fiq();
    vcpu->r9_fiq = get_r9_fiq();
    vcpu->r10_fiq = get_r10_fiq();
    vcpu->r11_fiq = get_r11_fiq();
    vcpu->r12_fiq = get_r12_fiq();


    /* This is done when we are asked to save and restore the CP14 debug context
     * of VCPU threads; the register context is saved into the underlying TCB.
     */
    saveAllBreakpointState(vcpu->vcpuTCB);

    isb();
}


static uint32_t
readVCPUReg(vcpu_t *vcpu, uint32_t field)
{
    if (__builtin_expect(!!(armHSCurVCPU == vcpu), 1)) {
        switch (field) {
        case seL4_VCPUReg_SCTLR:
            /* The SCTLR value is switched to/from hardware when we enable/disable
             * the vcpu, not when we switch vcpus */
            if (armHSVCPUActive) {
                return getSCTLR();
            } else {
                return vcpu->cpx.sctlr;
            }
        case seL4_VCPUReg_LRsvc:
            return get_lr_svc();
        case seL4_VCPUReg_SPsvc:
            return get_sp_svc();
        case seL4_VCPUReg_LRabt:
            return get_lr_abt();
        case seL4_VCPUReg_SPabt:
            return get_sp_abt();
        case seL4_VCPUReg_LRund:
            return get_lr_und();
        case seL4_VCPUReg_SPund:
            return get_sp_und();
        case seL4_VCPUReg_LRirq:
            return get_lr_irq();
        case seL4_VCPUReg_SPirq:
            return get_sp_irq();
        case seL4_VCPUReg_LRfiq:
            return get_lr_fiq();
        case seL4_VCPUReg_SPfiq:
            return get_sp_fiq();
        case seL4_VCPUReg_R8fiq:
            return get_r8_fiq();
        case seL4_VCPUReg_R9fiq:
            return get_r9_fiq();
        case seL4_VCPUReg_R10fiq:
            return get_r10_fiq();
        case seL4_VCPUReg_R11fiq:
            return get_r11_fiq();
        case seL4_VCPUReg_R12fiq:
            return get_r12_fiq();
        default:
            _fail("Unknown VCPU field", "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c", 602, __func__);
        }
    } else {
        switch (field) {
        case seL4_VCPUReg_SCTLR:
            return vcpu->cpx.sctlr;
        case seL4_VCPUReg_LRsvc:
            return vcpu->lr_svc;
        case seL4_VCPUReg_SPsvc:
            return vcpu->sp_svc;
        case seL4_VCPUReg_LRabt:
            return vcpu->lr_abt;
        case seL4_VCPUReg_SPabt:
            return vcpu->sp_abt;
        case seL4_VCPUReg_LRund:
            return vcpu->lr_und;
        case seL4_VCPUReg_SPund:
            return vcpu->sp_und;
        case seL4_VCPUReg_LRirq:
            return vcpu->lr_irq;
        case seL4_VCPUReg_SPirq:
            return vcpu->sp_irq;
        case seL4_VCPUReg_LRfiq:
            return vcpu->lr_fiq;
        case seL4_VCPUReg_SPfiq:
            return vcpu->sp_fiq;
        case seL4_VCPUReg_R8fiq:
            return vcpu->r8_fiq;
        case seL4_VCPUReg_R9fiq:
            return vcpu->r9_fiq;
        case seL4_VCPUReg_R10fiq:
            return vcpu->r10_fiq;
        case seL4_VCPUReg_R11fiq:
            return vcpu->r11_fiq;
        case seL4_VCPUReg_R12fiq:
            return vcpu->r12_fiq;
        default:
            _fail("Unknown VCPU field", "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c", 639, __func__);
        }
    }
}

static void
writeVCPUReg(vcpu_t *vcpu, uint32_t field, uint32_t value)
{
    if (__builtin_expect(!!(armHSCurVCPU == vcpu), 1)) {
        switch (field) {
        case seL4_VCPUReg_SCTLR:
            if (armHSVCPUActive) {
                setSCTLR(value);
            } else {
                vcpu->cpx.sctlr = value;
            }
            break;
        case seL4_VCPUReg_LRsvc:
            set_lr_svc(value);
            break;
        case seL4_VCPUReg_SPsvc:
            set_sp_svc(value);
            break;
        case seL4_VCPUReg_LRabt:
            set_lr_abt(value);
            break;
        case seL4_VCPUReg_SPabt:
            set_sp_abt(value);
            break;
        case seL4_VCPUReg_LRund:
            set_lr_und(value);
            break;
        case seL4_VCPUReg_SPund:
            set_sp_und(value);
            break;
        case seL4_VCPUReg_LRirq:
            set_lr_irq(value);
            break;
        case seL4_VCPUReg_SPirq:
            set_sp_irq(value);
            break;
        case seL4_VCPUReg_LRfiq:
            set_lr_fiq(value);
            break;
        case seL4_VCPUReg_SPfiq:
            set_sp_fiq(value);
            break;
        case seL4_VCPUReg_R8fiq:
            set_r8_fiq(value);
            break;
        case seL4_VCPUReg_R9fiq:
            set_r9_fiq(value);
            break;
        case seL4_VCPUReg_R10fiq:
            set_r10_fiq(value);
            break;
        case seL4_VCPUReg_R11fiq:
            set_r11_fiq(value);
            break;
        case seL4_VCPUReg_R12fiq:
            set_r12_fiq(value);
            break;
        default:
            _fail("Unknown VCPU field", "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c", 702, __func__);
        }
    } else {
        switch (field) {
        case seL4_VCPUReg_SCTLR:
            vcpu->cpx.sctlr = value;
            break;
        case seL4_VCPUReg_LRsvc:
            vcpu->lr_svc = value;
            break;
        case seL4_VCPUReg_SPsvc:
            vcpu->sp_svc = value;
            break;
        case seL4_VCPUReg_LRabt:
            vcpu->lr_abt = value;
            break;
        case seL4_VCPUReg_SPabt:
            vcpu->sp_abt = value;
            break;
        case seL4_VCPUReg_LRund:
            vcpu->lr_und = value;
            break;
        case seL4_VCPUReg_SPund:
            vcpu->sp_und = value;
            break;
        case seL4_VCPUReg_LRirq:
            vcpu->lr_irq = value;
            break;
        case seL4_VCPUReg_SPirq:
            vcpu->sp_irq = value;
            break;
        case seL4_VCPUReg_LRfiq:
            vcpu->lr_fiq = value;
            break;
        case seL4_VCPUReg_SPfiq:
            vcpu->sp_fiq = value;
            break;
        case seL4_VCPUReg_R8fiq:
            vcpu->r8_fiq = value;
            break;
        case seL4_VCPUReg_R9fiq:
            vcpu->r9_fiq = value;
            break;
        case seL4_VCPUReg_R10fiq:
            vcpu->r10_fiq = value;
            break;
        case seL4_VCPUReg_R11fiq:
            vcpu->r11_fiq = value;
            break;
        case seL4_VCPUReg_R12fiq:
            vcpu->r12_fiq = value;
            break;
        default:
            _fail("Unknown VCPU field", "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c", 755, __func__);
        }
    }
}

void
vcpu_restore(vcpu_t *vcpu)
{
    if(!(vcpu)) _assert_fail("vcpu", "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c", 763, __FUNCTION__);
    word_t i;
    unsigned int lr_num;
    /* Turn off the VGIC */
    set_gic_vcpu_ctrl_hcr(0);
    isb();

    /* Restore GIC VCPU control state */
    set_gic_vcpu_ctrl_vmcr(vcpu->vgic.vmcr);
    set_gic_vcpu_ctrl_apr(vcpu->vgic.apr);
    lr_num = gic_vcpu_num_list_regs;
    for (i = 0; i < lr_num; i++) {
        set_gic_vcpu_ctrl_lr(i, vcpu->vgic.lr[i]);
    }

    /* restore banked registers */
    set_lr_svc(vcpu->lr_svc);
    set_sp_svc(vcpu->sp_svc);
    set_lr_abt(vcpu->lr_abt);
    set_sp_abt(vcpu->sp_abt);
    set_lr_und(vcpu->lr_und);
    set_sp_und(vcpu->sp_und);
    set_lr_irq(vcpu->lr_irq);
    set_sp_irq(vcpu->sp_irq);
    set_lr_fiq(vcpu->lr_fiq);
    set_sp_fiq(vcpu->sp_fiq);
    set_r8_fiq(vcpu->r8_fiq);
    set_r9_fiq(vcpu->r9_fiq);
    set_r10_fiq(vcpu->r10_fiq);
    set_r11_fiq(vcpu->r11_fiq);
    set_r12_fiq(vcpu->r12_fiq);

    /* Restore and enable VCPU state */
    setACTLR(vcpu->cpx.actlr);
    vcpu_enable(vcpu);
}

void
VGICMaintenance(void)
{
    uint32_t eisr0, eisr1;
    uint32_t flags;

    /* The current thread must be runnable at this point as we can only get
     * a VGIC maintenance whilst we are actively running a thread with an
     * associated VCPU. For the moment for the proof we leave a redundant
     * check in here that this is indeed not happening */
    if (!isRunnable(ksCurThread)) {
        kprintf("Received VGIC maintenance on non-runnable thread!\n");
        return;
    }

    eisr0 = get_gic_vcpu_ctrl_eisr0();
    eisr1 = get_gic_vcpu_ctrl_eisr1();
    flags = get_gic_vcpu_ctrl_misr();

    if (flags & (1U << 0)) {
        int irq_idx;
        if (eisr0) {
            irq_idx = ctzl(eisr0);
        } else if (eisr1) {
            irq_idx = ctzl(eisr1) + 32;
        } else {
            irq_idx = -1;
        }

        /* the hardware should never give us an invalid index, but we don't
         * want to trust it that far */
        if (irq_idx == -1 || irq_idx >= gic_vcpu_num_list_regs) {
            current_fault = seL4_Fault_VGICMaintenance_new(0, 0);
        } else {
            virq_t virq = get_gic_vcpu_ctrl_lr(irq_idx);
            switch (virq_get_virqType(virq)) {
            case virq_virq_active:
                virq = virq_virq_active_set_virqEOIIRQEN(virq, 0);
                break;
            case virq_virq_pending:
                virq = virq_virq_pending_set_virqEOIIRQEN(virq, 0);
                break;
            case virq_virq_invalid:
                virq = virq_virq_invalid_set_virqEOIIRQEN(virq, 0);
                break;
            }
            set_gic_vcpu_ctrl_lr(irq_idx, virq);
            current_fault = seL4_Fault_VGICMaintenance_new(irq_idx, 1);
        }

    } else {
        /* Assume that it was an EOI for a LR that was not present */
        current_fault = seL4_Fault_VGICMaintenance_new(0, 0);
    }

    handleFault(ksCurThread);
}

void
vcpu_init(vcpu_t *vcpu)
{
    /* CPX registers */
    vcpu->cpx.sctlr = 0xc5187c;
    vcpu->cpx.actlr = 0x40;
    /* GICH VCPU interface control */
    vcpu->vgic.hcr = (1U << 0);
}

void
vcpu_switch(vcpu_t *new)
{
    if (__builtin_expect(!!(armHSCurVCPU != new), 1)) {
        if (__builtin_expect(!!(new != ((void *)0)), 0)) {
            if (__builtin_expect(!!(armHSCurVCPU != ((void *)0)), 0)) {
                vcpu_save(armHSCurVCPU, armHSVCPUActive);
            }
            vcpu_restore(new);
            armHSCurVCPU = new;
            armHSVCPUActive = true;
        } else if (__builtin_expect(!!(armHSVCPUActive), 0)) {
            /* leave the current VCPU state loaded, but disable vgic and mmu */

            saveAllBreakpointState(armHSCurVCPU->vcpuTCB);

            vcpu_disable(armHSCurVCPU);
            armHSVCPUActive = false;
        }
    } else if (__builtin_expect(!!(!armHSVCPUActive && new != ((void *)0)), 1)) {
        isb();
        vcpu_enable(new);
        armHSVCPUActive = true;
    }
}

static void
vcpu_invalidate_active(void)
{
    if (armHSVCPUActive) {
        vcpu_disable(((void *)0));
        armHSVCPUActive = false;
    }
    armHSCurVCPU = ((void *)0);
}

void
vcpu_finalise(vcpu_t *vcpu)
{
    if (vcpu->vcpuTCB) {
        dissociateVCPUTCB(vcpu, vcpu->vcpuTCB);
    }
}

void
associateVCPUTCB(vcpu_t *vcpu, tcb_t *tcb)
{
    if (tcb->tcbArch.tcbVCPU) {
        dissociateVCPUTCB(tcb->tcbArch.tcbVCPU, tcb);
    }
    if (vcpu->vcpuTCB) {
        dissociateVCPUTCB(vcpu, vcpu->vcpuTCB);
    }
    tcb->tcbArch.tcbVCPU = vcpu;
    vcpu->vcpuTCB = tcb;
}

void
dissociateVCPUTCB(vcpu_t *vcpu, tcb_t *tcb)
{
    if (tcb->tcbArch.tcbVCPU != vcpu || vcpu->vcpuTCB != tcb) {
        _fail("TCB and VCPU not associated.", "/home/sel4/work/work2/kernel/src/arch/arm/object/vcpu.c", 929, __func__);
    }
    if (vcpu == armHSCurVCPU) {
        vcpu_invalidate_active();
    }
    tcb->tcbArch.tcbVCPU = ((void *)0);
    vcpu->vcpuTCB = ((void *)0);

    Arch_debugDissociateVCPUTCB(tcb);


    /* sanitize the CPSR as without a VCPU a thread should only be in user mode */
    setRegister(tcb, CPSR, sanitiseRegister(CPSR, getRegister(tcb, CPSR), false));
}

exception_t
invokeVCPUWriteReg(vcpu_t *vcpu, uint32_t field, uint32_t value)
{
    writeVCPUReg(vcpu, field, value);
    return EXCEPTION_NONE;
}

exception_t
decodeVCPUWriteReg(cap_t cap, unsigned int length, word_t* buffer)
{
    uint32_t field;
    uint32_t value;
    if (length < 2) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 957, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("VCPUWriteReg: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }
    field = getSyscallArg(0, buffer);
    value = getSyscallArg(1, buffer);
    if (field >= seL4_VCPUReg_Num) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 964, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("VCPUWriteReg: Invalid field 0x%lx.", (long)field); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }
    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeVCPUWriteReg(((struct vcpu *)(cap_vcpu_cap_get_capVCPUPtr(cap))), field, value);
}

exception_t
invokeVCPUReadReg(vcpu_t *vcpu, uint32_t field, bool_t call)
{
    tcb_t *thread;
    thread = ksCurThread;
    uint32_t value = readVCPUReg(vcpu, field);
    if (call) {
        word_t *ipcBuffer = lookupIPCBuffer(true, thread);
        setRegister(thread, badgeRegister, 0);
        unsigned int length = setMR(thread, ipcBuffer, 0, value);
        setRegister(thread, msgInfoRegister, wordFromMessageInfo(
                        seL4_MessageInfo_new(0, 0, 0, length)));
    }
    setThreadState(ksCurThread, ThreadState_Running);
    return EXCEPTION_NONE;
}

exception_t
decodeVCPUReadReg(cap_t cap, unsigned int length, bool_t call, word_t* buffer)
{
    uint32_t field;
    if (length < 1) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 995, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("VCPUReadReg: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    field = getSyscallArg(0, buffer);

    if (field >= seL4_VCPUReg_Num) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1003, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("VCPUReadReg: Invalid field 0x%lx.", (long)field); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeVCPUReadReg(((struct vcpu *)(cap_vcpu_cap_get_capVCPUPtr(cap))), field, call);
}

exception_t
invokeVCPUInjectIRQ(vcpu_t* vcpu, unsigned long index, virq_t virq)
{
    if (__builtin_expect(!!(armHSCurVCPU == vcpu), 1)) {
        set_gic_vcpu_ctrl_lr(index, virq);
    } else {
        vcpu->vgic.lr[index] = virq;
    }

    return EXCEPTION_NONE;
}

exception_t
decodeVCPUInjectIRQ(cap_t cap, unsigned int length, word_t* buffer)
{
    word_t vid, priority, group, index;
    vcpu_t *vcpu;
    uint32_t mr0, mr1;

    vcpu = ((struct vcpu *)(cap_vcpu_cap_get_capVCPUPtr(cap)));

    if (length < 2) {
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    mr0 = getSyscallArg(0, buffer);
    mr1 = getSyscallArg(1, buffer);
    vid = mr0 & 0xffff;
    priority = (mr0 >> 16) & 0xff;
    group = (mr0 >> 24) & 0xff;
    index = mr1 & 0xff;

    /* Check IRQ parameters */
    if (vid > (1U << 10) - 1) {
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 0;
        current_syscall_error.rangeErrorMax = (1U << 10) - 1;
        current_syscall_error.invalidArgumentNumber = 1;
        current_syscall_error.type = seL4_RangeError;
        return EXCEPTION_SYSCALL_ERROR;
    }
    if (priority > 31) {
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 0;
        current_syscall_error.rangeErrorMax = 31;
        current_syscall_error.invalidArgumentNumber = 2;
        current_syscall_error.type = seL4_RangeError;
        return EXCEPTION_SYSCALL_ERROR;
    }
    if (group > 1) {
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 0;
        current_syscall_error.rangeErrorMax = 1;
        current_syscall_error.invalidArgumentNumber = 3;
        current_syscall_error.type = seL4_RangeError;
        return EXCEPTION_SYSCALL_ERROR;
    }
    /* LR index out of range */
    if (index >= gic_vcpu_num_list_regs) {
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 0;
        current_syscall_error.rangeErrorMax = gic_vcpu_num_list_regs - 1;
        current_syscall_error.invalidArgumentNumber = 4;
        current_syscall_error.type = seL4_RangeError;
        return EXCEPTION_SYSCALL_ERROR;
    }
    /* LR index is in use */
    if (virq_get_virqType(vcpu->vgic.lr[index]) == virq_virq_active) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1082, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("VGIC List register in use."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_DeleteFirst;
        return EXCEPTION_SYSCALL_ERROR;
    }
    virq_t virq = virq_virq_pending_new(group, priority, 1, vid);

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeVCPUInjectIRQ(vcpu, index, virq);
}

exception_t decodeARMVCPUInvocation(
    word_t label,
    unsigned int length,
    cptr_t cptr,
    cte_t* slot,
    cap_t cap,
    extra_caps_t extraCaps,
    bool_t call,
    word_t* buffer
)
{
    switch (label) {
    case ARMVCPUSetTCB:
        return decodeVCPUSetTCB(cap, extraCaps);
    case ARMVCPUReadReg:
        return decodeVCPUReadReg(cap, length, call, buffer);
    case ARMVCPUWriteReg:
        return decodeVCPUWriteReg(cap, length, buffer);
    case ARMVCPUInjectIRQ:
        return decodeVCPUInjectIRQ(cap, length, buffer);
    default:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1113, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("VCPU: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
}

exception_t
decodeVCPUSetTCB(cap_t cap, extra_caps_t extraCaps)
{
    cap_t tcbCap;
    if ( extraCaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1124, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("VCPU SetTCB: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }
    tcbCap = extraCaps.excaprefs[0]->cap;

    if (cap_get_capType(tcbCap) != cap_thread_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1131, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB cap is not a TCB cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeVCPUSetTCB(((struct vcpu *)(cap_vcpu_cap_get_capVCPUPtr(cap))), ((tcb_t *)(cap_thread_cap_get_capTCBPtr(tcbCap))));
}

exception_t
invokeVCPUSetTCB(vcpu_t *vcpu, tcb_t *tcb)
{
    associateVCPUTCB(vcpu, tcb);

    return EXCEPTION_NONE;
}

void
handleVCPUFault(word_t hsr)
{
    current_fault = seL4_Fault_VCPUFault_new(hsr);
    handleFault(ksCurThread);
    schedule();
    activateThread();
}
# 1 "/home/sel4/work/work2/kernel/src/arch/arm/smp/ipi.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/arch/arm/smp/ipi.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/smp/ipi.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/smp/ipi.h" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/smp/ipi.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/smp/ipi.h" 2
# 1 "/home/sel4/work/work2/kernel/include/smp/ipi.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/smp/ipi.h" 2
# 15 "/home/sel4/work/work2/kernel/src/arch/arm/smp/ipi.c" 2
# 1 "/home/sel4/work/work2/kernel/include/smp/lock.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/arch/arm/smp/ipi.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/arch/arm/smp/ipi.c" 2
# 1 "/home/sel4/work/work2/kernel/src/assert.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/assert.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/assert.c" 2



void _fail(
    const char* s,
    const char* file,
    unsigned int line,
    const char* function)
{
    kprintf("seL4 called fail at %s:%u in function %s, saying \"%s\"\n", file, line, function, s)





     ;
    halt();
}

void _assert_fail(
    const char* assertion,
    const char* file,
    unsigned int line,
    const char* function)
{
    kprintf("seL4 failed assertion '%s' at %s:%u in function %s\n", assertion, file, line, function)




           ;
    halt();
}
# 1 "/home/sel4/work/work2/kernel/src/benchmark/benchmark_track.c"
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/benchmark/benchmark_track.c" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/benchmark/benchmark_track.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/benchmark/benchmark_track.c" 2
# 1 "/home/sel4/work/work2/kernel/src/benchmark/benchmark_utilisation.c"
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/benchmark/benchmark_utilisation.c" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/benchmark/benchmark_utilisation.c" 2
# 1 "/home/sel4/work/work2/kernel/src/fastpath/fastpath.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/fastpath/fastpath.c" 2
# 1 "/home/sel4/work/work2/kernel/include/fastpath/fastpath.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




/* Fastpath cap lookup.  Returns a null_cap on failure. */
static inline cap_t __attribute__((always_inline))
lookup_fp(cap_t cap, cptr_t cptr)
{
    word_t cptr2;
    cte_t *slot;
    word_t guardBits, radixBits, bits;
    word_t radix, capGuard;

    bits = 0;

    if (__builtin_expect(!!(! cap_capType_equals(cap, cap_cnode_cap)), 0)) {
        return cap_null_cap_new();
    }

    do {
        guardBits = cap_cnode_cap_get_capCNodeGuardSize(cap);
        radixBits = cap_cnode_cap_get_capCNodeRadix(cap);
        cptr2 = cptr << bits;

        capGuard = cap_cnode_cap_get_capCNodeGuard(cap);

        /* Check the guard. Depth mismatch check is deferred.
           The 32MinusGuardSize encoding contains an exception
           when the guard is 0, when 32MinusGuardSize will be
           reported as 0 also. In this case we skip the check */
        if (__builtin_expect(!!(guardBits), 1) && __builtin_expect(!!(cptr2 >> ((1 << 5) - guardBits) != capGuard), 0)) {
            return cap_null_cap_new();
        }

        radix = cptr2 << guardBits >> ((1 << 5) - radixBits);
        slot = ((cte_t *)(cap_cnode_cap_get_capCNodePtr(cap))) + radix;

        cap = slot->cap;
        bits += guardBits + radixBits;

    } while (__builtin_expect(!!(bits < (1 << 5) && cap_capType_equals(cap, cap_cnode_cap)), 0));

    if (__builtin_expect(!!(bits > (1 << 5)), 0)) {
        /* Depth mismatch. We've overshot wordBits bits. The lookup we've done is
           safe, but wouldn't be allowed by the slowpath. */
        return cap_null_cap_new();
    }

    return cap;
}
/* make sure the fastpath functions conform with structure_*.bf */
static inline void
thread_state_ptr_set_tsType_np(thread_state_t *ts_ptr, word_t tsType)
{
    ts_ptr->words[0] = tsType;
}

static inline void
thread_state_ptr_mset_blockingObject_tsType(thread_state_t *ts_ptr,
                                            word_t ep_ref,
                                            word_t tsType)
{
    ts_ptr->words[0] = ep_ref | tsType;
}

static inline void
cap_reply_cap_ptr_new_np(cap_t *cap_ptr, word_t capReplyMaster,
                         word_t capTCBPtr)
{




    cap_ptr->words[0] = ((word_t)(capTCBPtr)) | (capReplyMaster << 4) |
                        cap_reply_cap ;

}

static inline void
endpoint_ptr_mset_epQueue_tail_state(endpoint_t *ep_ptr, word_t epQueue_tail,
                                     word_t state)
{
    ep_ptr->words[0] = epQueue_tail | state;
}

static inline void
endpoint_ptr_set_epQueue_head_np(endpoint_t *ep_ptr, word_t epQueue_head)
{
    ep_ptr->words[1] = epQueue_head;
}

# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/fastpath/fastpath.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 102 "/home/sel4/work/work2/kernel/include/fastpath/fastpath.h" 2
# 13 "/home/sel4/work/work2/kernel/src/fastpath/fastpath.c" 2




# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_utilisation.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/fastpath/fastpath.c" 2

void



fastpath_call(word_t cptr, word_t msgInfo)
{
    seL4_MessageInfo_t info;
    cap_t ep_cap;
    endpoint_t *ep_ptr;
    word_t length;
    tcb_t *dest;
    word_t badge;
    cte_t *replySlot, *callerSlot;
    cap_t newVTable;
    vspace_root_t *cap_pd;
    pde_t stored_hw_asid;
    word_t fault_type;

    /* Get message info, length, and fault type. */
    info = messageInfoFromWord_raw(msgInfo);
    length = seL4_MessageInfo_get_length(info);
    fault_type = seL4_Fault_get_seL4_FaultType(ksCurThread->tcbFault);

    /* Check there's no extra caps, the length is ok and there's no
     * saved fault. */
    if (__builtin_expect(!!(fastpath_mi_check(msgInfo) || fault_type != seL4_Fault_NullFault), 0)
                                                    ) {
        slowpath(SysCall);
    }

    /* Lookup the cap */
    ep_cap = lookup_fp((((cte_t *)((word_t)(ksCurThread)&~((1ul << (10))-1ul)))+(tcbCTable))->cap, cptr);

    /* Check it's an endpoint */
    if (__builtin_expect(!!(!cap_capType_equals(ep_cap, cap_endpoint_cap) || !cap_endpoint_cap_get_capCanSend(ep_cap)), 0)
                                                          ) {
        slowpath(SysCall);
    }

    /* Get the endpoint address */
    ep_ptr = ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(ep_cap)));

    /* Get the destination thread, which is only going to be valid
     * if the endpoint is valid. */
    dest = ((tcb_t *)(endpoint_ptr_get_epQueue_head(ep_ptr)));

    /* Check that there's a thread waiting to receive */
    if (__builtin_expect(!!(endpoint_ptr_get_state(ep_ptr) != EPState_Recv), 0)) {
        slowpath(SysCall);
    }

    /* ensure we are not single stepping the destination in ia32 */






    /* Get destination thread.*/
    newVTable = (((cte_t *)((word_t)(dest)&~((1ul << (10))-1ul)))+(tcbVTable))->cap;

    /* Get vspace root. */
    cap_pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(newVTable)));

    /* Ensure that the destination has a valid VTable. */
    if (__builtin_expect(!!(! isValidVTableRoot_fp(newVTable)), 0)) {
        slowpath(SysCall);
    }


    /* Get HW ASID */
    stored_hw_asid = cap_pd[(0xff000000 >> (9 + 12))];
# 102 "/home/sel4/work/work2/kernel/src/fastpath/fastpath.c"
    /* Ensure the destination has a higher/equal priority to us. */
    if (__builtin_expect(!!(dest->tcbPriority < ksCurThread->tcbPriority), 0)) {
        slowpath(SysCall);
    }

    /* Ensure that the endpoint has has grant rights so that we can
     * create the reply cap */
    if (__builtin_expect(!!(!cap_endpoint_cap_get_capCanGrant(ep_cap)), 0)) {
        slowpath(SysCall);
    }


    if (__builtin_expect(!!(!pde_pde_invalid_get_stored_asid_valid(stored_hw_asid)), 0)) {
        slowpath(SysCall);
    }


    /* Ensure the original caller is in the current domain and can be scheduled directly. */
    if (__builtin_expect(!!(dest->tcbDomain != ksCurDomain && maxDom), 0)) {
        slowpath(SysCall);
    }
# 131 "/home/sel4/work/work2/kernel/src/fastpath/fastpath.c"
    /*
     * --- POINT OF NO RETURN ---
     *
     * At this stage, we have committed to performing the IPC.
     */





    /* Dequeue the destination. */
    endpoint_ptr_set_epQueue_head_np(ep_ptr, ((word_t)(dest->tcbEPNext)));
    if (__builtin_expect(!!(dest->tcbEPNext), 0)) {
        dest->tcbEPNext->tcbEPPrev = ((void *)0);
    } else {
        endpoint_ptr_mset_epQueue_tail_state(ep_ptr, 0, EPState_Idle);
    }

    badge = cap_endpoint_cap_get_capEPBadge(ep_cap);

    /* Block sender */
    thread_state_ptr_set_tsType_np(&ksCurThread->tcbState,
                                   ThreadState_BlockedOnReply);

    /* Get sender reply slot */
    replySlot = (((cte_t *)((word_t)(ksCurThread)&~((1ul << (10))-1ul)))+(tcbReply));

    /* Get dest caller slot */
    callerSlot = (((cte_t *)((word_t)(dest)&~((1ul << (10))-1ul)))+(tcbCaller));

    /* Insert reply cap */
    cap_reply_cap_ptr_new_np(&callerSlot->cap, 0, ((word_t)(ksCurThread)));
    mdb_node_ptr_set_mdbPrev_np(&callerSlot->cteMDBNode, ((word_t)(replySlot)));
    mdb_node_ptr_mset_mdbNext_mdbRevocable_mdbFirstBadged(
        &replySlot->cteMDBNode, ((word_t)(callerSlot)), 1, 1);

    fastpath_copy_mrs (length, ksCurThread, dest);

    /* Dest thread is set Running, but not queued. */
    thread_state_ptr_set_tsType_np(&dest->tcbState,
                                   ThreadState_Running);
    switchToThread_fp(dest, cap_pd, stored_hw_asid);

    msgInfo = wordFromMessageInfo(seL4_MessageInfo_set_capsUnwrapped(info, 0));

    fastpath_restore(badge, msgInfo, ksCurThread);
}

void
fastpath_reply_recv(word_t cptr, word_t msgInfo)
{
    seL4_MessageInfo_t info;
    cap_t ep_cap;
    endpoint_t *ep_ptr;
    word_t length;
    cte_t *callerSlot;
    cap_t callerCap;
    tcb_t *caller;
    word_t badge;
    tcb_t *endpointTail;
    word_t fault_type;

    cap_t newVTable;
    vspace_root_t *cap_pd;
    pde_t stored_hw_asid;

    /* Get message info and length */
    info = messageInfoFromWord_raw(msgInfo);
    length = seL4_MessageInfo_get_length(info);
    fault_type = seL4_Fault_get_seL4_FaultType(ksCurThread->tcbFault);

    /* Check there's no extra caps, the length is ok and there's no
     * saved fault. */
    if (__builtin_expect(!!(fastpath_mi_check(msgInfo) || fault_type != seL4_Fault_NullFault), 0)
                                                    ) {
        slowpath(SysReplyRecv);
    }

    /* Lookup the cap */
    ep_cap = lookup_fp((((cte_t *)((word_t)(ksCurThread)&~((1ul << (10))-1ul)))+(tcbCTable))->cap,
                       cptr);

    /* Check it's an endpoint */
    if (__builtin_expect(!!(!cap_capType_equals(ep_cap, cap_endpoint_cap) || !cap_endpoint_cap_get_capCanReceive(ep_cap)), 0)
                                                             ) {
        slowpath(SysReplyRecv);
    }

    /* Check there is nothing waiting on the notification */
    if (ksCurThread->tcbBoundNotification &&
            notification_ptr_get_state(ksCurThread->tcbBoundNotification) == NtfnState_Active) {
        slowpath(SysReplyRecv);
    }

    /* Get the endpoint address */
    ep_ptr = ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(ep_cap)));

    /* Check that there's not a thread waiting to send */
    if (__builtin_expect(!!(endpoint_ptr_get_state(ep_ptr) == EPState_Send), 0)) {
        slowpath(SysReplyRecv);
    }

    /* Only reply if the reply cap is valid. */
    callerSlot = (((cte_t *)((word_t)(ksCurThread)&~((1ul << (10))-1ul)))+(tcbCaller));
    callerCap = callerSlot->cap;
    if (__builtin_expect(!!(!fastpath_reply_cap_check(callerCap)), 0)) {
        slowpath(SysReplyRecv);
    }

    /* Determine who the caller is. */
    caller = ((tcb_t *)(cap_reply_cap_get_capTCBPtr(callerCap)));

    /* ensure we are not single stepping the caller in ia32 */






    /* Check that the caller has not faulted, in which case a fault
       reply is generated instead. */
    fault_type = seL4_Fault_get_seL4_FaultType(caller->tcbFault);
    if (__builtin_expect(!!(fault_type != seL4_Fault_NullFault), 0)) {
        slowpath(SysReplyRecv);
    }

    /* Get destination thread.*/
    newVTable = (((cte_t *)((word_t)(caller)&~((1ul << (10))-1ul)))+(tcbVTable))->cap;

    /* Get vspace root. */
    cap_pd = ((pde_t *)(cap_page_directory_cap_get_capPDBasePtr(newVTable)));

    /* Ensure that the destination has a valid MMU. */
    if (__builtin_expect(!!(! isValidVTableRoot_fp (newVTable)), 0)) {
        slowpath(SysReplyRecv);
    }


    /* Get HWASID. */
    stored_hw_asid = cap_pd[(0xff000000 >> (9 + 12))];
# 281 "/home/sel4/work/work2/kernel/src/fastpath/fastpath.c"
    /* Ensure the original caller can be scheduled directly. */
    if (__builtin_expect(!!(caller->tcbPriority < ksCurThread->tcbPriority), 0)) {
        slowpath(SysReplyRecv);
    }


    /* Ensure the HWASID is valid. */
    if (__builtin_expect(!!(!pde_pde_invalid_get_stored_asid_valid(stored_hw_asid)), 0)) {
        slowpath(SysReplyRecv);
    }


    /* Ensure the original caller is in the current domain and can be scheduled directly. */
    if (__builtin_expect(!!(caller->tcbDomain != ksCurDomain && maxDom), 0)) {
        slowpath(SysReplyRecv);
    }
# 305 "/home/sel4/work/work2/kernel/src/fastpath/fastpath.c"
    /*
     * --- POINT OF NO RETURN ---
     *
     * At this stage, we have committed to performing the IPC.
     */





    /* Set thread state to BlockedOnReceive */
    thread_state_ptr_mset_blockingObject_tsType(
        &ksCurThread->tcbState, (word_t)ep_ptr, ThreadState_BlockedOnReceive);

    /* Place the thread in the endpoint queue */
    endpointTail = ((tcb_t *)(endpoint_ptr_get_epQueue_tail(ep_ptr)));
    if (__builtin_expect(!!(!endpointTail), 1)) {
        ksCurThread->tcbEPPrev = ((void *)0);
        ksCurThread->tcbEPNext = ((void *)0);

        /* Set head/tail of queue and endpoint state. */
        endpoint_ptr_set_epQueue_head_np(ep_ptr, ((word_t)(ksCurThread)));
        endpoint_ptr_mset_epQueue_tail_state(ep_ptr, ((word_t)(ksCurThread)),
                                             EPState_Recv);
    } else {
        /* Append current thread onto the queue. */
        endpointTail->tcbEPNext = ksCurThread;
        ksCurThread->tcbEPPrev = endpointTail;
        ksCurThread->tcbEPNext = ((void *)0);

        /* Update tail of queue. */
        endpoint_ptr_mset_epQueue_tail_state(ep_ptr, ((word_t)(ksCurThread)),
                                             EPState_Recv);
    }

    /* Delete the reply cap. */
    mdb_node_ptr_mset_mdbNext_mdbRevocable_mdbFirstBadged(
        &((cte_t *)(mdb_node_get_mdbPrev(callerSlot->cteMDBNode)))->cteMDBNode,
        0, 1, 1);
    callerSlot->cap = cap_null_cap_new();
    callerSlot->cteMDBNode = mdb_node_new(0, false, false, 0);

    /* I know there's no fault, so straight to the transfer. */

    /* Replies don't have a badge. */
    badge = 0;

    fastpath_copy_mrs (length, ksCurThread, caller);

    /* Dest thread is set Running, but not queued. */
    thread_state_ptr_set_tsType_np(&caller->tcbState,
                                   ThreadState_Running);
    switchToThread_fp(caller, cap_pd, stored_hw_asid);

    msgInfo = wordFromMessageInfo(seL4_MessageInfo_set_capsUnwrapped(info, 0));

    fastpath_restore(badge, msgInfo, ksCurThread);
}
# 1 "/home/sel4/work/work2/kernel/src/inlines.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/inlines.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/inlines.c" 2

lookup_fault_t current_lookup_fault;
seL4_Fault_t current_fault;
syscall_error_t current_syscall_error;
# 1 "/home/sel4/work/work2/kernel/src/kernel/boot.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/boot.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/kernel/boot.c" 2

/* (node-local) state accessed only during bootstrapping */

ndks_boot_t ndks_boot __attribute__((__section__(".boot.data")));

__attribute__((__section__(".boot.text"))) bool_t
insert_region(region_t reg)
{
    word_t i;

    if(!(reg.start <= reg.end)) _assert_fail("reg.start <= reg.end", "/home/sel4/work/work2/kernel/src/kernel/boot.c", 33, __FUNCTION__);
    if (is_reg_empty(reg)) {
        return true;
    }
    for (i = 0; i < 2; i++) {
        if (is_reg_empty(ndks_boot.freemem[i])) {
            ndks_boot.freemem[i] = reg;
            return true;
        }
    }
    return false;
}

__attribute__((__section__(".boot.text"))) static inline word_t
reg_size(region_t reg)
{
    return reg.end - reg.start;
}

__attribute__((__section__(".boot.text"))) pptr_t
alloc_region(word_t size_bits)
{
    word_t i;
    word_t reg_index = 0; /* gcc cannot work out that this will not be used uninitialized */
    region_t reg = (region_t){ .start = 0, .end = 0 };
    region_t rem_small = (region_t){ .start = 0, .end = 0 };
    region_t rem_large = (region_t){ .start = 0, .end = 0 };
    region_t new_reg;
    region_t new_rem_small;
    region_t new_rem_large;

    /* Search for a freemem region that will be the best fit for an allocation. We favour allocations
     * that are aligned to either end of the region. If an allocation must split a region we favour
     * an unbalanced split. In both cases we attempt to use the smallest region possible. In general
     * this means we aim to make the size of the smallest remaining region smaller (ideally zero)
     * followed by making the size of the largest remaining region smaller */

    for (i = 0; i < 2; i++) {
        /* Determine whether placing the region at the start or the end will create a bigger left over region */
        if ((((((ndks_boot.freemem[i].start) - 1ul) >> (size_bits)) + 1ul) << (size_bits)) - ndks_boot.freemem[i].start <
                ndks_boot.freemem[i].end - (((ndks_boot.freemem[i].end) >> (size_bits)) << (size_bits))) {
            new_reg.start = (((((ndks_boot.freemem[i].start) - 1ul) >> (size_bits)) + 1ul) << (size_bits));
            new_reg.end = new_reg.start + (1ul << (size_bits));
        } else {
            new_reg.end = (((ndks_boot.freemem[i].end) >> (size_bits)) << (size_bits));
            new_reg.start = new_reg.end - (1ul << (size_bits));
        }
        if (new_reg.end > new_reg.start &&
                new_reg.start >= ndks_boot.freemem[i].start &&
                new_reg.end <= ndks_boot.freemem[i].end) {
            if (new_reg.start - ndks_boot.freemem[i].start < ndks_boot.freemem[i].end - new_reg.end) {
                new_rem_small.start = ndks_boot.freemem[i].start;
                new_rem_small.end = new_reg.start;
                new_rem_large.start = new_reg.end;
                new_rem_large.end = ndks_boot.freemem[i].end;
            } else {
                new_rem_large.start = ndks_boot.freemem[i].start;
                new_rem_large.end = new_reg.start;
                new_rem_small.start = new_reg.end;
                new_rem_small.end = ndks_boot.freemem[i].end;
            }
            if ( is_reg_empty(reg) ||
                    (reg_size(new_rem_small) < reg_size(rem_small)) ||
                    (reg_size(new_rem_small) == reg_size(rem_small) && reg_size(new_rem_large) < reg_size(rem_large)) ) {
                reg = new_reg;
                rem_small = new_rem_small;
                rem_large = new_rem_large;
                reg_index = i;
            }
        }
    }
    if (is_reg_empty(reg)) {
        kprintf("Kernel init failing: not enough memory\n");
        return 0;
    }
    /* Remove the region in question */
    ndks_boot.freemem[reg_index] = (region_t){ .start = 0, .end = 0 };
    /* Add the remaining regions in largest to smallest order */
    insert_region(rem_large);
    if (!insert_region(rem_small)) {
        kprintf("alloc_region(): wasted 0x%lx bytes due to alignment, try to increase MAX_NUM_FREEMEM_REG\n", (word_t)(rem_small.end - rem_small.start))
                                                         ;
    }
    return reg.start;
}

__attribute__((__section__(".boot.text"))) void
write_slot(slot_ptr_t slot_ptr, cap_t cap)
{
    slot_ptr->cap = cap;

    slot_ptr->cteMDBNode = mdb_node_new(0, false, false, 0);
    mdb_node_ptr_set_mdbRevocable (&slot_ptr->cteMDBNode, true);
    mdb_node_ptr_set_mdbFirstBadged(&slot_ptr->cteMDBNode, true);
}

/* Our root CNode needs to be able to fit all the initial caps and not
 * cover all of memory.
 */
typedef int __assert_failed_root_cnode_size_valid[(19 < 32 - 4 && (1U << 19) >= seL4_NumInitialCaps) ? 1 : -1];



__attribute__((__section__(".boot.text"))) cap_t
create_root_cnode(void)
{
    pptr_t pptr;
    cap_t cap;

    /* write the number of root CNode slots to global state */
    ndks_boot.slot_pos_max = (1ul << (19));

    /* create an empty root CNode */
    pptr = alloc_region(19 + 4);
    if (!pptr) {
        kprintf("Kernel init failing: could not create root cnode\n");
        return cap_null_cap_new();
    }
    memzero(((cte_t *)(pptr)), 1U << (19 + 4));
    cap =
        cap_cnode_cap_new(
            19, /* radix      */
            (1 << 5) - 19, /* guard size */
            0, /* guard      */
            pptr /* pptr       */
        );

    /* write the root CNode cap into the root CNode */
    write_slot((((slot_ptr_t)(pptr)) + (seL4_CapInitThreadCNode)), cap);

    return cap;
}

typedef int __assert_failed_irq_cnode_size[((1ul << (12 - 4)) > maxIRQ) ? 1 : -1];

__attribute__((__section__(".boot.text"))) bool_t
create_irq_cnode(void)
{
    pptr_t pptr;
    /* create an empty IRQ CNode */
    pptr = alloc_region(12);
    if (!pptr) {
        kprintf("Kernel init failing: could not create irq cnode\n");
        return false;
    }
    memzero((void*)pptr, 1 << 12);
    intStateIRQNode = (cte_t*)pptr;
    return true;
}

/* Check domain scheduler assumptions. */
typedef int __assert_failed_num_domains_valid[(1 >= 1 && 1 <= 256) ? 1 : -1];

typedef int __assert_failed_num_priorities_valid[(256 >= 1 && 256 <= 256) ? 1 : -1];


__attribute__((__section__(".boot.text"))) void
create_domain_cap(cap_t root_cnode_cap)
{
    cap_t cap;
    word_t i;

    /* Check domain scheduler assumptions. */
    if(!(ksDomScheduleLength > 0)) _assert_fail("ksDomScheduleLength > 0", "/home/sel4/work/work2/kernel/src/kernel/boot.c", 196, __FUNCTION__);
    for (i = 0; i < ksDomScheduleLength; i++) {
        if(!(ksDomSchedule[i].domain < 1)) _assert_fail("ksDomSchedule[i].domain < CONFIG_NUM_DOMAINS", "/home/sel4/work/work2/kernel/src/kernel/boot.c", 198, __FUNCTION__);
        if(!(ksDomSchedule[i].length > 0)) _assert_fail("ksDomSchedule[i].length > 0", "/home/sel4/work/work2/kernel/src/kernel/boot.c", 199, __FUNCTION__);
    }

    cap = cap_domain_cap_new();
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapDomain)), cap);
}


__attribute__((__section__(".boot.text"))) cap_t
create_ipcbuf_frame(cap_t root_cnode_cap, cap_t pd_cap, vptr_t vptr)
{
    cap_t cap;
    pptr_t pptr;

    /* allocate the IPC buffer frame */
    pptr = alloc_region(12);
    if (!pptr) {
        kprintf("Kernel init failing: could not create ipc buffer frame\n");
        return cap_null_cap_new();
    }
    clearMemory((void*)pptr, 12);

    /* create a cap of it and write it into the root CNode */
    cap = create_mapped_it_frame_cap(pd_cap, pptr, vptr, 1 /* initial thread's ASID */, false, false);
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapInitThreadIPCBuffer)), cap);

    return cap;
}

__attribute__((__section__(".boot.text"))) void
create_bi_frame_cap(
    cap_t root_cnode_cap,
    cap_t pd_cap,
    pptr_t pptr,
    vptr_t vptr
)
{
    cap_t cap;

    /* create a cap of it and write it into the root CNode */
    cap = create_mapped_it_frame_cap(pd_cap, pptr, vptr, 1 /* initial thread's ASID */, false, false);
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapBootInfoFrame)), cap);
}

__attribute__((__section__(".boot.text"))) region_t
allocate_extra_bi_region(word_t extra_size)
{
    /* determine power of 2 size of this region. avoid calling clzl on 0 though */
    if (extra_size == 0) {
        /* return any valid address to correspond to the zero allocation */
        return (region_t) {
            0x1000, 0x1000
        };
    }
    word_t size_bits = (sizeof(seL4_Word) * 8) - 1 - clzl((((((extra_size) - 1ul) >> (12)) + 1ul) << (12)));
    pptr_t pptr = alloc_region(size_bits);
    if (!pptr) {
        kprintf("Kernel init failed: could not allocate extra bootinfo region size bits %lu\n", size_bits);
        return (region_t){ .start = 0, .end = 0 };
    }

    clearMemory((void*)pptr, size_bits);
    ndks_boot.bi_frame->extraLen = (1ul << (size_bits));

    return (region_t) {
        pptr, pptr + (1ul << (size_bits))
    };
}

__attribute__((__section__(".boot.text"))) pptr_t
allocate_bi_frame(
    node_id_t node_id,
    word_t num_nodes,
    vptr_t ipcbuf_vptr
)
{
    pptr_t pptr;

    /* create the bootinfo frame object */
    pptr = alloc_region(12);
    if (!pptr) {
        kprintf("Kernel init failed: could not allocate bootinfo frame\n");
        return 0;
    }
    clearMemory((void*)pptr, 12);

    /* initialise bootinfo-related global state */
    ndks_boot.bi_frame = ((seL4_BootInfo*)(pptr));
    ndks_boot.slot_pos_cur = seL4_NumInitialCaps;

    ((seL4_BootInfo*)(pptr))->nodeID = node_id;
    ((seL4_BootInfo*)(pptr))->numNodes = num_nodes;
    ((seL4_BootInfo*)(pptr))->numIOPTLevels = 0;
    ((seL4_BootInfo*)(pptr))->ipcBuffer = (seL4_IPCBuffer *) ipcbuf_vptr;
    ((seL4_BootInfo*)(pptr))->initThreadCNodeSizeBits = 19;
    ((seL4_BootInfo*)(pptr))->initThreadDomain = ksDomSchedule[ksDomScheduleIdx].domain;
    ((seL4_BootInfo*)(pptr))->extraLen = 0;
    ((seL4_BootInfo*)(pptr))->extraBIPages.start = 0;
    ((seL4_BootInfo*)(pptr))->extraBIPages.end = 0;

    return pptr;
}

__attribute__((__section__(".boot.text"))) bool_t
provide_cap(cap_t root_cnode_cap, cap_t cap)
{
    if (ndks_boot.slot_pos_cur >= ndks_boot.slot_pos_max) {
        kprintf("Kernel init failed: ran out of cap slots\n");
        return false;
    }
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (ndks_boot.slot_pos_cur)), cap);
    ndks_boot.slot_pos_cur++;
    return true;
}

__attribute__((__section__(".boot.text"))) create_frames_of_region_ret_t
create_frames_of_region(
    cap_t root_cnode_cap,
    cap_t pd_cap,
    region_t reg,
    bool_t do_map,
    sword_t pv_offset
)
{
    pptr_t f;
    cap_t frame_cap;
    seL4_SlotPos slot_pos_before;
    seL4_SlotPos slot_pos_after;

    slot_pos_before = ndks_boot.slot_pos_cur;

    for (f = reg.start; f < reg.end; f += (1ul << (12))) {
        if (do_map) {
            frame_cap = create_mapped_it_frame_cap(pd_cap, f, addrFromPPtr((void*)(f - pv_offset)), 1 /* initial thread's ASID */, false, true);
        } else {
            frame_cap = create_unmapped_it_frame_cap(f, false);
        }
        if (!provide_cap(root_cnode_cap, frame_cap))
            return (create_frames_of_region_ret_t) {
            (seL4_SlotRegion){ .start = 0, .end = 0 }, false
        };
    }

    slot_pos_after = ndks_boot.slot_pos_cur;

    return (create_frames_of_region_ret_t) {
        (seL4_SlotRegion) { slot_pos_before, slot_pos_after }, true
    };
}

__attribute__((__section__(".boot.text"))) cap_t
create_it_asid_pool(cap_t root_cnode_cap)
{
    pptr_t ap_pptr;
    cap_t ap_cap;

    /* create ASID pool */
    ap_pptr = alloc_region(12);
    if (!ap_pptr) {
        kprintf("Kernel init failed: failed to create initial thread asid pool\n");
        return cap_null_cap_new();
    }
    memzero(((asid_pool_t *)ap_pptr), 1 << 12);
    ap_cap = cap_asid_pool_cap_new(1 /* initial thread's ASID */ >> asidLowBits, ap_pptr);
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapInitThreadASIDPool)), ap_cap);

    /* create ASID control cap */
    write_slot(
        (((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapASIDControl)),
        cap_asid_control_cap_new()
    );

    return ap_cap;
}

__attribute__((__section__(".boot.text"))) bool_t
create_idle_thread(void)
{
    pptr_t pptr;




        pptr = alloc_region(10);
        if (!pptr) {
            kprintf("Kernel init failed: Unable to allocate tcb for idle thread\n");
            return false;
        }
        memzero((void *)pptr, 1 << 10);
        ksIdleThread = ((tcb_t *)(pptr + (1ul << ((4 + 4)))));
        configureIdleThread(ksIdleThread);

        setThreadName(ksIdleThread, "idle_thread");




    return true;
}

__attribute__((__section__(".boot.text"))) tcb_t *
create_initial_thread(
    cap_t root_cnode_cap,
    cap_t it_pd_cap,
    vptr_t ui_v_entry,
    vptr_t bi_frame_vptr,
    vptr_t ipcbuf_vptr,
    cap_t ipcbuf_cap
)
{
    pptr_t pptr;
    cap_t cap;
    tcb_t* tcb;
    deriveCap_ret_t dc_ret;

    /* allocate TCB */
    pptr = alloc_region(10);
    if (!pptr) {
        kprintf("Kernel init failed: Unable to allocate tcb for initial thread\n");
        return ((void *)0);
    }
    memzero((void*)pptr, 1 << 10);
    tcb = ((tcb_t *)(pptr + (1ul << ((4 + 4)))));
    tcb->tcbTimeSlice = 5;
    Arch_initContext(&tcb->tcbArch.tcbContext);

    /* derive a copy of the IPC buffer cap for inserting */
    dc_ret = deriveCap((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapInitThreadIPCBuffer)), ipcbuf_cap);
    if (dc_ret.status != EXCEPTION_NONE) {
        kprintf("Failed to derive copy of IPC Buffer\n");
        return ((void *)0);
    }

    /* initialise TCB (corresponds directly to abstract specification) */
    cteInsert(
        root_cnode_cap,
        (((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapInitThreadCNode)),
        (((slot_ptr_t)(pptr)) + (tcbCTable))
    );
    cteInsert(
        it_pd_cap,
        (((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapInitThreadVSpace)),
        (((slot_ptr_t)(pptr)) + (tcbVTable))
    );
    cteInsert(
        dc_ret.cap,
        (((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapInitThreadIPCBuffer)),
        (((slot_ptr_t)(pptr)) + (tcbBuffer))
    );
    tcb->tcbIPCBuffer = ipcbuf_vptr;

    /* Set the root thread's IPC buffer */
    Arch_setTCBIPCBuffer(tcb, ipcbuf_vptr);

    setRegister(tcb, capRegister, bi_frame_vptr);
    setNextPC(tcb, ui_v_entry);

    /* initialise TCB */
    tcb->tcbPriority = seL4_MaxPrio;
    tcb->tcbMCP = seL4_MaxPrio;
    setupReplyMaster(tcb);
    setThreadState(tcb, ThreadState_Running);

    ksCurDomain = ksDomSchedule[ksDomScheduleIdx].domain;
    ksDomainTime = ksDomSchedule[ksDomScheduleIdx].length;
    if(!(ksCurDomain < 1 && ksDomainTime > 0)) _assert_fail("ksCurDomain < CONFIG_NUM_DOMAINS && ksDomainTime > 0", "/home/sel4/work/work2/kernel/src/kernel/boot.c", 464, __FUNCTION__);

    ;

    /* create initial thread's TCB cap */
    cap = cap_thread_cap_new(((word_t)(tcb)));
    write_slot((((slot_ptr_t)((pptr_t)cap_get_capPtr(root_cnode_cap))) + (seL4_CapInitThreadTCB)), cap);


    setThreadName(tcb, "rootserver");


    return tcb;
}

__attribute__((__section__(".boot.text"))) void
init_core_state(tcb_t *scheduler_action)
{

    ksActiveFPUState = ((void *)0);


    /* add initial threads to the debug queue */
    ksDebugTCBs = ((void *)0);
    if (scheduler_action != ((tcb_t*)0) &&
            scheduler_action != ((tcb_t*)~0)) {
        tcbDebugAppend(scheduler_action);
    }
    for (int i = 0; i < 1; i++) {
        tcbDebugAppend(ksIdleThread);
    }

    ksSchedulerAction = scheduler_action;
    ksCurThread = ksIdleThread;
}

__attribute__((__section__(".boot.text"))) static bool_t
provide_untyped_cap(
    cap_t root_cnode_cap,
    bool_t device_memory,
    pptr_t pptr,
    word_t size_bits,
    seL4_SlotPos first_untyped_slot
)
{
    bool_t ret;
    cap_t ut_cap;
    word_t i = ndks_boot.slot_pos_cur - first_untyped_slot;
    if (i < 280) {
        ndks_boot.bi_frame->untypedList[i] = (seL4_UntypedDesc) {
            addrFromPPtr((void*)pptr), 0, 0, size_bits, device_memory
        };
        ut_cap = cap_untyped_cap_new(((1ul << ((size_bits) - 4))),
                                     device_memory, size_bits, pptr);
        ret = provide_cap(root_cnode_cap, ut_cap);
    } else {
        kprintf("Kernel init: Too many untyped regions for boot info\n");
        ret = true;
    }
    return ret;
}

/** DONT_TRANSLATE */
__attribute__((__section__(".boot.text"))) static word_t boot_ctzl (word_t x)
{
    return ctzl(x);
}

__attribute__((__section__(".boot.text"))) bool_t
create_untypeds_for_region(
    cap_t root_cnode_cap,
    bool_t device_memory,
    region_t reg,
    seL4_SlotPos first_untyped_slot
)
{
    word_t align_bits;
    word_t size_bits;

    while (!is_reg_empty(reg)) {
        /* Determine the maximum size of the region */
        size_bits = (sizeof(seL4_Word) * 8) - 1 - clzl(reg.end - reg.start);

        /* Determine the alignment of the region */
        if (reg.start != 0) {
            align_bits = boot_ctzl(reg.start);
        } else {
            align_bits = size_bits;
        }
        /* Reduce size bits to align if needed */
        if (align_bits < size_bits) {
            size_bits = align_bits;
        }
        if (size_bits > 29) {
            size_bits = 29;
        }

        if (size_bits >= 4) {
            if (!provide_untyped_cap(root_cnode_cap, device_memory, reg.start, size_bits, first_untyped_slot)) {
                return false;
            }
        }
        reg.start += (1ul << (size_bits));
    }
    return true;
}

__attribute__((__section__(".boot.text"))) bool_t
create_kernel_untypeds(cap_t root_cnode_cap, region_t boot_mem_reuse_reg, seL4_SlotPos first_untyped_slot)
{
    word_t i;
    region_t reg;

    /* if boot_mem_reuse_reg is not empty, we can create UT objs from boot code/data frames */
    if (!create_untypeds_for_region(root_cnode_cap, false, boot_mem_reuse_reg, first_untyped_slot)) {
        return false;
    }

    /* convert remaining freemem into UT objects and provide the caps */
    for (i = 0; i < 2; i++) {
        reg = ndks_boot.freemem[i];
        ndks_boot.freemem[i] = (region_t){ .start = 0, .end = 0 };
        if (!create_untypeds_for_region(root_cnode_cap, false, reg, first_untyped_slot)) {
            return false;
        }
    }

    return true;
}

__attribute__((__section__(".boot.text"))) void
bi_finalise(void)
{
    seL4_SlotPos slot_pos_start = ndks_boot.slot_pos_cur;
    seL4_SlotPos slot_pos_end = ndks_boot.slot_pos_max;
    ndks_boot.bi_frame->empty = (seL4_SlotRegion) {
        slot_pos_start, slot_pos_end
    };
}
# 1 "/home/sel4/work/work2/kernel/src/kernel/cspace.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/kernel/cspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/kernel/cspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/kernel/cspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/kernel/cspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/kernel/cspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/kernel/cspace.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/kernel/cspace.c" 2

lookupCap_ret_t
lookupCap(tcb_t *thread, cptr_t cPtr)
{
    lookupSlot_raw_ret_t lu_ret;
    lookupCap_ret_t ret;

    lu_ret = lookupSlot(thread, cPtr);
    if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
        ret.status = lu_ret.status;
        ret.cap = cap_null_cap_new();
        return ret;
    }

    ret.status = EXCEPTION_NONE;
    ret.cap = lu_ret.slot->cap;
    return ret;
}

lookupCapAndSlot_ret_t
lookupCapAndSlot(tcb_t *thread, cptr_t cPtr)
{
    lookupSlot_raw_ret_t lu_ret;
    lookupCapAndSlot_ret_t ret;

    lu_ret = lookupSlot(thread, cPtr);
    if (__builtin_expect(!!(lu_ret.status != EXCEPTION_NONE), 0)) {
        ret.status = lu_ret.status;
        ret.slot = ((void *)0);
        ret.cap = cap_null_cap_new();
        return ret;
    }

    ret.status = EXCEPTION_NONE;
    ret.slot = lu_ret.slot;
    ret.cap = lu_ret.slot->cap;
    return ret;
}

lookupSlot_raw_ret_t
lookupSlot(tcb_t *thread, cptr_t capptr)
{
    cap_t threadRoot;
    resolveAddressBits_ret_t res_ret;
    lookupSlot_raw_ret_t ret;

    threadRoot = (((cte_t *)((word_t)(thread)&~((1ul << (10))-1ul)))+(tcbCTable))->cap;
    res_ret = resolveAddressBits(threadRoot, capptr, (1 << 5));

    ret.status = res_ret.status;
    ret.slot = res_ret.slot;
    return ret;
}

lookupSlot_ret_t
lookupSlotForCNodeOp(bool_t isSource, cap_t root, cptr_t capptr,
                     word_t depth)
{
    resolveAddressBits_ret_t res_ret;
    lookupSlot_ret_t ret;

    ret.slot = ((void *)0);

    if (__builtin_expect(!!(cap_get_capType(root) != cap_cnode_cap), 0)) {
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = isSource;
        current_lookup_fault = lookup_fault_invalid_root_new();
        ret.status = EXCEPTION_SYSCALL_ERROR;
        return ret;
    }

    if (__builtin_expect(!!(depth < 1 || depth > (1 << 5)), 0)) {
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 1;
        current_syscall_error.rangeErrorMax = (1 << 5);
        ret.status = EXCEPTION_SYSCALL_ERROR;
        return ret;
    }
    res_ret = resolveAddressBits(root, capptr, depth);
    if (__builtin_expect(!!(res_ret.status != EXCEPTION_NONE), 0)) {
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = isSource;
        /* current_lookup_fault will have been set by resolveAddressBits */
        ret.status = EXCEPTION_SYSCALL_ERROR;
        return ret;
    }

    if (__builtin_expect(!!(res_ret.bitsRemaining != 0), 0)) {
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = isSource;
        current_lookup_fault =
            lookup_fault_depth_mismatch_new(0, res_ret.bitsRemaining);
        ret.status = EXCEPTION_SYSCALL_ERROR;
        return ret;
    }

    ret.slot = res_ret.slot;
    ret.status = EXCEPTION_NONE;
    return ret;
}

lookupSlot_ret_t
lookupSourceSlot(cap_t root, cptr_t capptr, word_t depth)
{
    return lookupSlotForCNodeOp(true, root, capptr, depth);
}

lookupSlot_ret_t
lookupTargetSlot(cap_t root, cptr_t capptr, word_t depth)
{
    return lookupSlotForCNodeOp(false, root, capptr, depth);
}

lookupSlot_ret_t
lookupPivotSlot(cap_t root, cptr_t capptr, word_t depth)
{
    return lookupSlotForCNodeOp(true, root, capptr, depth);
}

resolveAddressBits_ret_t
resolveAddressBits(cap_t nodeCap, cptr_t capptr, word_t n_bits)
{
    resolveAddressBits_ret_t ret;
    word_t radixBits, guardBits, levelBits, guard;
    word_t capGuard, offset;
    cte_t *slot;

    ret.bitsRemaining = n_bits;
    ret.slot = ((void *)0);

    if (__builtin_expect(!!(cap_get_capType(nodeCap) != cap_cnode_cap), 0)) {
        current_lookup_fault = lookup_fault_invalid_root_new();
        ret.status = EXCEPTION_LOOKUP_FAULT;
        return ret;
    }

    while (1) {
        radixBits = cap_cnode_cap_get_capCNodeRadix(nodeCap);
        guardBits = cap_cnode_cap_get_capCNodeGuardSize(nodeCap);
        levelBits = radixBits + guardBits;

        /* Haskell error: "All CNodes must resolve bits" */
        if(!(levelBits != 0)) _assert_fail("levelBits != 0", "/home/sel4/work/work2/kernel/src/kernel/cspace.c", 160, __FUNCTION__);

        capGuard = cap_cnode_cap_get_capCNodeGuard(nodeCap);

        /* sjw --- the MASK(5) here is to avoid the case where n_bits = 32
           and guardBits = 0, as it violates the C spec to >> by more
           than 31 */

        guard = (capptr >> ((n_bits - guardBits) & ((1ul << (5))-1ul))) & ((1ul << (guardBits))-1ul);
        if (__builtin_expect(!!(guardBits > n_bits || guard != capGuard), 0)) {
            current_lookup_fault =
                lookup_fault_guard_mismatch_new(capGuard, n_bits, guardBits);
            ret.status = EXCEPTION_LOOKUP_FAULT;
            return ret;
        }

        if (__builtin_expect(!!(levelBits > n_bits), 0)) {
            current_lookup_fault =
                lookup_fault_depth_mismatch_new(levelBits, n_bits);
            ret.status = EXCEPTION_LOOKUP_FAULT;
            return ret;
        }

        offset = (capptr >> (n_bits - levelBits)) & ((1ul << (radixBits))-1ul);
        slot = ((cte_t *)(cap_cnode_cap_get_capCNodePtr(nodeCap))) + offset;

        if (__builtin_expect(!!(n_bits <= levelBits), 1)) {
            ret.status = EXCEPTION_NONE;
            ret.slot = slot;
            ret.bitsRemaining = 0;
            return ret;
        }

        /** GHOSTUPD: "(\<acute>levelBits > 0, id)" */

        n_bits -= levelBits;
        nodeCap = slot->cap;

        if (__builtin_expect(!!(cap_get_capType(nodeCap) != cap_cnode_cap), 0)) {
            ret.status = EXCEPTION_NONE;
            ret.slot = slot;
            ret.bitsRemaining = n_bits;
            return ret;
        }
    }

    ret.status = EXCEPTION_NONE;
    return ret;
}
# 1 "/home/sel4/work/work2/kernel/src/kernel/faulthandler.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/kernel/faulthandler.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/kernel/faulthandler.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/faulthandler.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/kernel/faulthandler.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/kernel/faulthandler.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/kernel/faulthandler.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/kernel/faulthandler.c" 2

void
handleFault(tcb_t *tptr)
{
    exception_t status;
    seL4_Fault_t fault = current_fault;

    status = sendFaultIPC(tptr);
    if (status != EXCEPTION_NONE) {
        handleDoubleFault(tptr, fault);
    }
}

exception_t
sendFaultIPC(tcb_t *tptr)
{
    cptr_t handlerCPtr;
    cap_t handlerCap;
    lookupCap_ret_t lu_ret;
    lookup_fault_t original_lookup_fault;

    original_lookup_fault = current_lookup_fault;

    handlerCPtr = tptr->tcbFaultHandler;
    lu_ret = lookupCap(tptr, handlerCPtr);
    if (lu_ret.status != EXCEPTION_NONE) {
        current_fault = seL4_Fault_CapFault_new(handlerCPtr, false);
        return EXCEPTION_FAULT;
    }
    handlerCap = lu_ret.cap;

    if (cap_get_capType(handlerCap) == cap_endpoint_cap &&
            cap_endpoint_cap_get_capCanSend(handlerCap) &&
            cap_endpoint_cap_get_capCanGrant(handlerCap)) {
        tptr->tcbFault = current_fault;
        if (seL4_Fault_get_seL4_FaultType(current_fault) == seL4_Fault_CapFault) {
            tptr->tcbLookupFailure = original_lookup_fault;
        }
        sendIPC(true, false,
                cap_endpoint_cap_get_capEPBadge(handlerCap),
                true, tptr,
                ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(handlerCap))));

        return EXCEPTION_NONE;
    } else {
        current_fault = seL4_Fault_CapFault_new(handlerCPtr, false);
        current_lookup_fault = lookup_fault_missing_capability_new(0);

        return EXCEPTION_FAULT;
    }
}


static void
print_fault(seL4_Fault_t f)
{
    switch (seL4_Fault_get_seL4_FaultType(f)) {
    case seL4_Fault_NullFault:
        kprintf("null fault");
        break;
    case seL4_Fault_CapFault:
        kprintf("cap fault in %s phase at address 0x%x", seL4_Fault_CapFault_get_inReceivePhase(f) ? "receive" : "send", (unsigned int)seL4_Fault_CapFault_get_address(f))

                                                                ;
        break;
    case seL4_Fault_VMFault:
        kprintf("vm fault on %s at address 0x%x with status 0x%x", seL4_Fault_VMFault_get_instructionFault(f) ? "code" : "data", (unsigned int)seL4_Fault_VMFault_get_address(f), (unsigned int)seL4_Fault_VMFault_get_FSR(f))


                                                           ;
        break;
    case seL4_Fault_UnknownSyscall:
        kprintf("unknown syscall 0x%x", (unsigned int)seL4_Fault_UnknownSyscall_get_syscallNumber(f))
                                                                            ;
        break;
    case seL4_Fault_UserException:
        kprintf("user exception 0x%x code 0x%x", (unsigned int)seL4_Fault_UserException_get_number(f), (unsigned int)seL4_Fault_UserException_get_code(f))

                                                                  ;
        break;
    default:
        kprintf("unknown fault");
        break;
    }
}


/* The second fault, ex2, is stored in the global current_fault */
void
handleDoubleFault(tcb_t *tptr, seL4_Fault_t ex1)
{

    seL4_Fault_t ex2 = current_fault;
    kprintf("Caught ");
    print_fault(ex2);
    kprintf("\nwhile trying to handle:\n");
    print_fault(ex1);


    kprintf("\nin thread %p \"%s\" ", tptr, tptr->tcbName);


    kprintf("at address %p\n", (void*)getRestartPC(tptr));
    kprintf("With stack:\n");
    Arch_userStackTrace(tptr);


    setThreadState(tptr, ThreadState_Inactive);
}
# 1 "/home/sel4/work/work2/kernel/src/kernel/stack.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 1 "/home/sel4/work/work2/kernel/include/kernel/stack.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/kernel/stack.c" 2

__attribute__((externally_visible)) __attribute__((__aligned__(16)))
char kernel_stack_alloc[1][(1ul << (12))];
# 1 "/home/sel4/work/work2/kernel/src/kernel/thread.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/faults.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/src/kernel/thread.c" 2

static seL4_MessageInfo_t
transferCaps(seL4_MessageInfo_t info, extra_caps_t caps,
             endpoint_t *endpoint, tcb_t *receiver,
             word_t *receiveBuffer);

static inline bool_t __attribute__((__pure__))
isBlocked(const tcb_t *thread)
{
    switch (thread_state_get_tsType(thread->tcbState)) {
    case ThreadState_Inactive:
    case ThreadState_BlockedOnReceive:
    case ThreadState_BlockedOnSend:
    case ThreadState_BlockedOnNotification:
    case ThreadState_BlockedOnReply:
        return true;

    default:
        return false;
    }
}

__attribute__((__section__(".boot.text"))) void
configureIdleThread(tcb_t *tcb)
{
    Arch_configureIdleThread(tcb);
    setThreadState(tcb, ThreadState_IdleThreadState);
}

void
activateThread(void)
{
    switch (thread_state_get_tsType(ksCurThread->tcbState)) {
    case ThreadState_Running:



        break;

    case ThreadState_Restart: {
        word_t pc;

        pc = getRestartPC(ksCurThread);
        setNextPC(ksCurThread, pc);
        setThreadState(ksCurThread, ThreadState_Running);
        break;
    }

    case ThreadState_IdleThreadState:
        Arch_activateIdleThread(ksCurThread);
        break;

    default:
        _fail("Current thread is blocked", "/home/sel4/work/work2/kernel/src/kernel/thread.c", 77, __func__);
    }
}

void
suspend(tcb_t *target)
{
    cancelIPC(target);
    setThreadState(target, ThreadState_Inactive);
    tcbSchedDequeue(target);
}

void
restart(tcb_t *target)
{
    if (isBlocked(target)) {
        cancelIPC(target);
        setupReplyMaster(target);
        setThreadState(target, ThreadState_Restart);
        tcbSchedEnqueue(target);
        switchIfRequiredTo(target);
    }
}

void
doIPCTransfer(tcb_t *sender, endpoint_t *endpoint, word_t badge,
              bool_t grant, tcb_t *receiver)
{
    void *receiveBuffer, *sendBuffer;

    receiveBuffer = lookupIPCBuffer(true, receiver);

    if (__builtin_expect(!!(seL4_Fault_get_seL4_FaultType(sender->tcbFault) == seL4_Fault_NullFault), 1)) {
        sendBuffer = lookupIPCBuffer(false, sender);
        doNormalTransfer(sender, sendBuffer, endpoint, badge, grant,
                         receiver, receiveBuffer);
    } else {
        doFaultTransfer(badge, sender, receiver, receiveBuffer);
    }
}

void
doReplyTransfer(tcb_t *sender, tcb_t *receiver, cte_t *slot)
{
    if(!(thread_state_get_tsType(receiver->tcbState) == ThreadState_BlockedOnReply)) _assert_fail("thread_state_get_tsType(receiver->tcbState) == ThreadState_BlockedOnReply",
                                     "/home/sel4/work/work2/kernel/src/kernel/thread.c"
# 121 "/home/sel4/work/work2/kernel/src/kernel/thread.c"
    ,
                                     122
# 121 "/home/sel4/work/work2/kernel/src/kernel/thread.c"
    , __FUNCTION__)
                                      ;

    if (__builtin_expect(!!(seL4_Fault_get_seL4_FaultType(receiver->tcbFault) == seL4_Fault_NullFault), 1)) {
        doIPCTransfer(sender, ((void *)0), 0, true, receiver);
        /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (ucast cap_reply_cap))" */
        cteDeleteOne(slot);
        setThreadState(receiver, ThreadState_Running);
        attemptSwitchTo(receiver);
    } else {
        bool_t restart;

        /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (ucast cap_reply_cap))" */
        cteDeleteOne(slot);
        restart = handleFaultReply(receiver, sender);
        receiver->tcbFault = seL4_Fault_NullFault_new();
        if (restart) {
            setThreadState(receiver, ThreadState_Restart);
            attemptSwitchTo(receiver);
        } else {
            setThreadState(receiver, ThreadState_Inactive);
        }
    }
}

void
doNormalTransfer(tcb_t *sender, word_t *sendBuffer, endpoint_t *endpoint,
                 word_t badge, bool_t canGrant, tcb_t *receiver,
                 word_t *receiveBuffer)
{
    word_t msgTransferred;
    seL4_MessageInfo_t tag;
    exception_t status;
    extra_caps_t caps;

    tag = messageInfoFromWord(getRegister(sender, msgInfoRegister));

    if (canGrant) {
        status = lookupExtraCaps(sender, sendBuffer, tag);
        caps = current_extra_caps;
        if (__builtin_expect(!!(status != EXCEPTION_NONE), 0)) {
            caps.excaprefs[0] = ((void *)0);
        }
    } else {
        caps = current_extra_caps;
        caps.excaprefs[0] = ((void *)0);
    }

    msgTransferred = copyMRs(sender, sendBuffer, receiver, receiveBuffer,
                             seL4_MessageInfo_get_length(tag));

    tag = transferCaps(tag, caps, endpoint, receiver, receiveBuffer);

    tag = seL4_MessageInfo_set_length(tag, msgTransferred);
    setRegister(receiver, msgInfoRegister, wordFromMessageInfo(tag));
    setRegister(receiver, badgeRegister, badge);
}

void
doFaultTransfer(word_t badge, tcb_t *sender, tcb_t *receiver,
                word_t *receiverIPCBuffer)
{
    word_t sent;
    seL4_MessageInfo_t msgInfo;

    sent = setMRs_fault(sender, receiver, receiverIPCBuffer);
    msgInfo = seL4_MessageInfo_new(
                  seL4_Fault_get_seL4_FaultType(sender->tcbFault), 0, 0, sent);
    setRegister(receiver, msgInfoRegister, wordFromMessageInfo(msgInfo));
    setRegister(receiver, badgeRegister, badge);
}

/* Like getReceiveSlots, this is specialised for single-cap transfer. */
static seL4_MessageInfo_t
transferCaps(seL4_MessageInfo_t info, extra_caps_t caps,
             endpoint_t *endpoint, tcb_t *receiver,
             word_t *receiveBuffer)
{
    word_t i;
    cte_t* destSlot;

    info = seL4_MessageInfo_set_extraCaps(info, 0);
    info = seL4_MessageInfo_set_capsUnwrapped(info, 0);

    if (__builtin_expect(!!(!caps.excaprefs[0] || !receiveBuffer), 1)) {
        return info;
    }

    destSlot = getReceiveSlots(receiver, receiveBuffer);

    for (i = 0; i < ((1ul<<(seL4_MsgExtraCapBits))-1) && caps.excaprefs[i] != ((void *)0); i++) {
        cte_t *slot = caps.excaprefs[i];
        cap_t cap = slot->cap;

        if (cap_get_capType(cap) == cap_endpoint_cap &&
                ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(cap))) == endpoint) {
            /* If this is a cap to the endpoint on which the message was sent,
             * only transfer the badge, not the cap. */
            setExtraBadge(receiveBuffer,
                          cap_endpoint_cap_get_capEPBadge(cap), i);

            info = seL4_MessageInfo_set_capsUnwrapped(info,
                                                      seL4_MessageInfo_get_capsUnwrapped(info) | (1 << i));

        } else {
            deriveCap_ret_t dc_ret;

            if (!destSlot) {
                break;
            }

            dc_ret = deriveCap(slot, cap);

            if (dc_ret.status != EXCEPTION_NONE) {
                break;
            }
            if (cap_get_capType(dc_ret.cap) == cap_null_cap) {
                break;
            }

            cteInsert(dc_ret.cap, slot, destSlot);

            destSlot = ((void *)0);
        }
    }

    return seL4_MessageInfo_set_extraCaps(info, i);
}

void doNBRecvFailedTransfer(tcb_t *thread)
{
    /* Set the badge register to 0 to indicate there was no message */
    setRegister(thread, badgeRegister, 0);
}

static void
nextDomain(void)
{
    ksDomScheduleIdx++;
    if (ksDomScheduleIdx >= ksDomScheduleLength) {
        ksDomScheduleIdx = 0;
    }
    ksWorkUnitsCompleted = 0;
    ksCurDomain = ksDomSchedule[ksDomScheduleIdx].domain;
    ksDomainTime = ksDomSchedule[ksDomScheduleIdx].length;
}

void
schedule(void)
{
    word_t action;

    action = (word_t)ksSchedulerAction;
    if (action == (word_t)((tcb_t*)~0)) {
        if (isRunnable(ksCurThread)) {
            tcbSchedEnqueue(ksCurThread);
        }
        if (ksDomainTime == 0) {
            nextDomain();
        }
        chooseThread();
        ksSchedulerAction = ((tcb_t*)0);
    } else if (action != (word_t)((tcb_t*)0)) {
        if (isRunnable(ksCurThread)) {
            tcbSchedEnqueue(ksCurThread);
        }
        /* SwitchToThread */
        switchToThread(ksSchedulerAction);
        ksSchedulerAction = ((tcb_t*)0);
    }





}

void
chooseThread(void)
{
    word_t prio;
    word_t dom;
    tcb_t *thread;

    if (1 > 1) {
        dom = ksCurDomain;
    } else {
        dom = 0;
    }

    if (__builtin_expect(!!(ksReadyQueuesL1Bitmap[dom]), 1)) {
        word_t l1index = ((1 << 5) - 1) - clzl(ksReadyQueuesL1Bitmap[dom]);
        word_t l2index = ((1 << 5) - 1) - clzl(ksReadyQueuesL2Bitmap[dom][l1index]);
        prio = l1index_to_prio(l1index) | l2index;
        thread = ksReadyQueues[ready_queues_index(dom, prio)].head;
        if(!(thread)) _assert_fail("thread", "/home/sel4/work/work2/kernel/src/kernel/thread.c", 316, __FUNCTION__);
        if(!(isRunnable(thread))) _assert_fail("isRunnable(thread)", "/home/sel4/work/work2/kernel/src/kernel/thread.c", 317, __FUNCTION__);
        switchToThread(thread);
    } else {
        switchToIdleThread();
    }
}

void
switchToThread(tcb_t *thread)
{



    Arch_switchToThread(thread);
    tcbSchedDequeue(thread);
    ksCurThread = thread;
}

void
switchToIdleThread(void)
{



    Arch_switchToIdleThread();
    ksCurThread = ksIdleThread;
}

void
setDomain(tcb_t *tptr, dom_t dom)
{
    tcbSchedDequeue(tptr);
    tptr->tcbDomain = dom;
    if (isRunnable(tptr)) {
        tcbSchedEnqueue(tptr);
    }
    if (tptr == ksCurThread) {
        rescheduleRequired();
    }
}

void
setMCPriority(tcb_t *tptr, prio_t mcp)
{
    tptr->tcbMCP = mcp;
}

void
setPriority(tcb_t *tptr, prio_t prio)
{
    tcbSchedDequeue(tptr);
    tptr->tcbPriority = prio;
    if (isRunnable(tptr)) {
        tcbSchedEnqueue(tptr);
    }
    if (tptr == ksCurThread) {
        rescheduleRequired();
    }
}

static void
possibleSwitchTo(tcb_t* target, bool_t onSamePriority)
{
    dom_t curDom, targetDom;
    prio_t curPrio, targetPrio;
    tcb_t *action;

    curDom = ksCurDomain;
    curPrio = ksCurThread->tcbPriority;
    targetDom = target->tcbDomain;
    targetPrio = target->tcbPriority;
    action = ksSchedulerAction;
    if (targetDom != curDom) {
        tcbSchedEnqueue(target);
    } else {
        if ((targetPrio > curPrio || (targetPrio == curPrio && onSamePriority))
                && action == ((tcb_t*)0)
                ) {
            ksSchedulerAction = target;
        } else {
            tcbSchedEnqueue(target);
        }
        if (action != ((tcb_t*)0)
                && action != ((tcb_t*)~0)) {
            rescheduleRequired();
        }
    }
}

void
attemptSwitchTo(tcb_t* target)
{
    possibleSwitchTo(target, true);
}

void
switchIfRequiredTo(tcb_t* target)
{
    possibleSwitchTo(target, false);
}

void
setThreadState(tcb_t *tptr, _thread_state_t ts)
{
    thread_state_ptr_set_tsType(&tptr->tcbState, ts);
    scheduleTCB(tptr);
}

void
scheduleTCB(tcb_t *tptr)
{
    if (tptr == ksCurThread &&
            ksSchedulerAction == ((tcb_t*)0) &&
            !isRunnable(tptr)) {
        rescheduleRequired();
    }
}

void
timerTick(void)
{
    if (__builtin_expect(!!(thread_state_get_tsType(ksCurThread->tcbState) == ThreadState_Running), 1)
                                   ) {
        if (ksCurThread->tcbTimeSlice > 1) {
            ksCurThread->tcbTimeSlice--;
        } else {
            ksCurThread->tcbTimeSlice = 5;
            tcbSchedAppend(ksCurThread);
            rescheduleRequired();
        }
    }

    if (1 > 1) {
        ksDomainTime--;
        if (ksDomainTime == 0) {
            rescheduleRequired();
        }
    }
}

void
rescheduleRequired(void)
{
    if (ksSchedulerAction != ((tcb_t*)0)
            && ksSchedulerAction != ((tcb_t*)~0)) {
        tcbSchedEnqueue(ksSchedulerAction);
    }
    ksSchedulerAction = ((tcb_t*)~0);
}
# 1 "/home/sel4/work/work2/kernel/src/machine/fpu.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/machine/fpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/fpu.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/machine/fpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/machine/fpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/machine/fpu.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/machine/fpu.c" 2


/* Switch the owner of the FPU to the given thread on local core. */
void switchLocalFpuOwner(user_fpu_state_t *new_owner)
{
    enableFpu();
    if (ksActiveFPUState) {
        saveFpuState(ksActiveFPUState);
    }
    if (new_owner) {
        ksFPURestoresSinceSwitch = 0;
        loadFpuState(new_owner);
    } else {
        disableFpu();
    }
    ksActiveFPUState = new_owner;
}

void switchFpuOwner(user_fpu_state_t *new_owner, word_t cpu)
{





    {
        switchLocalFpuOwner(new_owner);
    }
}

/* Handle a FPU fault.
 *
 * This CPU exception is thrown when userspace attempts to use the FPU while
 * it is disabled. We need to save the current state of the FPU, and hand
 * it over. */
exception_t
handleFPUFault(void)
{
    /* If we have already given the FPU to the user, we should not reach here.
     * This should only be able to occur on CPUs without an FPU at all, which
     * we presumably are happy to assume will not be running seL4. */
    if(!(!nativeThreadUsingFPU(ksCurThread))) _assert_fail("!nativeThreadUsingFPU(NODE_STATE(ksCurThread))", "/home/sel4/work/work2/kernel/src/machine/fpu.c", 59, __FUNCTION__);

    /* Otherwise, lazily switch over the FPU. */
    switchLocalFpuOwner(&ksCurThread->tcbArch.tcbContext.fpuState);

    return EXCEPTION_NONE;
}

/* Prepare for the deletion of the given thread. */
void fpuThreadDelete(tcb_t *thread)
{
    /* If the thread being deleted currently owns the FPU, switch away from it
     * so that 'ksActiveFPUState' doesn't point to invalid memory. */
    if (nativeThreadUsingFPU(thread)) {
        switchFpuOwner(((void *)0), 0);
    }
}
# 1 "/home/sel4/work/work2/kernel/src/machine/io.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/machine/io.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/machine/io.c" 2



# 1 "/home/sel4/work/work2/kernel/include/stdarg.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */







typedef __builtin_va_list va_list;
# 17 "/home/sel4/work/work2/kernel/src/machine/io.c" 2

void
putchar(char c)
{
    putConsoleChar(c);
    if (c == '\n') {
        putConsoleChar('\r');
    }
}

static unsigned int
print_spaces(int n)
{
    for (int i = 0; i < n; i++) {
        putchar(' ');
    }

    return n;
}

static unsigned int
print_string(const char *s)
{
    unsigned int n;

    for (n = 0; *s; s++, n++) {
        putchar(*s);
    }

    return n;
}

static unsigned long
xdiv(unsigned long x, unsigned int denom)
{
    switch (denom) {
    case 16:
        return x / 16;
    case 10:
        return x / 10;
    default:
        return 0;
    }
}

static unsigned long
xmod(unsigned long x, unsigned int denom)
{
    switch (denom) {
    case 16:
        return x % 16;
    case 10:
        return x % 10;
    default:
        return 0;
    }
}

word_t
print_unsigned_long(unsigned long x, word_t ui_base)
{
    char out[sizeof(unsigned long) * 2 + 3];
    word_t i, j;
    unsigned int d;

    /*
     * Only base 10 and 16 supported for now. We want to avoid invoking the
     * compiler's support libraries through doing arbitrary divisions.
     */
    if (ui_base != 10 && ui_base != 16) {
        return 0;
    }

    if (x == 0) {
        putchar('0');
        return 1;
    }

    for (i = 0; x; x = xdiv(x, ui_base), i++) {
        d = xmod(x, ui_base);

        if (d >= 10) {
            out[i] = 'a' + d - 10;
        } else {
            out[i] = '0' + d;
        }
    }

    for (j = i; j > 0; j--) {
        putchar(out[j - 1]);
    }

    return i;
}

/* The print_unsigned_long_long function assumes that an unsinged int
   is half the size of an unsigned long long */
typedef int __assert_failed_print_unsigned_long_long_sizes[(sizeof(unsigned int) * 2 == sizeof(unsigned long long)) ? 1 : -1];

static unsigned int
print_unsigned_long_long(unsigned long long x, unsigned int ui_base)
{
    unsigned int upper, lower;
    unsigned int n = 0;
    unsigned int mask = 0xF0000000u;
    unsigned int shifts = 0;

    /* only implemented for hex, decimal is harder without 64 bit division */
    if (ui_base != 16) {
        return 0;
    }

    /* we can't do 64 bit division so break it up into two hex numbers */
    upper = (unsigned int) (x >> 32llu);
    lower = (unsigned int) x & 0xffffffff;

    /* print first 32 bits if they exist */
    if (upper > 0) {
        n += print_unsigned_long(upper, ui_base);
        /* print leading 0s */
        while (!(mask & lower)) {
            putchar('0');
            n++;
            mask = mask >> 4;
            shifts++;
            if (shifts == 8) {
                break;
            }
        }
    }
    /* print last 32 bits */
    n += print_unsigned_long(lower, ui_base);

    return n;
}

static inline bool_t
isdigit(char c)
{
    return c >= '0' &&
           c <= '9';
}

static inline int
atoi(char c)
{
    return c - '0';
}

static int
vprintf(const char *format, va_list ap)
{
    unsigned int n;
    unsigned int formatting;
    int nspaces = 0;

    if (!format) {
        return 0;
    }

    n = 0;
    formatting = 0;
    while (*format) {
        if (formatting) {
            while (isdigit(*format)) {
                nspaces = nspaces * 10 + atoi(*format);
                format++;
                if (format == ((void *)0)) {
                    break;
                }
            }
            switch (*format) {
            case '%':
                putchar('%');
                n++;
                format++;
                break;

            case 'd': {
                int x = __builtin_va_arg(ap,int);

                if (x < 0) {
                    putchar('-');
                    n++;
                    x = -x;
                }

                n += print_unsigned_long(x, 10);
                format++;
                break;
            }

            case 'u':
                n += print_unsigned_long(__builtin_va_arg(ap,unsigned int), 10);
                format++;
                break;

            case 'x':
                n += print_unsigned_long(__builtin_va_arg(ap,unsigned int), 16);
                format++;
                break;

            case 'p': {
                unsigned long p = __builtin_va_arg(ap,unsigned long);
                if (p == 0) {
                    n += print_string("(nil)");
                } else {
                    n += print_string("0x");
                    n += print_unsigned_long(p, 16);
                }
                format++;
                break;
            }

            case 's':
                n += print_string(__builtin_va_arg(ap,char *));
                format++;
                break;

            case 'l':
                format++;
                switch (*format) {
                case 'd': {
                    long x = __builtin_va_arg(ap,long);

                    if (x < 0) {
                        putchar('-');
                        n++;
                        x = -x;
                    }

                    n += print_unsigned_long((unsigned long)x, 10);
                    format++;
                }
                break;
                case 'l':
                    if (*(format + 1) == 'x') {
                        n += print_unsigned_long_long(__builtin_va_arg(ap,unsigned long long), 16);
                    }
                    format += 2;
                    break;
                case 'u':
                    n += print_unsigned_long(__builtin_va_arg(ap,unsigned long), 10);
                    format++;
                    break;
                case 'x':
                    n += print_unsigned_long(__builtin_va_arg(ap,unsigned long), 16);
                    format++;
                    break;

                default:
                    /* format not supported */
                    return -1;
                }
                break;
            default:
                /* format not supported */
                return -1;
            }

            n += print_spaces(nspaces - n);
            nspaces = 0;
            formatting = 0;
        } else {
            switch (*format) {
            case '%':
                formatting = 1;
                format++;
                break;

            default:
                putchar(*format);
                n++;
                format++;
                break;
            }
        }
    }

    return n;
}

word_t puts(const char *s)
{
    for (; *s; s++) {
        putchar(*s);
    }
    putchar('\n');
    return 0;
}

word_t
kprintf(const char *format, ...)
{
    va_list args;
    word_t i;

    __builtin_va_start(args,format);
    i = vprintf(format, args);
    __builtin_va_end(args);
    return i;
}
# 1 "/home/sel4/work/work2/kernel/src/machine/registerset.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 1 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/machine/registerset.c" 2

const register_t fault_messages[][(((n_syscallMessage)>(n_exceptionMessage))?(n_syscallMessage):(n_exceptionMessage))] = {
    [MessageID_Syscall] = { [seL4_UnknownSyscall_R0] = R0, [seL4_UnknownSyscall_R1] = R1, [seL4_UnknownSyscall_R2] = R2, [seL4_UnknownSyscall_R3] = R3, [seL4_UnknownSyscall_R4] = R4, [seL4_UnknownSyscall_R5] = R5, [seL4_UnknownSyscall_R6] = R6, [seL4_UnknownSyscall_R7] = R7, [seL4_UnknownSyscall_FaultIP] = FaultInstruction, [seL4_UnknownSyscall_SP] = SP, [seL4_UnknownSyscall_LR] = LR, [seL4_UnknownSyscall_CPSR] = CPSR},
    [MessageID_Exception] = { [seL4_UserException_FaultIP] = FaultInstruction, [seL4_UserException_SP] = SP, [seL4_UserException_CPSR] = CPSR }
};
# 1 "/home/sel4/work/work2/kernel/src/model/preemption.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/model/preemption.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/preemption.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/include/model/preemption.h" 2

exception_t preemptionPoint(void);
# 13 "/home/sel4/work/work2/kernel/src/model/preemption.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/model/preemption.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/model/preemption.c" 2
# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/model/preemption.c" 2

/*
 * Possibly preempt the current thread to allow an interrupt to be handled.
 */
exception_t
preemptionPoint(void)
{
    /* Record that we have performed some work. */
    ksWorkUnitsCompleted++;

    /*
     * If we have performed a non-trivial amount of work since last time we
     * checked for preemption, and there is an interrupt pending, handle the
     * interrupt.
     *
     * We avoid checking for pending IRQs every call, as our callers tend to
     * call us in a tight loop and checking for pending IRQs can be quite slow.
     */
    if (ksWorkUnitsCompleted >= 100) {
        ksWorkUnitsCompleted = 0;
        if (isIRQPending()) {
            return EXCEPTION_PREEMPTED;
        }
    }

    return EXCEPTION_NONE;
}
# 1 "/home/sel4/work/work2/kernel/src/model/statedata.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/debug.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/include/api/debug.h" 2
# 13 "/home/sel4/work/work2/kernel/src/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/smp.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/model/statedata.c" 2
# 1 "/home/sel4/work/work2/kernel/include/benchmark/benchmark_track.h" 1
/*
 * Copyright 2016, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/model/statedata.c" 2

/* Collective cpu states, including both pre core architecture dependant and independent data */
;

/* Global count of how many cpus there are */
word_t ksNumCPUs;

/* Pointer to the head of the scheduler queue for each priority */
tcb_queue_t ksReadyQueues[(1 * 256)];
word_t ksReadyQueuesL1Bitmap[1];
word_t ksReadyQueuesL2Bitmap[1][(256 / (1 << 5)) + 1];
typedef int __assert_failed_ksReadyQueuesL1BitmapBigEnough[((256 / (1 << 5)) <= (1 << 5)) ? 1 : -1];

/* Current thread TCB pointer */
tcb_t * ksCurThread;

/* Idle thread TCB pointer */
tcb_t * ksIdleThread;

/* Values of 0 and ~0 encode ResumeCurrentThread and ChooseNewThread
 * respectively; other values encode SwitchToThread and must be valid
 * tcb pointers */
tcb_t * ksSchedulerAction;


/* Currently active FPU state, or NULL if there is no active FPU state */
user_fpu_state_t * ksActiveFPUState;

word_t ksFPURestoresSinceSwitch;



tcb_t * ksDebugTCBs;


/* Units of work we have completed since the last time we checked for
 * pending interrupts */
word_t ksWorkUnitsCompleted;

/* CNode containing interrupt handler endpoints */
irq_state_t intStateIRQTable[maxIRQ + 1];
cte_t *intStateIRQNode;

/* Currently active domain */
dom_t ksCurDomain;

/* Domain timeslice remaining */
word_t ksDomainTime;

/* An index into ksDomSchedule for active domain and length. */
word_t ksDomScheduleIdx;

/* Only used by lockTLBEntry */
word_t tlbLockCount = 0;


kernel_entry_t ksKernelEntry;
# 1 "/home/sel4/work/work2/kernel/src/object/cnode.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "./api/invocation.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 15 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/untyped.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/preemption.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 27 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 28 "/home/sel4/work/work2/kernel/src/object/cnode.c" 2

struct finaliseSlot_ret {
    exception_t status;
    bool_t success;
    irq_t irq;
};
typedef struct finaliseSlot_ret finaliseSlot_ret_t;

static finaliseSlot_ret_t finaliseSlot(cte_t *slot, bool_t exposed);
static void emptySlot(cte_t *slot, irq_t irq);
static exception_t reduceZombie(cte_t* slot, bool_t exposed);

exception_t
decodeCNodeInvocation(word_t invLabel, word_t length, cap_t cap,
                      extra_caps_t excaps, word_t *buffer)
{
    lookupSlot_ret_t lu_ret;
    cte_t *destSlot;
    word_t index, w_bits;
    exception_t status;

    /* Haskell error: "decodeCNodeInvocation: invalid cap" */
    if(!(cap_get_capType(cap) == cap_cnode_cap)) _assert_fail("cap_get_capType(cap) == cap_cnode_cap", "/home/sel4/work/work2/kernel/src/object/cnode.c", 50, __FUNCTION__);

    if (invLabel < CNodeRevoke || invLabel > CNodeSaveCaller) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 53, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNodeCap: Illegal Operation attempted."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (length < 2) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 59, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode operation: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }
    index = getSyscallArg(0, buffer);
    w_bits = getSyscallArg(1, buffer);

    lu_ret = lookupTargetSlot(cap, index, w_bits);
    if (lu_ret.status != EXCEPTION_NONE) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 68, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode operation: Target slot invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
        return lu_ret.status;
    }
    destSlot = lu_ret.slot;

    if (invLabel >= CNodeCopy && invLabel <= CNodeMutate) {
        cte_t *srcSlot;
        word_t srcIndex, srcDepth, capData;
        bool_t isMove;
        seL4_CapRights_t cap_rights;
        cap_t srcRoot, newCap;
        deriveCap_ret_t dc_ret;
        cap_t srcCap;

        if (length < 4 || excaps.excaprefs[0] == ((void *)0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 83, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode Copy/Mint/Move/Mutate: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }
        srcIndex = getSyscallArg(2, buffer);
        srcDepth = getSyscallArg(3, buffer);

        srcRoot = excaps.excaprefs[0]->cap;

        status = ensureEmptySlot(destSlot);
        if (status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 94, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode Copy/Mint/Move/Mutate: Destination not empty."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return status;
        }

        lu_ret = lookupSourceSlot(srcRoot, srcIndex, srcDepth);
        if (lu_ret.status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 100, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode Copy/Mint/Move/Mutate: Invalid source slot."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return lu_ret.status;
        }
        srcSlot = lu_ret.slot;

        if (cap_get_capType(srcSlot->cap) == cap_null_cap) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 106, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode Copy/Mint/Move/Mutate: Source slot invalid or empty."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = 1;
            current_lookup_fault =
                lookup_fault_missing_capability_new(srcDepth);
            return EXCEPTION_SYSCALL_ERROR;
        }

        switch (invLabel) {
        case CNodeCopy:

            if (length < 5) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 118, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Truncated message for CNode Copy operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
                current_syscall_error.type = seL4_TruncatedMessage;
                return EXCEPTION_SYSCALL_ERROR;
            }

            cap_rights = rightsFromWord(getSyscallArg(4, buffer));
            srcCap = maskCapRights(cap_rights, srcSlot->cap);
            dc_ret = deriveCap(srcSlot, srcCap);
            if (dc_ret.status != EXCEPTION_NONE) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 127, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Error deriving cap for CNode Copy operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
                return dc_ret.status;
            }
            newCap = dc_ret.cap;
            isMove = false;

            break;

        case CNodeMint:
            if (length < 6) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 137, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode Mint: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
                current_syscall_error.type = seL4_TruncatedMessage;
                return EXCEPTION_SYSCALL_ERROR;
            }

            cap_rights = rightsFromWord(getSyscallArg(4, buffer));
            capData = getSyscallArg(5, buffer);
            srcCap = maskCapRights(cap_rights, srcSlot->cap);
            dc_ret = deriveCap(srcSlot,
                               updateCapData(false, capData, srcCap));
            if (dc_ret.status != EXCEPTION_NONE) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 148, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Error deriving cap for CNode Mint operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
                return dc_ret.status;
            }
            newCap = dc_ret.cap;
            isMove = false;

            break;

        case CNodeMove:
            newCap = srcSlot->cap;
            isMove = true;

            break;

        case CNodeMutate:
            if (length < 5) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 164, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode Mutate: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
                current_syscall_error.type = seL4_TruncatedMessage;
                return EXCEPTION_SYSCALL_ERROR;
            }

            capData = getSyscallArg(4, buffer);
            newCap = updateCapData(true, capData, srcSlot->cap);
            isMove = true;

            break;

        default:
            if(!(0)) _assert_fail("0", "/home/sel4/work/work2/kernel/src/object/cnode.c", 176, __FUNCTION__);
            return EXCEPTION_NONE;
        }

        if (cap_get_capType(newCap) == cap_null_cap) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 181, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode Copy/Mint/Move/Mutate: Mutated cap would be invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        if (isMove) {
            return invokeCNodeMove(newCap, srcSlot, destSlot);
        } else {
            return invokeCNodeInsert(newCap, srcSlot, destSlot);
        }
    }

    if (invLabel == CNodeRevoke) {
        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeCNodeRevoke(destSlot);
    }

    if (invLabel == CNodeDelete) {
        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeCNodeDelete(destSlot);
    }

    if (invLabel == CNodeSaveCaller) {
        status = ensureEmptySlot(destSlot);
        if (status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 207, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode SaveCaller: Destination slot not empty."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return status;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeCNodeSaveCaller(destSlot);
    }

    if (invLabel == CNodeCancelBadgedSends) {
        cap_t destCap;

        destCap = destSlot->cap;

        if (!hasCancelSendRights(destCap)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 221, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode CancelBadgedSends: Target cap invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }
        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeCNodeCancelBadgedSends(destCap);
    }

    if (invLabel == CNodeRotate) {
        word_t pivotNewData, pivotIndex, pivotDepth;
        word_t srcNewData, srcIndex, srcDepth;
        cte_t *pivotSlot, *srcSlot;
        cap_t pivotRoot, srcRoot, newSrcCap, newPivotCap;

        if (length < 8 || excaps.excaprefs[0] == ((void *)0)
                || excaps.excaprefs[1] == ((void *)0)) {
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }
        pivotNewData = getSyscallArg(2, buffer);
        pivotIndex = getSyscallArg(3, buffer);
        pivotDepth = getSyscallArg(4, buffer);
        srcNewData = getSyscallArg(5, buffer);
        srcIndex = getSyscallArg(6, buffer);
        srcDepth = getSyscallArg(7, buffer);

        pivotRoot = excaps.excaprefs[0]->cap;
        srcRoot = excaps.excaprefs[1]->cap;

        lu_ret = lookupSourceSlot(srcRoot, srcIndex, srcDepth);
        if (lu_ret.status != EXCEPTION_NONE) {
            return lu_ret.status;
        }
        srcSlot = lu_ret.slot;

        lu_ret = lookupPivotSlot(pivotRoot, pivotIndex, pivotDepth);
        if (lu_ret.status != EXCEPTION_NONE) {
            return lu_ret.status;
        }
        pivotSlot = lu_ret.slot;

        if (pivotSlot == srcSlot || pivotSlot == destSlot) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 263, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode Rotate: Pivot slot the same as source or dest slot."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }

        if (srcSlot != destSlot) {
            status = ensureEmptySlot(destSlot);
            if (status != EXCEPTION_NONE) {
                return status;
            }
        }

        if (cap_get_capType(srcSlot->cap) == cap_null_cap) {
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = 1;
            current_lookup_fault = lookup_fault_missing_capability_new(srcDepth);
            return EXCEPTION_SYSCALL_ERROR;
        }

        if (cap_get_capType(pivotSlot->cap) == cap_null_cap) {
            current_syscall_error.type = seL4_FailedLookup;
            current_syscall_error.failedLookupWasSource = 0;
            current_lookup_fault = lookup_fault_missing_capability_new(pivotDepth);
            return EXCEPTION_SYSCALL_ERROR;
        }

        newSrcCap = updateCapData(true, srcNewData, srcSlot->cap);
        newPivotCap = updateCapData(true, pivotNewData, pivotSlot->cap);

        if (cap_get_capType(newSrcCap) == cap_null_cap) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 293, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode Rotate: Source cap invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }

        if (cap_get_capType(newPivotCap) == cap_null_cap) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 299, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode Rotate: Pivot cap invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
            current_syscall_error.type = seL4_IllegalOperation;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeCNodeRotate(newSrcCap, newPivotCap,
                                 srcSlot, pivotSlot, destSlot);
    }

    return EXCEPTION_NONE;
}

exception_t
invokeCNodeRevoke(cte_t *destSlot)
{
    return cteRevoke(destSlot);
}

exception_t
invokeCNodeDelete(cte_t *destSlot)
{
    return cteDelete(destSlot, true);
}

exception_t
invokeCNodeCancelBadgedSends(cap_t cap)
{
    word_t badge = cap_endpoint_cap_get_capEPBadge(cap);
    if (badge) {
        endpoint_t* ep = (endpoint_t*)
                         cap_endpoint_cap_get_capEPPtr(cap);
        cancelBadgedSends(ep, badge);
    }
    return EXCEPTION_NONE;
}

exception_t
invokeCNodeInsert(cap_t cap, cte_t *srcSlot, cte_t *destSlot)
{
    cteInsert(cap, srcSlot, destSlot);

    return EXCEPTION_NONE;
}

exception_t
invokeCNodeMove(cap_t cap, cte_t *srcSlot, cte_t *destSlot)
{
    cteMove(cap, srcSlot, destSlot);

    return EXCEPTION_NONE;
}

exception_t
invokeCNodeRotate(cap_t cap1, cap_t cap2, cte_t *slot1,
                  cte_t *slot2, cte_t *slot3)
{
    if (slot1 == slot3) {
        cteSwap(cap1, slot1, cap2, slot2);
    } else {
        cteMove(cap2, slot2, slot3);
        cteMove(cap1, slot1, slot2);
    }

    return EXCEPTION_NONE;
}

exception_t
invokeCNodeSaveCaller(cte_t *destSlot)
{
    cap_t cap;
    cte_t *srcSlot;

    srcSlot = (((cte_t *)((word_t)(ksCurThread)&~((1ul << (10))-1ul)))+(tcbCaller));
    cap = srcSlot->cap;

    switch (cap_get_capType(cap)) {
    case cap_null_cap:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 377, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("CNode SaveCaller: Reply cap not present."); kprintf(">>" "\033[0m" "\n"); } while (0);
        break;

    case cap_reply_cap:
        if (!cap_reply_cap_get_capReplyMaster(cap)) {
            cteMove(cap, srcSlot, destSlot);
        }
        break;

    default:
        _fail("caller capability must be null or reply", "/home/sel4/work/work2/kernel/src/object/cnode.c", 387, __func__);
        break;
    }

    return EXCEPTION_NONE;
}

/*
 * If creating a child UntypedCap, don't allow new objects to be created in the
 * parent.
 */
static void
setUntypedCapAsFull(cap_t srcCap, cap_t newCap, cte_t *srcSlot)
{
    if ((cap_get_capType(srcCap) == cap_untyped_cap)
            && (cap_get_capType(newCap) == cap_untyped_cap)) {
        if ((cap_untyped_cap_get_capPtr(srcCap)
                == cap_untyped_cap_get_capPtr(newCap))
                && (cap_untyped_cap_get_capBlockSize(newCap)
                    == cap_untyped_cap_get_capBlockSize(srcCap))) {
            cap_untyped_cap_ptr_set_capFreeIndex(&(srcSlot->cap),
                                                 ((1ul << ((cap_untyped_cap_get_capBlockSize(srcCap)) - 4))));
        }
    }
}

void
cteInsert(cap_t newCap, cte_t *srcSlot, cte_t *destSlot)
{
    mdb_node_t srcMDB, newMDB;
    cap_t srcCap;
    bool_t newCapIsRevocable;

    srcMDB = srcSlot->cteMDBNode;
    srcCap = srcSlot->cap;

    switch (cap_get_capType(newCap)) {
    case cap_endpoint_cap:
        newCapIsRevocable = (cap_endpoint_cap_get_capEPBadge(newCap) !=
                             cap_endpoint_cap_get_capEPBadge(srcCap));
        break;

    case cap_notification_cap:
        newCapIsRevocable =
            (cap_notification_cap_get_capNtfnBadge(newCap) !=
             cap_notification_cap_get_capNtfnBadge(srcCap));
        break;

    case cap_irq_handler_cap:
        newCapIsRevocable = (cap_get_capType(srcCap) ==
                             cap_irq_control_cap);
        break;

    case cap_untyped_cap:
        newCapIsRevocable = true;
        break;

    default:
        newCapIsRevocable = false;
        break;
    }

    newMDB = mdb_node_set_mdbPrev(srcMDB, ((word_t)(srcSlot)));
    newMDB = mdb_node_set_mdbRevocable(newMDB, newCapIsRevocable);
    newMDB = mdb_node_set_mdbFirstBadged(newMDB, newCapIsRevocable);

    /* Haskell error: "cteInsert to non-empty destination" */
    if(!(cap_get_capType(destSlot->cap) == cap_null_cap)) _assert_fail("cap_get_capType(destSlot->cap) == cap_null_cap", "/home/sel4/work/work2/kernel/src/object/cnode.c", 454, __FUNCTION__);
    /* Haskell error: "cteInsert: mdb entry must be empty" */
    if(!((cte_t*)mdb_node_get_mdbNext(destSlot->cteMDBNode) == ((void *)0) && (cte_t*)mdb_node_get_mdbPrev(destSlot->cteMDBNode) == ((void *)0))) _assert_fail("(cte_t*)mdb_node_get_mdbNext(destSlot->cteMDBNode) == NULL && (cte_t*)mdb_node_get_mdbPrev(destSlot->cteMDBNode) == NULL",
                                                                     "/home/sel4/work/work2/kernel/src/object/cnode.c"
# 456 "/home/sel4/work/work2/kernel/src/object/cnode.c"
    ,
                                                                     457
# 456 "/home/sel4/work/work2/kernel/src/object/cnode.c"
    , __FUNCTION__)
                                                                      ;

    /* Prevent parent untyped cap from being used again if creating a child
     * untyped from it. */
    setUntypedCapAsFull(srcCap, newCap, srcSlot);

    destSlot->cap = newCap;
    destSlot->cteMDBNode = newMDB;
    mdb_node_ptr_set_mdbNext(&srcSlot->cteMDBNode, ((word_t)(destSlot)));
    if (mdb_node_get_mdbNext(newMDB)) {
        mdb_node_ptr_set_mdbPrev(
            &((cte_t *)(mdb_node_get_mdbNext(newMDB)))->cteMDBNode,
            ((word_t)(destSlot)));
    }
}

void
cteMove(cap_t newCap, cte_t *srcSlot, cte_t *destSlot)
{
    mdb_node_t mdb;
    word_t prev_ptr, next_ptr;

    /* Haskell error: "cteMove to non-empty destination" */
    if(!(cap_get_capType(destSlot->cap) == cap_null_cap)) _assert_fail("cap_get_capType(destSlot->cap) == cap_null_cap", "/home/sel4/work/work2/kernel/src/object/cnode.c", 480, __FUNCTION__);
    /* Haskell error: "cteMove: mdb entry must be empty" */
    if(!((cte_t*)mdb_node_get_mdbNext(destSlot->cteMDBNode) == ((void *)0) && (cte_t*)mdb_node_get_mdbPrev(destSlot->cteMDBNode) == ((void *)0))) _assert_fail("(cte_t*)mdb_node_get_mdbNext(destSlot->cteMDBNode) == NULL && (cte_t*)mdb_node_get_mdbPrev(destSlot->cteMDBNode) == NULL",
                                                                     "/home/sel4/work/work2/kernel/src/object/cnode.c"
# 482 "/home/sel4/work/work2/kernel/src/object/cnode.c"
    ,
                                                                     483
# 482 "/home/sel4/work/work2/kernel/src/object/cnode.c"
    , __FUNCTION__)
                                                                      ;

    mdb = srcSlot->cteMDBNode;
    destSlot->cap = newCap;
    srcSlot->cap = cap_null_cap_new();
    destSlot->cteMDBNode = mdb;
    srcSlot->cteMDBNode = mdb_node_new(0, false, false, 0);

    prev_ptr = mdb_node_get_mdbPrev(mdb);
    if (prev_ptr)
        mdb_node_ptr_set_mdbNext(
            &((cte_t *)(prev_ptr))->cteMDBNode,
            ((word_t)(destSlot)));

    next_ptr = mdb_node_get_mdbNext(mdb);
    if (next_ptr)
        mdb_node_ptr_set_mdbPrev(
            &((cte_t *)(next_ptr))->cteMDBNode,
            ((word_t)(destSlot)));
}

void
capSwapForDelete(cte_t *slot1, cte_t *slot2)
{
    cap_t cap1, cap2;

    if (slot1 == slot2) {
        return;
    }

    cap1 = slot1->cap;
    cap2 = slot2->cap;

    cteSwap(cap1, slot1, cap2, slot2);
}

void
cteSwap(cap_t cap1, cte_t *slot1, cap_t cap2, cte_t *slot2)
{
    mdb_node_t mdb1, mdb2;
    word_t next_ptr, prev_ptr;

    slot1->cap = cap2;
    slot2->cap = cap1;

    mdb1 = slot1->cteMDBNode;

    prev_ptr = mdb_node_get_mdbPrev(mdb1);
    if (prev_ptr)
        mdb_node_ptr_set_mdbNext(
            &((cte_t *)(prev_ptr))->cteMDBNode,
            ((word_t)(slot2)));

    next_ptr = mdb_node_get_mdbNext(mdb1);
    if (next_ptr)
        mdb_node_ptr_set_mdbPrev(
            &((cte_t *)(next_ptr))->cteMDBNode,
            ((word_t)(slot2)));

    mdb2 = slot2->cteMDBNode;
    slot1->cteMDBNode = mdb2;
    slot2->cteMDBNode = mdb1;

    prev_ptr = mdb_node_get_mdbPrev(mdb2);
    if (prev_ptr)
        mdb_node_ptr_set_mdbNext(
            &((cte_t *)(prev_ptr))->cteMDBNode,
            ((word_t)(slot1)));

    next_ptr = mdb_node_get_mdbNext(mdb2);
    if (next_ptr)
        mdb_node_ptr_set_mdbPrev(
            &((cte_t *)(next_ptr))->cteMDBNode,
            ((word_t)(slot1)));
}

exception_t
cteRevoke(cte_t *slot)
{
    cte_t *nextPtr;
    exception_t status;

    /* there is no need to check for a NullCap as NullCaps are
       always accompanied by null mdb pointers */
    for (nextPtr = ((cte_t *)(mdb_node_get_mdbNext(slot->cteMDBNode)));
            nextPtr && isMDBParentOf(slot, nextPtr);
            nextPtr = ((cte_t *)(mdb_node_get_mdbNext(slot->cteMDBNode)))) {
        status = cteDelete(nextPtr, true);
        if (status != EXCEPTION_NONE) {
            return status;
        }

        status = preemptionPoint();
        if (status != EXCEPTION_NONE) {
            return status;
        }
    }

    return EXCEPTION_NONE;
}

exception_t
cteDelete(cte_t *slot, bool_t exposed)
{
    finaliseSlot_ret_t fs_ret;

    fs_ret = finaliseSlot(slot, exposed);
    if (fs_ret.status != EXCEPTION_NONE) {
        return fs_ret.status;
    }

    if (exposed || fs_ret.success) {
        emptySlot(slot, fs_ret.irq);
    }
    return EXCEPTION_NONE;
}

static void
emptySlot(cte_t *slot, irq_t irq)
{
    if (cap_get_capType(slot->cap) != cap_null_cap) {
        mdb_node_t mdbNode;
        cte_t *prev, *next;

        mdbNode = slot->cteMDBNode;
        prev = ((cte_t *)(mdb_node_get_mdbPrev(mdbNode)));
        next = ((cte_t *)(mdb_node_get_mdbNext(mdbNode)));

        if (prev) {
            mdb_node_ptr_set_mdbNext(&prev->cteMDBNode, ((word_t)(next)));
        }
        if (next) {
            mdb_node_ptr_set_mdbPrev(&next->cteMDBNode, ((word_t)(prev)));
        }
        if (next)
            mdb_node_ptr_set_mdbFirstBadged(&next->cteMDBNode,
                                            mdb_node_get_mdbFirstBadged(next->cteMDBNode) ||
                                            mdb_node_get_mdbFirstBadged(mdbNode));
        slot->cap = cap_null_cap_new();
        slot->cteMDBNode = mdb_node_new(0, false, false, 0);

        if (irq != irqInvalid) {
            deletedIRQHandler(irq);
        }
    }
}

static inline bool_t __attribute__((__const__))
capRemovable(cap_t cap, cte_t* slot)
{
    switch (cap_get_capType(cap)) {
    case cap_null_cap:
        return true;
    case cap_zombie_cap: {
        word_t n = cap_zombie_cap_get_capZombieNumber(cap);
        cte_t* z_slot = (cte_t*)cap_zombie_cap_get_capZombiePtr(cap);
        return (n == 0 || (n == 1 && slot == z_slot));
    }
    default:
        _fail("finaliseCap should only return Zombie or NullCap", "/home/sel4/work/work2/kernel/src/object/cnode.c", 642, __func__);
    }
}

static inline bool_t __attribute__((__const__))
capCyclicZombie(cap_t cap, cte_t *slot)
{
    return cap_get_capType(cap) == cap_zombie_cap &&
           ((cte_t *)(cap_zombie_cap_get_capZombiePtr(cap))) == slot;
}

static finaliseSlot_ret_t
finaliseSlot(cte_t *slot, bool_t immediate)
{
    bool_t final;
    finaliseCap_ret_t fc_ret;
    exception_t status;
    finaliseSlot_ret_t ret;

    while (cap_get_capType(slot->cap) != cap_null_cap) {
        final = isFinalCapability(slot);
        fc_ret = finaliseCap(slot->cap, final, false);

        if (capRemovable(fc_ret.remainder, slot)) {
            ret.status = EXCEPTION_NONE;
            ret.success = true;
            ret.irq = fc_ret.irq;
            return ret;
        }

        slot->cap = fc_ret.remainder;

        if (!immediate && capCyclicZombie(fc_ret.remainder, slot)) {
            ret.status = EXCEPTION_NONE;
            ret.success = false;
            ret.irq = fc_ret.irq;
            return ret;
        }

        status = reduceZombie(slot, immediate);
        if (status != EXCEPTION_NONE) {
            ret.status = status;
            ret.success = false;
            ret.irq = irqInvalid;
            return ret;
        }

        status = preemptionPoint();
        if (status != EXCEPTION_NONE) {
            ret.status = status;
            ret.success = false;
            ret.irq = irqInvalid;
            return ret;
        }
    }
    ret.status = EXCEPTION_NONE;
    ret.success = true;
    ret.irq = irqInvalid;
    return ret;
}

static exception_t
reduceZombie(cte_t* slot, bool_t immediate)
{
    cte_t* ptr;
    word_t n, type;
    exception_t status;

    if(!(cap_get_capType(slot->cap) == cap_zombie_cap)) _assert_fail("cap_get_capType(slot->cap) == cap_zombie_cap", "/home/sel4/work/work2/kernel/src/object/cnode.c", 710, __FUNCTION__);
    ptr = (cte_t*)cap_zombie_cap_get_capZombiePtr(slot->cap);
    n = cap_zombie_cap_get_capZombieNumber(slot->cap);
    type = cap_zombie_cap_get_capZombieType(slot->cap);

    /* Haskell error: "reduceZombie: expected unremovable zombie" */
    if(!(n > 0)) _assert_fail("n > 0", "/home/sel4/work/work2/kernel/src/object/cnode.c", 716, __FUNCTION__);

    if (immediate) {
        cte_t* endSlot = &ptr[n - 1];

        status = cteDelete(endSlot, false);
        if (status != EXCEPTION_NONE) {
            return status;
        }

        switch (cap_get_capType(slot->cap)) {
        case cap_null_cap:
            break;

        case cap_zombie_cap: {
            cte_t* ptr2 =
                (cte_t*)cap_zombie_cap_get_capZombiePtr(slot->cap);

            if (ptr == ptr2 &&
                    cap_zombie_cap_get_capZombieNumber(slot->cap) == n &&
                    cap_zombie_cap_get_capZombieType(slot->cap) == type) {
                if(!(cap_get_capType(endSlot->cap) == cap_null_cap)) _assert_fail("cap_get_capType(endSlot->cap) == cap_null_cap", "/home/sel4/work/work2/kernel/src/object/cnode.c", 737, __FUNCTION__);
                slot->cap =
                    cap_zombie_cap_set_capZombieNumber(slot->cap, n - 1);
            } else {
                /* Haskell error:
                 * "Expected new Zombie to be self-referential."
                 */
                if(!(ptr2 == slot && ptr != slot)) _assert_fail("ptr2 == slot && ptr != slot", "/home/sel4/work/work2/kernel/src/object/cnode.c", 744, __FUNCTION__);
            }
            break;
        }

        default:
            _fail("Expected recursion to result in Zombie.", "/home/sel4/work/work2/kernel/src/object/cnode.c", 750, __func__);
        }
    } else {
        /* Haskell error: "Cyclic zombie passed to unexposed reduceZombie" */
        if(!(ptr != slot)) _assert_fail("ptr != slot", "/home/sel4/work/work2/kernel/src/object/cnode.c", 754, __FUNCTION__);

        if (cap_get_capType(ptr->cap) == cap_zombie_cap) {
            /* Haskell error: "Moving self-referential Zombie aside." */
            if(!(ptr != ((cte_t *)(cap_zombie_cap_get_capZombiePtr(ptr->cap))))) _assert_fail("ptr != CTE_PTR(cap_zombie_cap_get_capZombiePtr(ptr->cap))", "/home/sel4/work/work2/kernel/src/object/cnode.c", 758, __FUNCTION__);
        }

        capSwapForDelete(ptr, slot);
    }
    return EXCEPTION_NONE;
}

void
cteDeleteOne(cte_t* slot)
{
    word_t cap_type = cap_get_capType(slot->cap);
    if (cap_type != cap_null_cap) {
        bool_t final;
        finaliseCap_ret_t fc_ret __attribute__((unused));

        /** GHOSTUPD: "(gs_get_assn cteDeleteOne_'proc \<acute>ghost'state = (-1)
            \<or> gs_get_assn cteDeleteOne_'proc \<acute>ghost'state = \<acute>cap_type, id)" */

        final = isFinalCapability(slot);
        fc_ret = finaliseCap(slot->cap, final, true);
        /* Haskell error: "cteDeleteOne: cap should be removable" */
        if(!(capRemovable(fc_ret.remainder, slot) && fc_ret.irq == irqInvalid)) _assert_fail("capRemovable(fc_ret.remainder, slot) && fc_ret.irq == irqInvalid",
                                       "/home/sel4/work/work2/kernel/src/object/cnode.c"
# 780 "/home/sel4/work/work2/kernel/src/object/cnode.c"
        ,
                                       781
# 780 "/home/sel4/work/work2/kernel/src/object/cnode.c"
        , __FUNCTION__)
                                        ;
        emptySlot(slot, irqInvalid);
    }
}

void
insertNewCap(cte_t *parent, cte_t *slot, cap_t cap)
{
    cte_t *next;

    next = ((cte_t *)(mdb_node_get_mdbNext(parent->cteMDBNode)));
    slot->cap = cap;
    slot->cteMDBNode = mdb_node_new(((word_t)(next)), true, true, ((word_t)(parent)));
    if (next) {
        mdb_node_ptr_set_mdbPrev(&next->cteMDBNode, ((word_t)(slot)));
    }
    mdb_node_ptr_set_mdbNext(&parent->cteMDBNode, ((word_t)(slot)));
}

void
setupReplyMaster(tcb_t *thread)
{
    cte_t *slot;

    slot = (((cte_t *)((word_t)(thread)&~((1ul << (10))-1ul)))+(tcbReply));
    if (cap_get_capType(slot->cap) == cap_null_cap) {
        /* Haskell asserts that no reply caps exist for this thread here. This
         * cannot be translated. */
        slot->cap = cap_reply_cap_new(true, ((word_t)(thread)));
        slot->cteMDBNode = mdb_node_new(0, false, false, 0);
        mdb_node_ptr_set_mdbRevocable(&slot->cteMDBNode, true);
        mdb_node_ptr_set_mdbFirstBadged(&slot->cteMDBNode, true);
    }
}

bool_t __attribute__((__pure__))
isMDBParentOf(cte_t *cte_a, cte_t *cte_b)
{
    if (!mdb_node_get_mdbRevocable(cte_a->cteMDBNode)) {
        return false;
    }
    if (!sameRegionAs(cte_a->cap, cte_b->cap)) {
        return false;
    }
    switch (cap_get_capType(cte_a->cap)) {
    case cap_endpoint_cap: {
        word_t badge;

        badge = cap_endpoint_cap_get_capEPBadge(cte_a->cap);
        if (badge == 0) {
            return true;
        }
        return (badge == cap_endpoint_cap_get_capEPBadge(cte_b->cap)) &&
               !mdb_node_get_mdbFirstBadged(cte_b->cteMDBNode);
        break;
    }

    case cap_notification_cap: {
        word_t badge;

        badge = cap_notification_cap_get_capNtfnBadge(cte_a->cap);
        if (badge == 0) {
            return true;
        }
        return
            (badge == cap_notification_cap_get_capNtfnBadge(cte_b->cap)) &&
            !mdb_node_get_mdbFirstBadged(cte_b->cteMDBNode);
        break;
    }

    default:
        return true;
        break;
    }
}

exception_t
ensureNoChildren(cte_t *slot)
{
    if (mdb_node_get_mdbNext(slot->cteMDBNode) != 0) {
        cte_t *next;

        next = ((cte_t *)(mdb_node_get_mdbNext(slot->cteMDBNode)));
        if (isMDBParentOf(slot, next)) {
            current_syscall_error.type = seL4_RevokeFirst;
            return EXCEPTION_SYSCALL_ERROR;
        }
    }

    return EXCEPTION_NONE;
}

exception_t
ensureEmptySlot(cte_t *slot)
{
    if (cap_get_capType(slot->cap) != cap_null_cap) {
        current_syscall_error.type = seL4_DeleteFirst;
        return EXCEPTION_SYSCALL_ERROR;
    }

    return EXCEPTION_NONE;
}

bool_t __attribute__((__pure__))
isFinalCapability(cte_t *cte)
{
    mdb_node_t mdb;
    bool_t prevIsSameObject;

    mdb = cte->cteMDBNode;

    if (mdb_node_get_mdbPrev(mdb) == 0) {
        prevIsSameObject = false;
    } else {
        cte_t *prev;

        prev = ((cte_t *)(mdb_node_get_mdbPrev(mdb)));
        prevIsSameObject = sameObjectAs(prev->cap, cte->cap);
    }

    if (prevIsSameObject) {
        return false;
    } else {
        if (mdb_node_get_mdbNext(mdb) == 0) {
            return true;
        } else {
            cte_t *next;

            next = ((cte_t *)(mdb_node_get_mdbNext(mdb)));
            return !sameObjectAs(cte->cap, next->cap);
        }
    }
}

bool_t __attribute__((__pure__))
slotCapLongRunningDelete(cte_t *slot)
{
    if (cap_get_capType(slot->cap) == cap_null_cap) {
        return false;
    } else if (! isFinalCapability(slot)) {
        return false;
    }
    switch (cap_get_capType(slot->cap)) {
    case cap_thread_cap:
    case cap_zombie_cap:
    case cap_cnode_cap:
        return true;
    default:
        return false;
    }
}

/* This implementation is specialised to the (current) limit
 * of one cap receive slot. */
cte_t *
getReceiveSlots(tcb_t *thread, word_t *buffer)
{
    cap_transfer_t ct;
    cptr_t cptr;
    lookupCap_ret_t luc_ret;
    lookupSlot_ret_t lus_ret;
    cte_t *slot;
    cap_t cnode;

    if (!buffer) {
        return ((void *)0);
    }

    ct = loadCapTransfer(buffer);
    cptr = ct.ctReceiveRoot;

    luc_ret = lookupCap(thread, cptr);
    if (luc_ret.status != EXCEPTION_NONE) {
        return ((void *)0);
    }
    cnode = luc_ret.cap;

    lus_ret = lookupTargetSlot(cnode, ct.ctReceiveIndex, ct.ctReceiveDepth);
    if (lus_ret.status != EXCEPTION_NONE) {
        return ((void *)0);
    }
    slot = lus_ret.slot;

    if (cap_get_capType(slot->cap) != cap_null_cap) {
        return ((void *)0);
    }

    return slot;
}

cap_transfer_t __attribute__((__pure__))
loadCapTransfer(word_t *buffer)
{
    const int offset = seL4_MsgMaxLength + ((1ul<<(seL4_MsgExtraCapBits))-1) + 2;
    return capTransferFromWords(buffer + offset);
}
# 1 "/home/sel4/work/work2/kernel/src/object/endpoint.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/object/endpoint.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/object/endpoint.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/object/endpoint.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/registerset.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/object/endpoint.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/object/endpoint.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/notification.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/object/endpoint.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/object/endpoint.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/endpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/object/endpoint.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/object/endpoint.c" 2

static inline tcb_queue_t __attribute__((__pure__))
ep_ptr_get_queue(endpoint_t *epptr)
{
    tcb_queue_t queue;

    queue.head = (tcb_t*)endpoint_ptr_get_epQueue_head(epptr);
    queue.end = (tcb_t*)endpoint_ptr_get_epQueue_tail(epptr);

    return queue;
}

static inline void
ep_ptr_set_queue(endpoint_t *epptr, tcb_queue_t queue)
{
    endpoint_ptr_set_epQueue_head(epptr, (word_t)queue.head);
    endpoint_ptr_set_epQueue_tail(epptr, (word_t)queue.end);
}

void
sendIPC(bool_t blocking, bool_t do_call, word_t badge,
        bool_t canGrant, tcb_t *thread, endpoint_t *epptr)
{
    switch (endpoint_ptr_get_state(epptr)) {
    case EPState_Idle:
    case EPState_Send:
        if (blocking) {
            tcb_queue_t queue;

            /* Set thread state to BlockedOnSend */
            thread_state_ptr_set_tsType(&thread->tcbState,
                                        ThreadState_BlockedOnSend);
            thread_state_ptr_set_blockingObject(
                &thread->tcbState, ((word_t)(epptr)));
            thread_state_ptr_set_blockingIPCBadge(
                &thread->tcbState, badge);
            thread_state_ptr_set_blockingIPCCanGrant(
                &thread->tcbState, canGrant);
            thread_state_ptr_set_blockingIPCIsCall(
                &thread->tcbState, do_call);

            scheduleTCB(thread);

            /* Place calling thread in endpoint queue */
            queue = ep_ptr_get_queue(epptr);
            queue = tcbEPAppend(thread, queue);
            endpoint_ptr_set_state(epptr, EPState_Send);
            ep_ptr_set_queue(epptr, queue);
        }
        break;

    case EPState_Recv: {
        tcb_queue_t queue;
        tcb_t *dest;

        /* Get the head of the endpoint queue. */
        queue = ep_ptr_get_queue(epptr);
        dest = queue.head;

        /* Haskell error "Receive endpoint queue must not be empty" */
        if(!(dest)) _assert_fail("dest", "/home/sel4/work/work2/kernel/src/object/endpoint.c", 80, __FUNCTION__);

        /* Dequeue the first TCB */
        queue = tcbEPDequeue(dest, queue);
        ep_ptr_set_queue(epptr, queue);

        if (!queue.head) {
            endpoint_ptr_set_state(epptr, EPState_Idle);
        }

        /* Do the transfer */
        doIPCTransfer(thread, epptr, badge, canGrant, dest);

        setThreadState(dest, ThreadState_Running);
        attemptSwitchTo(dest);

        if (do_call ||
                seL4_Fault_ptr_get_seL4_FaultType(&thread->tcbFault) != seL4_Fault_NullFault) {
            if (canGrant) {
                setupCallerCap(thread, dest);
            } else {
                setThreadState(thread, ThreadState_Inactive);
            }
        }

        break;
    }
    }
}

void
receiveIPC(tcb_t *thread, cap_t cap, bool_t isBlocking)
{
    endpoint_t *epptr;
    notification_t *ntfnPtr;

    /* Haskell error "receiveIPC: invalid cap" */
    if(!(cap_get_capType(cap) == cap_endpoint_cap)) _assert_fail("cap_get_capType(cap) == cap_endpoint_cap", "/home/sel4/work/work2/kernel/src/object/endpoint.c", 117, __FUNCTION__);

    epptr = ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(cap)));

    /* Check for anything waiting in the notification */
    ntfnPtr = thread->tcbBoundNotification;
    if (ntfnPtr && notification_ptr_get_state(ntfnPtr) == NtfnState_Active) {
        completeSignal(ntfnPtr, thread);
    } else {
        switch (endpoint_ptr_get_state(epptr)) {
        case EPState_Idle:
        case EPState_Recv: {
            tcb_queue_t queue;

            if (isBlocking) {
                /* Set thread state to BlockedOnReceive */
                thread_state_ptr_set_tsType(&thread->tcbState,
                                            ThreadState_BlockedOnReceive);
                thread_state_ptr_set_blockingObject(
                    &thread->tcbState, ((word_t)(epptr)));

                scheduleTCB(thread);

                /* Place calling thread in endpoint queue */
                queue = ep_ptr_get_queue(epptr);
                queue = tcbEPAppend(thread, queue);
                endpoint_ptr_set_state(epptr, EPState_Recv);
                ep_ptr_set_queue(epptr, queue);
            } else {
                doNBRecvFailedTransfer(thread);
            }
            break;
        }

        case EPState_Send: {
            tcb_queue_t queue;
            tcb_t *sender;
            word_t badge;
            bool_t canGrant;
            bool_t do_call;

            /* Get the head of the endpoint queue. */
            queue = ep_ptr_get_queue(epptr);
            sender = queue.head;

            /* Haskell error "Send endpoint queue must not be empty" */
            if(!(sender)) _assert_fail("sender", "/home/sel4/work/work2/kernel/src/object/endpoint.c", 163, __FUNCTION__);

            /* Dequeue the first TCB */
            queue = tcbEPDequeue(sender, queue);
            ep_ptr_set_queue(epptr, queue);

            if (!queue.head) {
                endpoint_ptr_set_state(epptr, EPState_Idle);
            }

            /* Get sender IPC details */
            badge = thread_state_ptr_get_blockingIPCBadge(&sender->tcbState);
            canGrant =
                thread_state_ptr_get_blockingIPCCanGrant(&sender->tcbState);

            /* Do the transfer */
            doIPCTransfer(sender, epptr, badge,
                          canGrant, thread);

            do_call = thread_state_ptr_get_blockingIPCIsCall(&sender->tcbState);

            if (do_call ||
                    seL4_Fault_get_seL4_FaultType(sender->tcbFault) != seL4_Fault_NullFault) {
                if (canGrant) {
                    setupCallerCap(sender, thread);
                } else {
                    setThreadState(sender, ThreadState_Inactive);
                }
            } else {
                setThreadState(sender, ThreadState_Running);
                switchIfRequiredTo(sender);
            }

            break;
        }
        }
    }
}

void
replyFromKernel_error(tcb_t *thread)
{
    word_t len;
    word_t *ipcBuffer;

    ipcBuffer = lookupIPCBuffer(true, thread);
    setRegister(thread, badgeRegister, 0);
    len = setMRs_syscall_error(thread, ipcBuffer);
    setRegister(thread, msgInfoRegister, wordFromMessageInfo(
                    seL4_MessageInfo_new(current_syscall_error.type, 0, 0, len)));
}

void
replyFromKernel_success_empty(tcb_t *thread)
{
    setRegister(thread, badgeRegister, 0);
    setRegister(thread, msgInfoRegister, wordFromMessageInfo(
                    seL4_MessageInfo_new(0, 0, 0, 0)));
}

void
cancelIPC(tcb_t *tptr)
{
    thread_state_t *state = &tptr->tcbState;

    switch (thread_state_ptr_get_tsType(state)) {
    case ThreadState_BlockedOnSend:
    case ThreadState_BlockedOnReceive: {
        /* blockedIPCCancel state */
        endpoint_t *epptr;
        tcb_queue_t queue;

        epptr = ((endpoint_t *)(thread_state_ptr_get_blockingObject(state)));

        /* Haskell error "blockedIPCCancel: endpoint must not be idle" */
        if(!(endpoint_ptr_get_state(epptr) != EPState_Idle)) _assert_fail("endpoint_ptr_get_state(epptr) != EPState_Idle", "/home/sel4/work/work2/kernel/src/object/endpoint.c", 238, __FUNCTION__);

        /* Dequeue TCB */
        queue = ep_ptr_get_queue(epptr);
        queue = tcbEPDequeue(tptr, queue);
        ep_ptr_set_queue(epptr, queue);

        if (!queue.head) {
            endpoint_ptr_set_state(epptr, EPState_Idle);
        }

        setThreadState(tptr, ThreadState_Inactive);
        break;
    }

    case ThreadState_BlockedOnNotification:
        cancelSignal(tptr,
                     ((notification_t *)(thread_state_ptr_get_blockingObject(state))));
        break;

    case ThreadState_BlockedOnReply: {
        cte_t *slot, *callerCap;

        tptr->tcbFault = seL4_Fault_NullFault_new();

        /* Get the reply cap slot */
        slot = (((cte_t *)((word_t)(tptr)&~((1ul << (10))-1ul)))+(tcbReply));

        callerCap = ((cte_t *)(mdb_node_get_mdbNext(slot->cteMDBNode)));
        if (callerCap) {
            /** GHOSTUPD: "(True,
                gs_set_assn cteDeleteOne_'proc (ucast cap_reply_cap))" */
            cteDeleteOne(callerCap);
        }

        break;
    }
    }
}

void
cancelAllIPC(endpoint_t *epptr)
{
    switch (endpoint_ptr_get_state(epptr)) {
    case EPState_Idle:
        break;

    default: {
        tcb_t *thread = ((tcb_t *)(endpoint_ptr_get_epQueue_head(epptr)));

        /* Make endpoint idle */
        endpoint_ptr_set_state(epptr, EPState_Idle);
        endpoint_ptr_set_epQueue_head(epptr, 0);
        endpoint_ptr_set_epQueue_tail(epptr, 0);

        /* Set all blocked threads to restart */
        for (; thread; thread = thread->tcbEPNext) {
            setThreadState (thread, ThreadState_Restart);
            tcbSchedEnqueue(thread);
        }

        rescheduleRequired();
        break;
    }
    }
}

void
cancelBadgedSends(endpoint_t *epptr, word_t badge)
{
    switch (endpoint_ptr_get_state(epptr)) {
    case EPState_Idle:
    case EPState_Recv:
        break;

    case EPState_Send: {
        tcb_t *thread, *next;
        tcb_queue_t queue = ep_ptr_get_queue(epptr);

        /* this is a de-optimisation for verification
         * reasons. it allows the contents of the endpoint
         * queue to be ignored during the for loop. */
        endpoint_ptr_set_state(epptr, EPState_Idle);
        endpoint_ptr_set_epQueue_head(epptr, 0);
        endpoint_ptr_set_epQueue_tail(epptr, 0);

        for (thread = queue.head; thread; thread = next) {
            word_t b = thread_state_ptr_get_blockingIPCBadge(
                           &thread->tcbState);
            next = thread->tcbEPNext;
            if (b == badge) {
                setThreadState(thread, ThreadState_Restart);
                tcbSchedEnqueue(thread);
                queue = tcbEPDequeue(thread, queue);
            }
        }
        ep_ptr_set_queue(epptr, queue);

        if (queue.head) {
            endpoint_ptr_set_state(epptr, EPState_Send);
        }

        rescheduleRequired();

        break;
    }

    default:
        _fail("invalid EP state", "/home/sel4/work/work2/kernel/src/object/endpoint.c", 346, __func__);
    }
}
# 1 "/home/sel4/work/work2/kernel/src/object/interrupt.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "./api/invocation.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 15 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/notification.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/timer.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2
# 1 "/home/sel4/work/work2/kernel/include/smp/ipi.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 26 "/home/sel4/work/work2/kernel/src/object/interrupt.c" 2

exception_t
decodeIRQControlInvocation(word_t invLabel, word_t length,
                           cte_t *srcSlot, extra_caps_t excaps,
                           word_t *buffer)
{
    if (invLabel == IRQIssueIRQHandler) {
        word_t index, depth, irq_w;
        irq_t irq;
        cte_t *destSlot;
        cap_t cnodeCap;
        lookupSlot_ret_t lu_ret;
        exception_t status;

        if (length < 3 || excaps.excaprefs[0] == ((void *)0)) {
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }
        irq_w = getSyscallArg(0, buffer);
        irq = (irq_t) irq_w;
        index = getSyscallArg(1, buffer);
        depth = getSyscallArg(2, buffer);

        cnodeCap = excaps.excaprefs[0]->cap;

        status = Arch_checkIRQ(irq);
        if (status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 53, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Rejecting request for IRQ %u. IRQ is greater than maxIRQ.", (int)irq); kprintf(">>" "\033[0m" "\n"); } while (0);
            return status;
        }

        if (isIRQActive(irq)) {
            current_syscall_error.type = seL4_RevokeFirst;
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 59, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Rejecting request for IRQ %u. Already active.", (int)irq); kprintf(">>" "\033[0m" "\n"); } while (0);
            return EXCEPTION_SYSCALL_ERROR;
        }

        lu_ret = lookupTargetSlot(cnodeCap, index, depth);
        if (lu_ret.status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 66, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Target slot for new IRQ Handler cap invalid: cap %lu, IRQ %u.", getExtraCPtr(buffer, 0), (int)irq); kprintf(">>" "\033[0m" "\n"); } while (0)
                                                        ;
            return lu_ret.status;
        }
        destSlot = lu_ret.slot;

        status = ensureEmptySlot(destSlot);
        if (status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 74, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Target slot for new IRQ Handler cap not empty: cap %lu, IRQ %u.", getExtraCPtr(buffer, 0), (int)irq); kprintf(">>" "\033[0m" "\n"); } while (0)
                                                        ;
            return status;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeIRQControl(irq, destSlot, srcSlot);
    } else {
        return Arch_decodeIRQControlInvocation(invLabel, length, srcSlot, excaps, buffer);
    }
}

exception_t
invokeIRQControl(irq_t irq, cte_t *handlerSlot, cte_t *controlSlot)
{
    setIRQState(IRQSignal, irq);
    cteInsert(cap_irq_handler_cap_new(irq), controlSlot, handlerSlot);

    return EXCEPTION_NONE;
}

exception_t
decodeIRQHandlerInvocation(word_t invLabel, irq_t irq,
                           extra_caps_t excaps)
{
    switch (invLabel) {
    case IRQAckIRQ:
        setThreadState(ksCurThread, ThreadState_Restart);
        invokeIRQHandler_AckIRQ(irq);
        return EXCEPTION_NONE;

    case IRQSetIRQHandler: {
        cap_t ntfnCap;
        cte_t *slot;

        if (excaps.excaprefs[0] == ((void *)0)) {
            current_syscall_error.type = seL4_TruncatedMessage;
            return EXCEPTION_SYSCALL_ERROR;
        }
        ntfnCap = excaps.excaprefs[0]->cap;
        slot = excaps.excaprefs[0];

        if (cap_get_capType(ntfnCap) != cap_notification_cap ||
                !cap_notification_cap_get_capNtfnCanSend(ntfnCap)) {
            if (cap_get_capType(ntfnCap) != cap_notification_cap) {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 118, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("IRQSetHandler: provided cap is not an notification capability."); kprintf(">>" "\033[0m" "\n"); } while (0);
            } else {
                do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 120, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("IRQSetHandler: caller does not have send rights on the endpoint."); kprintf(">>" "\033[0m" "\n"); } while (0);
            }
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        invokeIRQHandler_SetIRQHandler(irq, ntfnCap, slot);
        return EXCEPTION_NONE;
    }

    case IRQClearIRQHandler:
        setThreadState(ksCurThread, ThreadState_Restart);
        invokeIRQHandler_ClearIRQHandler(irq);
        return EXCEPTION_NONE;

    default:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 138, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("IRQHandler: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
}

void
invokeIRQHandler_AckIRQ(irq_t irq)
{
    maskInterrupt(false, irq);
}

void
invokeIRQHandler_SetIRQHandler(irq_t irq, cap_t cap, cte_t *slot)
{
    cte_t *irqSlot;

    irqSlot = intStateIRQNode + irq;
    /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (-1))" */
    cteDeleteOne(irqSlot);
    cteInsert(cap, slot, irqSlot);
}

void
invokeIRQHandler_ClearIRQHandler(irq_t irq)
{
    cte_t *irqSlot;

    irqSlot = intStateIRQNode + irq;
    /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (-1))" */
    cteDeleteOne(irqSlot);
}

void
deletingIRQHandler(irq_t irq)
{
    cte_t *slot;

    slot = intStateIRQNode + irq;
    /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (ucast cap_notification_cap))" */
    cteDeleteOne(slot);
}

void
deletedIRQHandler(irq_t irq)
{
    setIRQState(IRQInactive, irq);
}

void
handleInterrupt(irq_t irq)
{
    if (__builtin_expect(!!(irq > maxIRQ), 0)) {
        /* mask, ack and pretend it didn't happen. We assume that because
         * the interrupt controller for the platform returned this IRQ that
         * it is safe to use in mask and ack operations, even though it is
         * above the claimed maxIRQ. i.e. we're assuming maxIRQ is wrong */
        kprintf("Received IRQ %d, which is above the platforms maxIRQ of %d\n", (int)irq, (int)maxIRQ);
        maskInterrupt(true, irq);
        ackInterrupt(irq);
        return;
    }
    switch (intStateIRQTable[irq]) {
    case IRQSignal: {
        cap_t cap;

        cap = intStateIRQNode[irq].cap;

        if (cap_get_capType(cap) == cap_notification_cap &&
                cap_notification_cap_get_capNtfnCanSend(cap)) {
            sendSignal(((notification_t *)(cap_notification_cap_get_capNtfnPtr(cap))),
                       cap_notification_cap_get_capNtfnBadge(cap));
        } else {



        }
        maskInterrupt(true, irq);
        break;
    }

    case IRQTimer:
        timerTick();
        resetTimer();
        break;







    case IRQReserved:



        handleReservedIRQ(irq);
        break;

    case IRQInactive:
        /*
         * This case shouldn't happen anyway unless the hardware or
         * platform code is broken. Hopefully masking it again should make
         * the interrupt go away.
         */
        maskInterrupt(true, irq);



        break;

    default:
        /* No corresponding haskell error */
        _fail("Invalid IRQ state", "/home/sel4/work/work2/kernel/src/object/interrupt.c", 251, __func__);
    }

    ackInterrupt(irq);
}

bool_t
isIRQActive(irq_t irq)
{
    return intStateIRQTable[irq] != IRQInactive;
}

void
setIRQState(irq_state_t irqState, irq_t irq)
{
    intStateIRQTable[irq] = irqState;
    maskInterrupt(irqState == IRQInactive, irq);
}
# 1 "/home/sel4/work/work2/kernel/src/object/notification.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/object/notification.c" 2

# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/object/notification.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/object/notification.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/object/notification.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/object/notification.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/endpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/object/notification.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/object/notification.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/object/notification.c" 2

# 1 "/home/sel4/work/work2/kernel/include/object/notification.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/object/notification.c" 2

static inline tcb_queue_t __attribute__((__pure__))
ntfn_ptr_get_queue(notification_t *ntfnPtr)
{
    tcb_queue_t ntfn_queue;

    ntfn_queue.head = (tcb_t*)notification_ptr_get_ntfnQueue_head(ntfnPtr);
    ntfn_queue.end = (tcb_t*)notification_ptr_get_ntfnQueue_tail(ntfnPtr);

    return ntfn_queue;
}

static inline void
ntfn_ptr_set_queue(notification_t *ntfnPtr, tcb_queue_t ntfn_queue)
{
    notification_ptr_set_ntfnQueue_head(ntfnPtr, (word_t)ntfn_queue.head);
    notification_ptr_set_ntfnQueue_tail(ntfnPtr, (word_t)ntfn_queue.end);
}

static inline void
ntfn_set_active(notification_t *ntfnPtr, word_t badge)
{
    notification_ptr_set_state(ntfnPtr, NtfnState_Active);
    notification_ptr_set_ntfnMsgIdentifier(ntfnPtr, badge);
}


void
sendSignal(notification_t *ntfnPtr, word_t badge)
{
    switch (notification_ptr_get_state(ntfnPtr)) {
    case NtfnState_Idle: {
        tcb_t *tcb = (tcb_t*)notification_ptr_get_ntfnBoundTCB(ntfnPtr);
        /* Check if we are bound and that thread is waiting for a message */
        if (tcb) {
            if (thread_state_ptr_get_tsType(&tcb->tcbState) == ThreadState_BlockedOnReceive) {
                /* Send and start thread running */
                cancelIPC(tcb);
                setThreadState(tcb, ThreadState_Running);
                setRegister(tcb, badgeRegister, badge);
                switchIfRequiredTo(tcb);
# 78 "/home/sel4/work/work2/kernel/src/object/notification.c"
            } else {
                ntfn_set_active(ntfnPtr, badge);
            }
        } else {
            ntfn_set_active(ntfnPtr, badge);
        }
        break;
    }
    case NtfnState_Waiting: {
        tcb_queue_t ntfn_queue;
        tcb_t *dest;

        ntfn_queue = ntfn_ptr_get_queue(ntfnPtr);
        dest = ntfn_queue.head;

        /* Haskell error "WaitingNtfn Notification must have non-empty queue" */
        if(!(dest)) _assert_fail("dest", "/home/sel4/work/work2/kernel/src/object/notification.c", 94, __FUNCTION__);

        /* Dequeue TCB */
        ntfn_queue = tcbEPDequeue(dest, ntfn_queue);
        ntfn_ptr_set_queue(ntfnPtr, ntfn_queue);

        /* set the thread state to idle if the queue is empty */
        if (!ntfn_queue.head) {
            notification_ptr_set_state(ntfnPtr, NtfnState_Idle);
        }

        setThreadState(dest, ThreadState_Running);
        setRegister(dest, badgeRegister, badge);
        switchIfRequiredTo(dest);
        break;
    }

    case NtfnState_Active: {
        word_t badge2;

        badge2 = notification_ptr_get_ntfnMsgIdentifier(ntfnPtr);
        badge2 |= badge;

        notification_ptr_set_ntfnMsgIdentifier(ntfnPtr, badge2);
        break;
    }
    }
}

void
receiveSignal(tcb_t *thread, cap_t cap, bool_t isBlocking)
{
    notification_t *ntfnPtr;

    ntfnPtr = ((notification_t *)(cap_notification_cap_get_capNtfnPtr(cap)));

    switch (notification_ptr_get_state(ntfnPtr)) {
    case NtfnState_Idle:
    case NtfnState_Waiting: {
        tcb_queue_t ntfn_queue;

        if (isBlocking) {
            /* Block thread on notification object */
            thread_state_ptr_set_tsType(&thread->tcbState,
                                        ThreadState_BlockedOnNotification);
            thread_state_ptr_set_blockingObject(&thread->tcbState,
                                                ((word_t)(ntfnPtr)));
            scheduleTCB(thread);

            /* Enqueue TCB */
            ntfn_queue = ntfn_ptr_get_queue(ntfnPtr);
            ntfn_queue = tcbEPAppend(thread, ntfn_queue);

            notification_ptr_set_state(ntfnPtr, NtfnState_Waiting);
            ntfn_ptr_set_queue(ntfnPtr, ntfn_queue);
        } else {
            doNBRecvFailedTransfer(thread);
        }

        break;
    }

    case NtfnState_Active:
        setRegister(
            thread, badgeRegister,
            notification_ptr_get_ntfnMsgIdentifier(ntfnPtr));
        notification_ptr_set_state(ntfnPtr, NtfnState_Idle);
        break;
    }
}

void
cancelAllSignals(notification_t *ntfnPtr)
{
    if (notification_ptr_get_state(ntfnPtr) == NtfnState_Waiting) {
        tcb_t *thread = ((tcb_t *)(notification_ptr_get_ntfnQueue_head(ntfnPtr)));

        notification_ptr_set_state(ntfnPtr, NtfnState_Idle);
        notification_ptr_set_ntfnQueue_head(ntfnPtr, 0);
        notification_ptr_set_ntfnQueue_tail(ntfnPtr, 0);

        /* Set all waiting threads to Restart */
        for (; thread; thread = thread->tcbEPNext) {
            setThreadState(thread, ThreadState_Restart);
            tcbSchedEnqueue(thread);
        }
        rescheduleRequired();
    }
}

void
cancelSignal(tcb_t *threadPtr, notification_t *ntfnPtr)
{
    tcb_queue_t ntfn_queue;

    /* Haskell error "cancelSignal: notification object must be in a waiting" state */
    if(!(notification_ptr_get_state(ntfnPtr) == NtfnState_Waiting)) _assert_fail("notification_ptr_get_state(ntfnPtr) == NtfnState_Waiting", "/home/sel4/work/work2/kernel/src/object/notification.c", 190, __FUNCTION__);

    /* Dequeue TCB */
    ntfn_queue = ntfn_ptr_get_queue(ntfnPtr);
    ntfn_queue = tcbEPDequeue(threadPtr, ntfn_queue);
    ntfn_ptr_set_queue(ntfnPtr, ntfn_queue);

    /* Make notification object idle */
    if (!ntfn_queue.head) {
        notification_ptr_set_state(ntfnPtr, NtfnState_Idle);
    }

    /* Make thread inactive */
    setThreadState(threadPtr, ThreadState_Inactive);
}

void
completeSignal(notification_t *ntfnPtr, tcb_t *tcb)
{
    word_t badge;

    if (__builtin_expect(!!(tcb && notification_ptr_get_state(ntfnPtr) == NtfnState_Active), 1)) {
        badge = notification_ptr_get_ntfnMsgIdentifier(ntfnPtr);
        setRegister(tcb, badgeRegister, badge);
        notification_ptr_set_state(ntfnPtr, NtfnState_Idle);
    } else {
        _fail("tried to complete signal with inactive notification object", "/home/sel4/work/work2/kernel/src/object/notification.c", 216, __func__);
    }
}

static inline void
doUnbindNotification(notification_t *ntfnPtr, tcb_t *tcbptr)
{
    notification_ptr_set_ntfnBoundTCB(ntfnPtr, (word_t) 0);
    tcbptr->tcbBoundNotification = ((void *)0);
}

void
unbindMaybeNotification(notification_t *ntfnPtr)
{
    tcb_t *boundTCB;
    boundTCB = (tcb_t*)notification_ptr_get_ntfnBoundTCB(ntfnPtr);

    if (boundTCB) {
        doUnbindNotification(ntfnPtr, boundTCB);
    }
}

void
unbindNotification(tcb_t *tcb)
{
    notification_t *ntfnPtr;
    ntfnPtr = tcb->tcbBoundNotification;

    if (ntfnPtr) {
        doUnbindNotification(ntfnPtr, tcb);
    }
}

void
bindNotification(tcb_t *tcb, notification_t *ntfnPtr)
{
    notification_ptr_set_ntfnBoundTCB(ntfnPtr, (word_t)tcb);
    tcb->tcbBoundNotification = ntfnPtr;
}
# 1 "/home/sel4/work/work2/kernel/src/object/objecttype.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/notification.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/endpoint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/interrupt.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/untyped.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 26 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 27 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 28 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 29 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 30 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 31 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2
# 1 "/home/sel4/work/work2/kernel/include/string.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 32 "/home/sel4/work/work2/kernel/src/object/objecttype.c" 2

word_t getObjectSize(word_t t, word_t userObjSize)
{
    if (t >= seL4_NonArchObjectTypeCount) {
        return Arch_getObjectSize(t);
    } else {
        switch (t) {
        case seL4_TCBObject:
            return 10;
        case seL4_EndpointObject:
            return 4;
        case seL4_NotificationObject:
            return 4;
        case seL4_CapTableObject:
            return 4 + userObjSize;
        case seL4_UntypedObject:
            return userObjSize;
        default:
            _fail("Invalid object type", "/home/sel4/work/work2/kernel/src/object/objecttype.c", 50, __func__);
            return 0;
        }
    }
}

deriveCap_ret_t
deriveCap(cte_t *slot, cap_t cap)
{
    deriveCap_ret_t ret;

    if (isArchCap(cap)) {
        return Arch_deriveCap(slot, cap);
    }

    switch (cap_get_capType(cap)) {
    case cap_zombie_cap:
        ret.status = EXCEPTION_NONE;
        ret.cap = cap_null_cap_new();
        break;

    case cap_irq_control_cap:
        ret.status = EXCEPTION_NONE;
        ret.cap = cap_null_cap_new();
        break;

    case cap_untyped_cap:
        ret.status = ensureNoChildren(slot);
        if (ret.status != EXCEPTION_NONE) {
            ret.cap = cap_null_cap_new();
        } else {
            ret.cap = cap;
        }
        break;

    case cap_reply_cap:
        ret.status = EXCEPTION_NONE;
        ret.cap = cap_null_cap_new();
        break;

    default:
        ret.status = EXCEPTION_NONE;
        ret.cap = cap;
    }

    return ret;
}

finaliseCap_ret_t
finaliseCap(cap_t cap, bool_t final, bool_t exposed)
{
    finaliseCap_ret_t fc_ret;

    if (isArchCap(cap)) {
        fc_ret.remainder = Arch_finaliseCap(cap, final);
        fc_ret.irq = irqInvalid;
        return fc_ret;
    }

    switch (cap_get_capType(cap)) {
    case cap_endpoint_cap:
        if (final) {
            cancelAllIPC(((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(cap))));
        }

        fc_ret.remainder = cap_null_cap_new();
        fc_ret.irq = irqInvalid;
        return fc_ret;

    case cap_notification_cap:
        if (final) {
            notification_t *ntfn = ((notification_t *)(cap_notification_cap_get_capNtfnPtr(cap)));

            unbindMaybeNotification(ntfn);
            cancelAllSignals(ntfn);
        }
        fc_ret.remainder = cap_null_cap_new();
        fc_ret.irq = irqInvalid;
        return fc_ret;

    case cap_reply_cap:
    case cap_null_cap:
    case cap_domain_cap:
        fc_ret.remainder = cap_null_cap_new();
        fc_ret.irq = irqInvalid;
        return fc_ret;
    }

    if (exposed) {
        _fail("finaliseCap: failed to finalise immediately.", "/home/sel4/work/work2/kernel/src/object/objecttype.c", 139, __func__);
    }

    switch (cap_get_capType(cap)) {
    case cap_cnode_cap: {
        if (final) {
            fc_ret.remainder =
                Zombie_new(
                    1 << cap_cnode_cap_get_capCNodeRadix(cap),
                    cap_cnode_cap_get_capCNodeRadix(cap),
                    cap_cnode_cap_get_capCNodePtr(cap)
                );
            fc_ret.irq = irqInvalid;
            return fc_ret;
        }
        break;
    }

    case cap_thread_cap: {
        if (final) {
            tcb_t *tcb;
            cte_t *cte_ptr;

            tcb = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap)));
           
            cte_ptr = (((cte_t *)((word_t)(tcb)&~((1ul << (10))-1ul)))+(tcbCTable));
            unbindNotification(tcb);
            suspend(tcb);

            tcbDebugRemove(tcb);

            Arch_prepareThreadDelete(tcb);
            fc_ret.remainder =
                Zombie_new(
                    tcbCNodeEntries,
                    (1ul << (5)),
                    ((word_t)(cte_ptr))
                );
            fc_ret.irq = irqInvalid;
            return fc_ret;
        }
        break;
    }

    case cap_zombie_cap:
        fc_ret.remainder = cap;
        fc_ret.irq = irqInvalid;
        return fc_ret;

    case cap_irq_handler_cap:
        if (final) {
            irq_t irq = cap_irq_handler_cap_get_capIRQ(cap);

            deletingIRQHandler(irq);

            fc_ret.remainder = cap_null_cap_new();
            fc_ret.irq = irq;
            return fc_ret;
        }
        break;
    }

    fc_ret.remainder = cap_null_cap_new();
    fc_ret.irq = irqInvalid;
    return fc_ret;
}

bool_t __attribute__((__const__))
hasCancelSendRights(cap_t cap)
{
    switch (cap_get_capType(cap)) {
    case cap_endpoint_cap:
        return cap_endpoint_cap_get_capCanSend(cap) &&
               cap_endpoint_cap_get_capCanReceive(cap) &&
               cap_endpoint_cap_get_capCanGrant(cap);

    default:
        return false;
    }
}

bool_t __attribute__((__const__))
sameRegionAs(cap_t cap_a, cap_t cap_b)
{
    switch (cap_get_capType(cap_a)) {
    case cap_untyped_cap:
        if (cap_get_capIsPhysical(cap_b)) {
            word_t aBase, bBase, aTop, bTop;

            aBase = (word_t)((word_t *)(cap_untyped_cap_get_capPtr(cap_a)));
            bBase = (word_t)cap_get_capPtr(cap_b);

            aTop = aBase + ((1ul << (cap_untyped_cap_get_capBlockSize(cap_a)))-1ul);
            bTop = bBase + ((1ul << (cap_get_capSizeBits(cap_b)))-1ul);

            return (aBase <= bBase) && (bTop <= aTop) && (bBase <= bTop);
        }
        break;

    case cap_endpoint_cap:
        if (cap_get_capType(cap_b) == cap_endpoint_cap) {
            return cap_endpoint_cap_get_capEPPtr(cap_a) ==
                   cap_endpoint_cap_get_capEPPtr(cap_b);
        }
        break;

    case cap_notification_cap:
        if (cap_get_capType(cap_b) == cap_notification_cap) {
            return cap_notification_cap_get_capNtfnPtr(cap_a) ==
                   cap_notification_cap_get_capNtfnPtr(cap_b);
        }
        break;

    case cap_cnode_cap:
        if (cap_get_capType(cap_b) == cap_cnode_cap) {
            return (cap_cnode_cap_get_capCNodePtr(cap_a) ==
                    cap_cnode_cap_get_capCNodePtr(cap_b)) &&
                   (cap_cnode_cap_get_capCNodeRadix(cap_a) ==
                    cap_cnode_cap_get_capCNodeRadix(cap_b));
        }
        break;

    case cap_thread_cap:
        if (cap_get_capType(cap_b) == cap_thread_cap) {
            return cap_thread_cap_get_capTCBPtr(cap_a) ==
                   cap_thread_cap_get_capTCBPtr(cap_b);
        }
        break;

    case cap_reply_cap:
        if (cap_get_capType(cap_b) == cap_reply_cap) {
            return cap_reply_cap_get_capTCBPtr(cap_a) ==
                   cap_reply_cap_get_capTCBPtr(cap_b);
        }
        break;

    case cap_domain_cap:
        if (cap_get_capType(cap_b) == cap_domain_cap) {
            return true;
        }
        break;

    case cap_irq_control_cap:
        if (cap_get_capType(cap_b) == cap_irq_control_cap ||
                cap_get_capType(cap_b) == cap_irq_handler_cap) {
            return true;
        }
        break;

    case cap_irq_handler_cap:
        if (cap_get_capType(cap_b) == cap_irq_handler_cap) {
            return (irq_t)cap_irq_handler_cap_get_capIRQ(cap_a) ==
                   (irq_t)cap_irq_handler_cap_get_capIRQ(cap_b);
        }
        break;

    default:
        if (isArchCap(cap_a) &&
                isArchCap(cap_b)) {
            return Arch_sameRegionAs(cap_a, cap_b);
        }
        break;
    }

    return false;
}

bool_t __attribute__((__const__))
sameObjectAs(cap_t cap_a, cap_t cap_b)
{
    if (cap_get_capType(cap_a) == cap_untyped_cap) {
        return false;
    }
    if (cap_get_capType(cap_a) == cap_irq_control_cap &&
            cap_get_capType(cap_b) == cap_irq_handler_cap) {
        return false;
    }
    if (isArchCap(cap_a) && isArchCap(cap_b)) {
        return Arch_sameObjectAs(cap_a, cap_b);
    }
    return sameRegionAs(cap_a, cap_b);
}

cap_t __attribute__((__const__))
updateCapData(bool_t preserve, word_t newData, cap_t cap)
{
    if (isArchCap(cap)) {
        return Arch_updateCapData(preserve, newData, cap);
    }

    switch (cap_get_capType(cap)) {
    case cap_endpoint_cap:
        if (!preserve && cap_endpoint_cap_get_capEPBadge(cap) == 0) {
            return cap_endpoint_cap_set_capEPBadge(cap, newData);
        } else {
            return cap_null_cap_new();
        }

    case cap_notification_cap:
        if (!preserve && cap_notification_cap_get_capNtfnBadge(cap) == 0) {
            return cap_notification_cap_set_capNtfnBadge(cap, newData);
        } else {
            return cap_null_cap_new();
        }

    case cap_cnode_cap: {
        word_t guard, guardSize;
        cnode_capdata_t w = { .words = { newData } };

        guardSize = cnode_capdata_get_guardSize(w);

        if (guardSize + cap_cnode_cap_get_capCNodeRadix(cap) > (1 << 5)) {
            return cap_null_cap_new();
        } else {
            cap_t new_cap;

            guard = cnode_capdata_get_guard(w) & ((1ul << (guardSize))-1ul);
            new_cap = cap_cnode_cap_set_capCNodeGuard(cap, guard);
            new_cap = cap_cnode_cap_set_capCNodeGuardSize(new_cap,
                                                          guardSize);

            return new_cap;
        }
    }

    default:
        return cap;
    }
}

cap_t __attribute__((__const__))
maskCapRights(seL4_CapRights_t cap_rights, cap_t cap)
{
    if (isArchCap(cap)) {
        return Arch_maskCapRights(cap_rights, cap);
    }

    switch (cap_get_capType(cap)) {
    case cap_null_cap:
    case cap_domain_cap:
    case cap_cnode_cap:
    case cap_untyped_cap:
    case cap_reply_cap:
    case cap_irq_control_cap:
    case cap_irq_handler_cap:
    case cap_zombie_cap:
    case cap_thread_cap:
        return cap;

    case cap_endpoint_cap: {
        cap_t new_cap;

        new_cap = cap_endpoint_cap_set_capCanSend(
                      cap, cap_endpoint_cap_get_capCanSend(cap) &
                      seL4_CapRights_get_capAllowWrite(cap_rights));
        new_cap = cap_endpoint_cap_set_capCanReceive(
                      new_cap, cap_endpoint_cap_get_capCanReceive(cap) &
                      seL4_CapRights_get_capAllowRead(cap_rights));
        new_cap = cap_endpoint_cap_set_capCanGrant(
                      new_cap, cap_endpoint_cap_get_capCanGrant(cap) &
                      seL4_CapRights_get_capAllowGrant(cap_rights));

        return new_cap;
    }

    case cap_notification_cap: {
        cap_t new_cap;

        new_cap = cap_notification_cap_set_capNtfnCanSend(
                      cap, cap_notification_cap_get_capNtfnCanSend(cap) &
                      seL4_CapRights_get_capAllowWrite(cap_rights));
        new_cap = cap_notification_cap_set_capNtfnCanReceive(new_cap,
                                                             cap_notification_cap_get_capNtfnCanReceive(cap) &
                                                             seL4_CapRights_get_capAllowRead(cap_rights));

        return new_cap;
    }

    default:
        _fail("Invalid cap type", "/home/sel4/work/work2/kernel/src/object/objecttype.c", 418, __func__); /* Sentinel for invalid enums */
    }
}

cap_t
createObject(object_t t, void *regionBase, word_t userSize, bool_t deviceMemory)
{
    /* Handle architecture-specific objects. */
    if (t >= (object_t) seL4_NonArchObjectTypeCount) {
        return Arch_createObject(t, regionBase, userSize, deviceMemory);
    }

    /* Create objects. */
    switch ((api_object_t)t) {
    case seL4_TCBObject: {
        tcb_t *tcb;
        tcb = ((tcb_t *)((word_t)regionBase + (1ul << ((4 + 4)))));
        /** AUXUPD: "(True, ptr_retyps 1
          (Ptr ((ptr_val \<acute>tcb) - 0x100) :: (cte_C[5]) ptr)
            o (ptr_retyp \<acute>tcb))" */

        /* Setup non-zero parts of the TCB. */

        Arch_initContext(&tcb->tcbArch.tcbContext);
        tcb->tcbTimeSlice = 5;
        tcb->tcbDomain = ksCurDomain;

        /* Initialize the new TCB to the current core */
        ;


        strlcpy(tcb->tcbName, "child of: '", ((1ul << (10)) - (1ul << ((4 + 4))) - sizeof(tcb_t)));
        strlcat(tcb->tcbName, ksCurThread->tcbName, ((1ul << (10)) - (1ul << ((4 + 4))) - sizeof(tcb_t)));
        strlcat(tcb->tcbName, "'", ((1ul << (10)) - (1ul << ((4 + 4))) - sizeof(tcb_t)));
        tcbDebugAppend(tcb);


        return cap_thread_cap_new(((word_t)(tcb)));
    }

    case seL4_EndpointObject:
        /** AUXUPD: "(True, ptr_retyp
          (Ptr (ptr_val \<acute>regionBase) :: endpoint_C ptr))" */
        return cap_endpoint_cap_new(0, true, true, true,
                                    ((word_t)(regionBase)));

    case seL4_NotificationObject:
        /** AUXUPD: "(True, ptr_retyp
              (Ptr (ptr_val \<acute>regionBase) :: notification_C ptr))" */
        return cap_notification_cap_new(0, true, true,
                                        ((word_t)(regionBase)));

    case seL4_CapTableObject:
        /** AUXUPD: "(True, ptr_arr_retyps (2 ^ (unat \<acute>userSize))
          (Ptr (ptr_val \<acute>regionBase) :: cte_C ptr))" */
        /** GHOSTUPD: "(True, gs_new_cnodes (unat \<acute>userSize)
                                (ptr_val \<acute>regionBase)
                                (4 + unat \<acute>userSize))" */
        return cap_cnode_cap_new(userSize, 0, 0, ((word_t)(regionBase)));

    case seL4_UntypedObject:
        /*
         * No objects need to be created; instead, just insert caps into
         * the destination slots.
         */
        return cap_untyped_cap_new(0, !!deviceMemory, userSize, ((word_t)(regionBase)));

    default:
        _fail("Invalid object type", "/home/sel4/work/work2/kernel/src/object/objecttype.c", 486, __func__);
    }
}

void
createNewObjects(object_t t, cte_t *parent, slot_range_t slots,
                 void *regionBase, word_t userSize, bool_t deviceMemory)
{
    word_t objectSize;
    void *nextFreeArea;
    word_t i;
    word_t totalObjectSize __attribute__((unused));

    /* ghost check that we're visiting less bytes than the max object size */
    objectSize = getObjectSize(t, userSize);
    totalObjectSize = slots.length << objectSize;
    /** GHOSTUPD: "(gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
        \<or> \<acute>totalObjectSize <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state, id)" */

    /* Create the objects. */
    nextFreeArea = regionBase;
    for (i = 0; i < slots.length; i++) {
        /* Create the object. */
        /** AUXUPD: "(True, typ_region_bytes (ptr_val \<acute> nextFreeArea + ((\<acute> i) << unat (\<acute> objectSize))) (unat (\<acute> objectSize)))" */
        cap_t cap = createObject(t, (void *)((word_t)nextFreeArea + (i << objectSize)), userSize, deviceMemory);

        /* Insert the cap into the user's cspace. */
        insertNewCap(parent, &slots.cnode[slots.offset + i], cap);

        /* Move along to the next region of memory. been merged into a formula of i */
    }
}

exception_t
decodeInvocation(word_t invLabel, word_t length,
                 cptr_t capIndex, cte_t *slot, cap_t cap,
                 extra_caps_t excaps, bool_t block, bool_t call,
                 word_t *buffer)
{
    if (isArchCap(cap)) {
        return Arch_decodeInvocation(invLabel, length, capIndex,
                                     slot, cap, excaps, call, buffer);
    }

    switch (cap_get_capType(cap)) {
    case cap_null_cap:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 532, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Attempted to invoke a null cap #%lu.", capIndex); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;

    case cap_zombie_cap:
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 538, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Attempted to invoke a zombie cap #%lu.", capIndex); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;

    case cap_endpoint_cap:
        if (__builtin_expect(!!(!cap_endpoint_cap_get_capCanSend(cap)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 546, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Attempted to invoke a read-only endpoint cap #%lu.", capIndex); kprintf(">>" "\033[0m" "\n"); } while (0)
                               ;
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return performInvocation_Endpoint(
                   ((endpoint_t *)(cap_endpoint_cap_get_capEPPtr(cap))),
                   cap_endpoint_cap_get_capEPBadge(cap),
                   cap_endpoint_cap_get_capCanGrant(cap), block, call);

    case cap_notification_cap: {
        if (__builtin_expect(!!(!cap_notification_cap_get_capNtfnCanSend(cap)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 561, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Attempted to invoke a read-only notification cap #%lu.", capIndex); kprintf(">>" "\033[0m" "\n"); } while (0)
                               ;
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return performInvocation_Notification(
                   ((notification_t *)(cap_notification_cap_get_capNtfnPtr(cap))),
                   cap_notification_cap_get_capNtfnBadge(cap));
    }

    case cap_reply_cap:
        if (__builtin_expect(!!(cap_reply_cap_get_capReplyMaster(cap)), 0)) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 576, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Attempted to invoke an invalid reply cap #%lu.", capIndex); kprintf(">>" "\033[0m" "\n"); } while (0)
                               ;
            current_syscall_error.type = seL4_InvalidCapability;
            current_syscall_error.invalidCapNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }

        setThreadState(ksCurThread, ThreadState_Restart);
        return performInvocation_Reply(
                   ((tcb_t *)(cap_reply_cap_get_capTCBPtr(cap))), slot);

    case cap_thread_cap:
        return decodeTCBInvocation(invLabel, length, cap,
                                   slot, excaps, call, buffer);

    case cap_domain_cap:
        return decodeDomainInvocation(invLabel, length, excaps, buffer);

    case cap_cnode_cap:
        return decodeCNodeInvocation(invLabel, length, cap, excaps, buffer);

    case cap_untyped_cap:
        return decodeUntypedInvocation(invLabel, length, slot, cap, excaps,
                                       call, buffer);

    case cap_irq_control_cap:
        return decodeIRQControlInvocation(invLabel, length, slot,
                                          excaps, buffer);

    case cap_irq_handler_cap:
        return decodeIRQHandlerInvocation(invLabel,
                                          cap_irq_handler_cap_get_capIRQ(cap), excaps);

    default:
        _fail("Invalid cap type", "/home/sel4/work/work2/kernel/src/object/objecttype.c", 609, __func__);
    }
}

exception_t
performInvocation_Endpoint(endpoint_t *ep, word_t badge,
                           bool_t canGrant, bool_t block,
                           bool_t call)
{
    sendIPC(block, call, badge, canGrant, ksCurThread, ep);

    return EXCEPTION_NONE;
}

exception_t
performInvocation_Notification(notification_t *ntfn, word_t badge)
{
    sendSignal(ntfn, badge);

    return EXCEPTION_NONE;
}

exception_t
performInvocation_Reply(tcb_t *thread, cte_t *slot)
{
    doReplyTransfer(ksCurThread, thread, slot);
    return EXCEPTION_NONE;
}
# 1 "/home/sel4/work/work2/kernel/src/object/tcb.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "./api/invocation.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 15 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/shared_types.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */
# 17 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/tcb.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 25 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 26 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 27 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/string.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 28 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 29 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/smp/ipi_inline.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 30 "/home/sel4/work/work2/kernel/src/object/tcb.c" 2



static exception_t
checkPrio(prio_t prio)
{
    prio_t mcp;

    mcp = ksCurThread->tcbMCP;

    /* system invariant: existing MCPs are bounded */
    if(!(mcp <= seL4_MaxPrio)) _assert_fail("mcp <= seL4_MaxPrio", "/home/sel4/work/work2/kernel/src/object/tcb.c", 41, __FUNCTION__);

    /* can't assign a priority greater than our own mcp */
    if (prio > mcp) {
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = seL4_MinPrio;
        current_syscall_error.rangeErrorMax = mcp;
        return EXCEPTION_SYSCALL_ERROR;
    }

    return EXCEPTION_NONE;
}

static inline void
addToBitmap(word_t cpu, word_t dom, word_t prio)
{
    word_t l1index;

    l1index = prio_to_l1index(prio);
    ksReadyQueuesL1Bitmap[dom] |= (1ul << (l1index));
    ksReadyQueuesL2Bitmap[dom][l1index] |= (1ul << (prio & ((1ul << (5))-1ul)));
}

static inline void
removeFromBitmap(word_t cpu, word_t dom, word_t prio)
{
    word_t l1index;

    l1index = prio_to_l1index(prio);
    ksReadyQueuesL2Bitmap[dom][l1index] &= ~(1ul << (prio & ((1ul << (5))-1ul)));
    if (__builtin_expect(!!(!ksReadyQueuesL2Bitmap[dom][l1index]), 0)) {
        ksReadyQueuesL1Bitmap[dom] &= ~(1ul << (l1index));
    }
}

/* Add TCB to the head of a scheduler queue */
void
tcbSchedEnqueue(tcb_t *tcb)
{
    if (!thread_state_get_tcbQueued(tcb->tcbState)) {
        tcb_queue_t queue;
        dom_t dom;
        prio_t prio;
        word_t idx;

        dom = tcb->tcbDomain;
        prio = tcb->tcbPriority;
        idx = ready_queues_index(dom, prio);
        queue = ksReadyQueues[idx];

        if (!queue.end) { /* Empty list */
            queue.end = tcb;
            addToBitmap(0, dom, prio);
        } else {
            queue.head->tcbSchedPrev = tcb;
        }
        tcb->tcbSchedPrev = ((void *)0);
        tcb->tcbSchedNext = queue.head;
        queue.head = tcb;

        ksReadyQueues[idx] = queue;

        thread_state_ptr_set_tcbQueued(&tcb->tcbState, true);
    }
}

/* Add TCB to the end of a scheduler queue */
void
tcbSchedAppend(tcb_t *tcb)
{
    if (!thread_state_get_tcbQueued(tcb->tcbState)) {
        tcb_queue_t queue;
        dom_t dom;
        prio_t prio;
        word_t idx;

        dom = tcb->tcbDomain;
        prio = tcb->tcbPriority;
        idx = ready_queues_index(dom, prio);
        queue = ksReadyQueues[idx];

        if (!queue.head) { /* Empty list */
            queue.head = tcb;
            addToBitmap(0, dom, prio);
        } else {
            queue.end->tcbSchedNext = tcb;
        }
        tcb->tcbSchedPrev = queue.end;
        tcb->tcbSchedNext = ((void *)0);
        queue.end = tcb;

        ksReadyQueues[idx] = queue;

        thread_state_ptr_set_tcbQueued(&tcb->tcbState, true);
    }
}

/* Remove TCB from a scheduler queue */
void
tcbSchedDequeue(tcb_t *tcb)
{
    if (thread_state_get_tcbQueued(tcb->tcbState)) {
        tcb_queue_t queue;
        dom_t dom;
        prio_t prio;
        word_t idx;

        dom = tcb->tcbDomain;
        prio = tcb->tcbPriority;
        idx = ready_queues_index(dom, prio);
        queue = ksReadyQueues[idx];

        if (tcb->tcbSchedPrev) {
            tcb->tcbSchedPrev->tcbSchedNext = tcb->tcbSchedNext;
        } else {
            queue.head = tcb->tcbSchedNext;
            if (__builtin_expect(!!(!tcb->tcbSchedNext), 1)) {
                removeFromBitmap(0, dom, prio);
            }
        }

        if (tcb->tcbSchedNext) {
            tcb->tcbSchedNext->tcbSchedPrev = tcb->tcbSchedPrev;
        } else {
            queue.end = tcb->tcbSchedPrev;
        }

        ksReadyQueues[idx] = queue;

        thread_state_ptr_set_tcbQueued(&tcb->tcbState, false);
    }
}


void tcbDebugAppend(tcb_t *tcb)
{
    /* prepend to the list */
    tcb->tcbDebugPrev = ((void *)0);

    if (ksDebugTCBs) {
        ksDebugTCBs->tcbDebugPrev = tcb;
    }

    tcb->tcbDebugNext = ksDebugTCBs;
    ksDebugTCBs = tcb;
}

void tcbDebugRemove(tcb_t *tcb)
{
    if(!(ksDebugTCBs != ((void *)0))) _assert_fail("NODE_STATE(ksDebugTCBs) != NULL", "/home/sel4/work/work2/kernel/src/object/tcb.c", 190, __FUNCTION__);
    if (tcb == ksDebugTCBs) {
        ksDebugTCBs = ksDebugTCBs->tcbDebugNext;
    } else {
        if(!(tcb->tcbDebugPrev)) _assert_fail("tcb->tcbDebugPrev", "/home/sel4/work/work2/kernel/src/object/tcb.c", 194, __FUNCTION__);
        tcb->tcbDebugPrev->tcbDebugNext = tcb->tcbDebugNext;
    }

    if (tcb->tcbDebugNext) {
        tcb->tcbDebugNext->tcbDebugPrev = tcb->tcbDebugPrev;
    }

    tcb->tcbDebugPrev = ((void *)0);
    tcb->tcbDebugNext = ((void *)0);
}


/* Add TCB to the end of an endpoint queue */
tcb_queue_t
tcbEPAppend(tcb_t *tcb, tcb_queue_t queue)
{
    if (!queue.head) { /* Empty list */
        queue.head = tcb;
    } else {
        queue.end->tcbEPNext = tcb;
    }
    tcb->tcbEPPrev = queue.end;
    tcb->tcbEPNext = ((void *)0);
    queue.end = tcb;

    return queue;
}

/* Remove TCB from an endpoint queue */
tcb_queue_t
tcbEPDequeue(tcb_t *tcb, tcb_queue_t queue)
{
    if (tcb->tcbEPPrev) {
        tcb->tcbEPPrev->tcbEPNext = tcb->tcbEPNext;
    } else {
        queue.head = tcb->tcbEPNext;
    }

    if (tcb->tcbEPNext) {
        tcb->tcbEPNext->tcbEPPrev = tcb->tcbEPPrev;
    } else {
        queue.end = tcb->tcbEPPrev;
    }

    return queue;
}

cptr_t __attribute__((__pure__))
getExtraCPtr(word_t *bufferPtr, word_t i)
{
    return (cptr_t)bufferPtr[seL4_MsgMaxLength + 2 + i];
}

void
setExtraBadge(word_t *bufferPtr, word_t badge,
              word_t i)
{
    bufferPtr[seL4_MsgMaxLength + 2 + i] = badge;
}

void
setupCallerCap(tcb_t *sender, tcb_t *receiver)
{
    cte_t *replySlot, *callerSlot;
    cap_t masterCap __attribute__((unused)), callerCap __attribute__((unused));

    setThreadState(sender, ThreadState_BlockedOnReply);
    replySlot = (((cte_t *)((word_t)(sender)&~((1ul << (10))-1ul)))+(tcbReply));
    masterCap = replySlot->cap;
    /* Haskell error: "Sender must have a valid master reply cap" */
    if(!(cap_get_capType(masterCap) == cap_reply_cap)) _assert_fail("cap_get_capType(masterCap) == cap_reply_cap", "/home/sel4/work/work2/kernel/src/object/tcb.c", 265, __FUNCTION__);
    if(!(cap_reply_cap_get_capReplyMaster(masterCap))) _assert_fail("cap_reply_cap_get_capReplyMaster(masterCap)", "/home/sel4/work/work2/kernel/src/object/tcb.c", 266, __FUNCTION__);
    if(!(((tcb_t *)(cap_reply_cap_get_capTCBPtr(masterCap))) == sender)) _assert_fail("TCB_PTR(cap_reply_cap_get_capTCBPtr(masterCap)) == sender", "/home/sel4/work/work2/kernel/src/object/tcb.c", 267, __FUNCTION__);
    callerSlot = (((cte_t *)((word_t)(receiver)&~((1ul << (10))-1ul)))+(tcbCaller));
    callerCap = callerSlot->cap;
    /* Haskell error: "Caller cap must not already exist" */
    if(!(cap_get_capType(callerCap) == cap_null_cap)) _assert_fail("cap_get_capType(callerCap) == cap_null_cap", "/home/sel4/work/work2/kernel/src/object/tcb.c", 271, __FUNCTION__);
    cteInsert(cap_reply_cap_new(false, ((word_t)(sender))),
              replySlot, callerSlot);
}

void
deleteCallerCap(tcb_t *receiver)
{
    cte_t *callerSlot;

    callerSlot = (((cte_t *)((word_t)(receiver)&~((1ul << (10))-1ul)))+(tcbCaller));
    /** GHOSTUPD: "(True, gs_set_assn cteDeleteOne_'proc (ucast cap_reply_cap))" */
    cteDeleteOne(callerSlot);
}

extra_caps_t current_extra_caps;

exception_t
lookupExtraCaps(tcb_t* thread, word_t *bufferPtr, seL4_MessageInfo_t info)
{
    lookupSlot_raw_ret_t lu_ret;
    cptr_t cptr;
    word_t i, length;

    if (!bufferPtr) {
        current_extra_caps.excaprefs[0] = ((void *)0);
        return EXCEPTION_NONE;
    }

    length = seL4_MessageInfo_get_extraCaps(info);

    for (i = 0; i < length; i++) {
        cptr = getExtraCPtr(bufferPtr, i);

        lu_ret = lookupSlot(thread, cptr);
        if (lu_ret.status != EXCEPTION_NONE) {
            current_fault = seL4_Fault_CapFault_new(cptr, false);
            return lu_ret.status;
        }

        current_extra_caps.excaprefs[i] = lu_ret.slot;
    }
    if (i < ((1ul<<(seL4_MsgExtraCapBits))-1)) {
        current_extra_caps.excaprefs[i] = ((void *)0);
    }

    return EXCEPTION_NONE;
}

/* Copy IPC MRs from one thread to another */
word_t
copyMRs(tcb_t *sender, word_t *sendBuf, tcb_t *receiver,
        word_t *recvBuf, word_t n)
{
    word_t i;

    /* Copy inline words */
    for (i = 0; i < n && i < n_msgRegisters; i++) {
        setRegister(receiver, msgRegisters[i],
                    getRegister(sender, msgRegisters[i]));
    }

    if (!recvBuf || !sendBuf) {
        return i;
    }

    /* Copy out-of-line words */
    for (; i < n; i++) {
        recvBuf[i + 1] = sendBuf[i + 1];
    }

    return i;
}
# 656 "/home/sel4/work/work2/kernel/src/object/tcb.c"
/* The following functions sit in the syscall error monad, but include the
 * exception cases for the preemptible bottom end, as they call the invoke
 * functions directly.  This is a significant deviation from the Haskell
 * spec. */
exception_t
decodeTCBInvocation(word_t invLabel, word_t length, cap_t cap,
                    cte_t* slot, extra_caps_t excaps, bool_t call,
                    word_t *buffer)
{
    /* Stall the core if we are operating on a remote TCB that is currently running */
   

    switch (invLabel) {
    case TCBReadRegisters:
        /* Second level of decoding */
        return decodeReadRegisters(cap, length, call, buffer);

    case TCBWriteRegisters:
        return decodeWriteRegisters(cap, length, buffer);

    case TCBCopyRegisters:
        return decodeCopyRegisters(cap, length, excaps, buffer);

    case TCBSuspend:
        /* Jump straight to the invoke */
        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeTCB_Suspend(
                   ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))));

    case TCBResume:
        setThreadState(ksCurThread, ThreadState_Restart);
        return invokeTCB_Resume(
                   ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))));

    case TCBConfigure:
        return decodeTCBConfigure(cap, length, slot, excaps, buffer);

    case TCBSetPriority:
        return decodeSetPriority(cap, length, buffer);

    case TCBSetMCPriority:
        return decodeSetMCPriority(cap, length, buffer);

    case TCBSetIPCBuffer:
        return decodeSetIPCBuffer(cap, length, slot, excaps, buffer);

    case TCBSetSpace:
        return decodeSetSpace(cap, length, slot, excaps, buffer);

    case TCBBindNotification:
        return decodeBindNotification(cap, excaps);

    case TCBUnbindNotification:
        return decodeUnbindNotification(cap);






        /* There is no notion of arch specific TCB invocations so this needs to go here */
# 736 "/home/sel4/work/work2/kernel/src/object/tcb.c"
    default:
        /* Haskell: "throw IllegalOperation" */
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 738, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB: Illegal operation."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }
}

enum CopyRegistersFlags {
    CopyRegisters_suspendSource = 0,
    CopyRegisters_resumeTarget = 1,
    CopyRegisters_transferFrame = 2,
    CopyRegisters_transferInteger = 3
};

exception_t
decodeCopyRegisters(cap_t cap, word_t length,
                    extra_caps_t excaps, word_t *buffer)
{
    word_t transferArch;
    tcb_t *srcTCB;
    cap_t source_cap;
    word_t flags;

    if (length < 1 || excaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 761, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB CopyRegisters: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    flags = getSyscallArg(0, buffer);

    transferArch = Arch_decodeTransfer(flags >> 8);

    source_cap = excaps.excaprefs[0]->cap;

    if (cap_get_capType(source_cap) == cap_thread_cap) {
        srcTCB = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(source_cap)));
    } else {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 775, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB CopyRegisters: Invalid source TCB."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidCapability;
        current_syscall_error.invalidCapNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_CopyRegisters(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), srcTCB,
               flags & (1ul << (CopyRegisters_suspendSource)),
               flags & (1ul << (CopyRegisters_resumeTarget)),
               flags & (1ul << (CopyRegisters_transferFrame)),
               flags & (1ul << (CopyRegisters_transferInteger)),
               transferArch);

}

enum ReadRegistersFlags {
    ReadRegisters_suspend = 0
};

exception_t
decodeReadRegisters(cap_t cap, word_t length, bool_t call,
                    word_t *buffer)
{
    word_t transferArch, flags, n;
    tcb_t* thread;

    if (length < 2) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 804, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB ReadRegisters: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    flags = getSyscallArg(0, buffer);
    n = getSyscallArg(1, buffer);

    if (n < 1 || n > n_frameRegisters + n_gpRegisters) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 814, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB ReadRegisters: Attempted to read an invalid number of registers (%d).", (int)n); kprintf(">>" "\033[0m" "\n"); } while (0)
                         ;
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 1;
        current_syscall_error.rangeErrorMax = n_frameRegisters +
                                              n_gpRegisters;
        return EXCEPTION_SYSCALL_ERROR;
    }

    transferArch = Arch_decodeTransfer(flags >> 8);

    thread = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap)));
    if (thread == ksCurThread) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 826, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB ReadRegisters: Attempted to read our own registers."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ReadRegisters(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))),
               flags & (1ul << (ReadRegisters_suspend)),
               n, transferArch, call);
}

enum WriteRegistersFlags {
    WriteRegisters_resume = 0
};

exception_t
decodeWriteRegisters(cap_t cap, word_t length, word_t *buffer)
{
    word_t flags, w;
    word_t transferArch;
    tcb_t* thread;

    if (length < 2) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 850, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB WriteRegisters: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    flags = getSyscallArg(0, buffer);
    w = getSyscallArg(1, buffer);

    if (length - 2 < w) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 860, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB WriteRegisters: Message too short for requested write size (%d/%d).", (int)(length - 2), (int)w); kprintf(">>" "\033[0m" "\n"); } while (0)
                                            ;
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    transferArch = Arch_decodeTransfer(flags >> 8);

    thread = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap)));
    if (thread == ksCurThread) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 869, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB WriteRegisters: Attempted to write our own registers."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_WriteRegisters(thread,
                                    flags & (1ul << (WriteRegisters_resume)),
                                    w, transferArch, buffer);
}

/* SetPriority, SetMCPriority, SetIPCParams and SetSpace are all
 * specialisations of TCBConfigure. */

exception_t
decodeTCBConfigure(cap_t cap, word_t length, cte_t* slot,
                   extra_caps_t rootCaps, word_t *buffer)
{
    cte_t *bufferSlot, *cRootSlot, *vRootSlot;
    cap_t bufferCap, cRootCap, vRootCap;
    deriveCap_ret_t dc_ret;
    cptr_t faultEP;
    seL4_PrioProps_t props;
    prio_t prio, mcp;
    word_t cRootData, vRootData, bufferAddr;
    exception_t status;

    if (length < 5 || rootCaps.excaprefs[0] == ((void *)0)
            || rootCaps.excaprefs[1] == ((void *)0)
            || rootCaps.excaprefs[2] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 899, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB Configure: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    faultEP = getSyscallArg(0, buffer);
    props = prioPropsFromWord(getSyscallArg(1, buffer));
    cRootData = getSyscallArg(2, buffer);
    vRootData = getSyscallArg(3, buffer);
    bufferAddr = getSyscallArg(4, buffer);

    cRootSlot = rootCaps.excaprefs[0];
    cRootCap = rootCaps.excaprefs[0]->cap;
    vRootSlot = rootCaps.excaprefs[1];
    vRootCap = rootCaps.excaprefs[1]->cap;
    bufferSlot = rootCaps.excaprefs[2];
    bufferCap = rootCaps.excaprefs[2]->cap;

    prio = seL4_PrioProps_get_prio(props);
    mcp = seL4_PrioProps_get_mcp(props);

    status = checkPrio(prio);
    if (status != EXCEPTION_NONE) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 923, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB Configure: Requested priority %lu too high (max %lu).", (unsigned long) prio, (unsigned long) ksCurThread->tcbMCP); kprintf(">>" "\033[0m" "\n"); } while (0)
                                                                                        ;
        return status;
    }

    status = checkPrio(mcp);
    if (status != EXCEPTION_NONE) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 930, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB Configure: Requested maximum controlled priority %lu too high (max %lu),", (unsigned long) mcp, (unsigned long) ksCurThread->tcbMCP); kprintf(">>" "\033[0m" "\n"); } while (0)
                                                                                       ;
        return status;
    }

    if (bufferAddr == 0) {
        bufferSlot = ((void *)0);
    } else {
        dc_ret = deriveCap(bufferSlot, bufferCap);
        if (dc_ret.status != EXCEPTION_NONE) {
            return dc_ret.status;
        }
        bufferCap = dc_ret.cap;

        exception_t e = checkValidIPCBuffer(bufferAddr, bufferCap);
        if (e != EXCEPTION_NONE) {
            return e;
        }
    }

    if (slotCapLongRunningDelete(
                (((cte_t *)((word_t)(cap_thread_cap_get_capTCBPtr(cap))&~((1ul << (10))-1ul)))+(tcbCTable))) ||
            slotCapLongRunningDelete(
                (((cte_t *)((word_t)(cap_thread_cap_get_capTCBPtr(cap))&~((1ul << (10))-1ul)))+(tcbVTable)))) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 953, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB Configure: CSpace or VSpace currently being deleted."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cRootData != 0) {
        cRootCap = updateCapData(false, cRootData, cRootCap);
    }

    dc_ret = deriveCap(cRootSlot, cRootCap);
    if (dc_ret.status != EXCEPTION_NONE) {
        return dc_ret.status;
    }
    cRootCap = dc_ret.cap;

    if (cap_get_capType(cRootCap) != cap_cnode_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 969, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB Configure: CSpace cap is invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (vRootData != 0) {
        vRootCap = updateCapData(false, vRootData, vRootCap);
    }

    dc_ret = deriveCap(vRootSlot, vRootCap);
    if (dc_ret.status != EXCEPTION_NONE) {
        return dc_ret.status;
    }
    vRootCap = dc_ret.cap;

    if (!isValidVTableRoot(vRootCap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 985, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB Configure: VSpace cap is invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ThreadControl(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), slot,
               faultEP, mcp, prio,
               cRootCap, cRootSlot,
               vRootCap, vRootSlot,
               bufferAddr, bufferCap,
               bufferSlot, thread_control_update_all);
}

exception_t
decodeSetPriority(cap_t cap, word_t length, word_t *buffer)
{
    prio_t newPrio;
    exception_t status;

    if (length < 1) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1007, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB SetPriority: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    newPrio = getSyscallArg(0, buffer);

    status = checkPrio(newPrio);
    if (status != EXCEPTION_NONE) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1017, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB SetPriority: Requested priority %lu too high (max %lu).", (unsigned long) newPrio, (unsigned long) ksCurThread->tcbMCP); kprintf(">>" "\033[0m" "\n"); } while (0)
                                                                                           ;
        return status;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ThreadControl(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), ((void *)0),
               0, 0, newPrio,
               cap_null_cap_new(), ((void *)0),
               cap_null_cap_new(), ((void *)0),
               0, cap_null_cap_new(),
               ((void *)0), thread_control_update_priority);
}

exception_t
decodeSetMCPriority(cap_t cap, word_t length, word_t *buffer)
{
    prio_t newMcp;
    exception_t status;

    if (length < 1) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1038, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB SetMCPriority: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    newMcp = getSyscallArg(0, buffer);

    status = checkPrio(newMcp);
    if (status != EXCEPTION_NONE) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1048, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB SetMCPriority: Requested maximum controlled priority %lu too high (max %lu).", (unsigned long) newMcp, (unsigned long) ksCurThread->tcbMCP); kprintf(">>" "\033[0m" "\n"); } while (0)
                                                                                          ;
        return status;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ThreadControl(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), ((void *)0),
               0, newMcp, 0,
               cap_null_cap_new(), ((void *)0),
               cap_null_cap_new(), ((void *)0),
               0, cap_null_cap_new(),
               ((void *)0), thread_control_update_mcp);
}

exception_t
decodeSetIPCBuffer(cap_t cap, word_t length, cte_t* slot,
                   extra_caps_t excaps, word_t *buffer)
{
    cptr_t cptr_bufferPtr;
    cap_t bufferCap;
    cte_t *bufferSlot;

    if (length < 1 || excaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1071, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB SetIPCBuffer: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    cptr_bufferPtr = getSyscallArg(0, buffer);
    bufferSlot = excaps.excaprefs[0];
    bufferCap = excaps.excaprefs[0]->cap;

    if (cptr_bufferPtr == 0) {
        bufferSlot = ((void *)0);
    } else {
        exception_t e;
        deriveCap_ret_t dc_ret;

        dc_ret = deriveCap(bufferSlot, bufferCap);
        if (dc_ret.status != EXCEPTION_NONE) {
            return dc_ret.status;
        }
        bufferCap = dc_ret.cap;
        e = checkValidIPCBuffer(cptr_bufferPtr, bufferCap);
        if (e != EXCEPTION_NONE) {
            return e;
        }
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ThreadControl(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), slot,
               0, 0, 0,
               cap_null_cap_new(), ((void *)0),
               cap_null_cap_new(), ((void *)0),
               cptr_bufferPtr, bufferCap,
               bufferSlot, thread_control_update_ipc_buffer);
}

exception_t
decodeSetSpace(cap_t cap, word_t length, cte_t* slot,
               extra_caps_t excaps, word_t *buffer)
{
    cptr_t faultEP;
    word_t cRootData, vRootData;
    cte_t *cRootSlot, *vRootSlot;
    cap_t cRootCap, vRootCap;
    deriveCap_ret_t dc_ret;

    if (length < 3 || excaps.excaprefs[0] == ((void *)0)
            || excaps.excaprefs[1] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1119, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB SetSpace: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    faultEP = getSyscallArg(0, buffer);
    cRootData = getSyscallArg(1, buffer);
    vRootData = getSyscallArg(2, buffer);

    cRootSlot = excaps.excaprefs[0];
    cRootCap = excaps.excaprefs[0]->cap;
    vRootSlot = excaps.excaprefs[1];
    vRootCap = excaps.excaprefs[1]->cap;

    if (slotCapLongRunningDelete(
                (((cte_t *)((word_t)(cap_thread_cap_get_capTCBPtr(cap))&~((1ul << (10))-1ul)))+(tcbCTable))) ||
            slotCapLongRunningDelete(
                (((cte_t *)((word_t)(cap_thread_cap_get_capTCBPtr(cap))&~((1ul << (10))-1ul)))+(tcbVTable)))) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1137, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB SetSpace: CSpace or VSpace currently being deleted."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (cRootData != 0) {
        cRootCap = updateCapData(false, cRootData, cRootCap);
    }

    dc_ret = deriveCap(cRootSlot, cRootCap);
    if (dc_ret.status != EXCEPTION_NONE) {
        return dc_ret.status;
    }
    cRootCap = dc_ret.cap;

    if (cap_get_capType(cRootCap) != cap_cnode_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1153, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB SetSpace: Invalid CNode cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (vRootData != 0) {
        vRootCap = updateCapData(false, vRootData, vRootCap);
    }

    dc_ret = deriveCap(vRootSlot, vRootCap);
    if (dc_ret.status != EXCEPTION_NONE) {
        return dc_ret.status;
    }
    vRootCap = dc_ret.cap;

    if (!isValidVTableRoot(vRootCap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1169, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB SetSpace: Invalid VSpace cap."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_ThreadControl(
               ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap))), slot,
               faultEP,
               0, 0,
               cRootCap, cRootSlot,
               vRootCap, vRootSlot,
               0, cap_null_cap_new(), ((void *)0), thread_control_update_space);
}

exception_t
decodeDomainInvocation(word_t invLabel, word_t length, extra_caps_t excaps, word_t *buffer)
{
    word_t domain;
    cap_t tcap;

    if (__builtin_expect(!!(invLabel != DomainSetSet), 0)) {
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (__builtin_expect(!!(length == 0), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1196, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Domain Configure: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    } else {
        domain = getSyscallArg(0, buffer);
        if (domain >= 1) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1203, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Domain Configure: invalid domain (%lu >= %u).", domain, 1); kprintf(">>" "\033[0m" "\n"); } while (0)
                                                 ;
            current_syscall_error.type = seL4_InvalidArgument;
            current_syscall_error.invalidArgumentNumber = 0;
            return EXCEPTION_SYSCALL_ERROR;
        }
    }

    if (__builtin_expect(!!(excaps.excaprefs[0] == ((void *)0)), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1211, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Domain Configure: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    tcap = excaps.excaprefs[0]->cap;
    if (__builtin_expect(!!(cap_get_capType(tcap) != cap_thread_cap), 0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1218, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Domain Configure: thread cap required."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    setDomain(((tcb_t *)(cap_thread_cap_get_capTCBPtr(tcap))), domain);
    return EXCEPTION_NONE;
}

exception_t
decodeBindNotification(cap_t cap, extra_caps_t excaps)
{
    notification_t *ntfnPtr;
    tcb_t *tcb;
    cap_t ntfn_cap;

    if (excaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1237, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB BindNotification: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    tcb = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap)));

    if (tcb->tcbBoundNotification) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1245, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB BindNotification: TCB already has a bound notification."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    ntfn_cap = excaps.excaprefs[0]->cap;

    if (cap_get_capType(ntfn_cap) == cap_notification_cap) {
        ntfnPtr = ((notification_t *)(cap_notification_cap_get_capNtfnPtr(ntfn_cap)));
    } else {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1255, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB BindNotification: Notification is invalid."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if (!cap_notification_cap_get_capNtfnCanReceive(ntfn_cap)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1261, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB BindNotification: Insufficient access rights"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    if ((tcb_t*)notification_ptr_get_ntfnQueue_head(ntfnPtr)
            || (tcb_t*)notification_ptr_get_ntfnBoundTCB(ntfnPtr)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1268, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB BindNotification: Notification cannot be bound."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }


    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_NotificationControl(tcb, ntfnPtr);
}

exception_t
decodeUnbindNotification(cap_t cap)
{
    tcb_t *tcb;

    tcb = ((tcb_t *)(cap_thread_cap_get_capTCBPtr(cap)));

    if (!tcb->tcbBoundNotification) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 1286, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("TCB UnbindNotification: TCB already has no bound Notification."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeTCB_NotificationControl(tcb, ((void *)0));
}

/* The following functions sit in the preemption monad and implement the
 * preemptible, non-faulting bottom end of a TCB invocation. */
exception_t
invokeTCB_Suspend(tcb_t *thread)
{
    suspend(thread);
    return EXCEPTION_NONE;
}

exception_t
invokeTCB_Resume(tcb_t *thread)
{
    restart(thread);
    return EXCEPTION_NONE;
}

exception_t
invokeTCB_ThreadControl(tcb_t *target, cte_t* slot,
                        cptr_t faultep, prio_t mcp, prio_t priority,
                        cap_t cRoot_newCap, cte_t *cRoot_srcSlot,
                        cap_t vRoot_newCap, cte_t *vRoot_srcSlot,
                        word_t bufferAddr, cap_t bufferCap,
                        cte_t *bufferSrcSlot,
                        thread_control_flag_t updateFlags)
{
    exception_t e;
    cap_t tCap = cap_thread_cap_new((word_t)target);

    if (updateFlags & thread_control_update_space) {
        target->tcbFaultHandler = faultep;
    }

    if (updateFlags & thread_control_update_mcp) {
        setMCPriority(target, mcp);
    }

    if (updateFlags & thread_control_update_priority) {
        setPriority(target, priority);
    }

    if (updateFlags & thread_control_update_space) {
        cte_t *rootSlot;

        rootSlot = (((cte_t *)((word_t)(target)&~((1ul << (10))-1ul)))+(tcbCTable));
        e = cteDelete(rootSlot, true);
        if (e != EXCEPTION_NONE) {
            return e;
        }
        if (sameObjectAs(cRoot_newCap, cRoot_srcSlot->cap) &&
                sameObjectAs(tCap, slot->cap)) {
            cteInsert(cRoot_newCap, cRoot_srcSlot, rootSlot);
        }
    }

    if (updateFlags & thread_control_update_space) {
        cte_t *rootSlot;

        rootSlot = (((cte_t *)((word_t)(target)&~((1ul << (10))-1ul)))+(tcbVTable));
        e = cteDelete(rootSlot, true);
        if (e != EXCEPTION_NONE) {
            return e;
        }
        if (sameObjectAs(vRoot_newCap, vRoot_srcSlot->cap) &&
                sameObjectAs(tCap, slot->cap)) {
            cteInsert(vRoot_newCap, vRoot_srcSlot, rootSlot);
        }
    }

    if (updateFlags & thread_control_update_ipc_buffer) {
        cte_t *bufferSlot;

        bufferSlot = (((cte_t *)((word_t)(target)&~((1ul << (10))-1ul)))+(tcbBuffer));
        e = cteDelete(bufferSlot, true);
        if (e != EXCEPTION_NONE) {
            return e;
        }
        target->tcbIPCBuffer = bufferAddr;

        Arch_setTCBIPCBuffer(target, bufferAddr);

        if (bufferSrcSlot && sameObjectAs(bufferCap, bufferSrcSlot->cap) &&
                sameObjectAs(tCap, slot->cap)) {
            cteInsert(bufferCap, bufferSrcSlot, bufferSlot);
        }

        if (target == ksCurThread) {
            rescheduleRequired();
        }
    }

    return EXCEPTION_NONE;
}

exception_t
invokeTCB_CopyRegisters(tcb_t *dest, tcb_t *tcb_src,
                        bool_t suspendSource, bool_t resumeTarget,
                        bool_t transferFrame, bool_t transferInteger,
                        word_t transferArch)
{
    if (suspendSource) {
        suspend(tcb_src);
    }

    if (resumeTarget) {
        restart(dest);
    }

    if (transferFrame) {
        word_t i;
        word_t v;
        word_t pc;

        for (i = 0; i < n_frameRegisters; i++) {
            v = getRegister(tcb_src, frameRegisters[i]);
            setRegister(dest, frameRegisters[i], v);
        }

        pc = getRestartPC(dest);
        setNextPC(dest, pc);
    }

    if (transferInteger) {
        word_t i;
        word_t v;

        for (i = 0; i < n_gpRegisters; i++) {
            v = getRegister(tcb_src, gpRegisters[i]);
            setRegister(dest, gpRegisters[i], v);
        }
    }
# 1434 "/home/sel4/work/work2/kernel/src/object/tcb.c"
    if (dest == ksCurThread) {
        /* If we modified the current thread we may need to reschedule
         * due to changing registers are only reloaded in Arch_switchToThread */
        rescheduleRequired();
    }

    return Arch_performTransfer(transferArch, tcb_src, dest);
}

/* ReadRegisters is a special case: replyFromKernel & setMRs are
 * unfolded here, in order to avoid passing the large reply message up
 * to the top level in a global (and double-copying). We prevent the
 * top-level replyFromKernel_success_empty() from running by setting the
 * thread state. Retype does this too.
 */
exception_t
invokeTCB_ReadRegisters(tcb_t *tcb_src, bool_t suspendSource,
                        word_t n, word_t arch, bool_t call)
{
    word_t i, j;
    exception_t e;
    tcb_t *thread;

    thread = ksCurThread;

    if (suspendSource) {
        suspend(tcb_src);
    }

    e = Arch_performTransfer(arch, tcb_src, ksCurThread);
    if (e != EXCEPTION_NONE) {
        return e;
    }

    if (call) {
        word_t *ipcBuffer;

        ipcBuffer = lookupIPCBuffer(true, thread);

        setRegister(thread, badgeRegister, 0);

        for (i = 0; i < n && i < n_frameRegisters && i < n_msgRegisters; i++) {
            setRegister(thread, msgRegisters[i],
                        getRegister(tcb_src, frameRegisters[i]));
        }

        if (ipcBuffer != ((void *)0) && i < n && i < n_frameRegisters) {
            for (; i < n && i < n_frameRegisters; i++) {
                ipcBuffer[i + 1] = getRegister(tcb_src, frameRegisters[i]);
            }
        }

        j = i;

        for (i = 0; i < n_gpRegisters && i + n_frameRegisters < n
                && i + n_frameRegisters < n_msgRegisters; i++) {
            setRegister(thread, msgRegisters[i + n_frameRegisters],
                        getRegister(tcb_src, gpRegisters[i]));
        }

        if (ipcBuffer != ((void *)0) && i < n_gpRegisters
                && i + n_frameRegisters < n) {
            for (; i < n_gpRegisters && i + n_frameRegisters < n; i++) {
                ipcBuffer[i + n_frameRegisters + 1] =
                    getRegister(tcb_src, gpRegisters[i]);
            }
        }

        setRegister(thread, msgInfoRegister, wordFromMessageInfo(
                        seL4_MessageInfo_new(0, 0, 0, i + j)));
    }
    setThreadState(thread, ThreadState_Running);

    return EXCEPTION_NONE;
}

exception_t
invokeTCB_WriteRegisters(tcb_t *dest, bool_t resumeTarget,
                         word_t n, word_t arch, word_t *buffer)
{
    word_t i;
    word_t pc;
    exception_t e;
    bool_t archInfo;

    e = Arch_performTransfer(arch, ksCurThread, dest);
    if (e != EXCEPTION_NONE) {
        return e;
    }

    if (n > n_frameRegisters + n_gpRegisters) {
        n = n_frameRegisters + n_gpRegisters;
    }

    archInfo = Arch_getSanitiseRegisterInfo(dest);

    for (i = 0; i < n_frameRegisters && i < n; i++) {
        /* Offset of 2 to get past the initial syscall arguments */
        setRegister(dest, frameRegisters[i],
                    sanitiseRegister(frameRegisters[i],
                                     getSyscallArg(i + 2, buffer), archInfo));
    }

    for (i = 0; i < n_gpRegisters && i + n_frameRegisters < n; i++) {
        setRegister(dest, gpRegisters[i],
                    sanitiseRegister(gpRegisters[i],
                                     getSyscallArg(i + n_frameRegisters + 2,
                                                   buffer), archInfo));
    }
# 1552 "/home/sel4/work/work2/kernel/src/object/tcb.c"
    pc = getRestartPC(dest);
    setNextPC(dest, pc);

    if (resumeTarget) {
        restart(dest);
    }

    if (dest == ksCurThread) {
        /* If we modified the current thread we may need to reschedule
         * due to changing registers are only reloaded in Arch_switchToThread */
        rescheduleRequired();
    }

    return EXCEPTION_NONE;
}

exception_t
invokeTCB_NotificationControl(tcb_t *tcb, notification_t *ntfnPtr)
{
    if (ntfnPtr) {
        bindNotification(tcb, ntfnPtr);
    } else {
        unbindNotification(tcb);
    }

    return EXCEPTION_NONE;
}


void
setThreadName(tcb_t *tcb, const char *name)
{
    strlcpy(tcb->tcbName, name, ((1ul << (10)) - (1ul << ((4 + 4))) - sizeof(tcb_t)));
}


word_t
setMRs_syscall_error(tcb_t *thread, word_t *receiveIPCBuffer)
{
    switch (current_syscall_error.type) {
    case seL4_InvalidArgument:
        return setMR(thread, receiveIPCBuffer, 0,
                     current_syscall_error.invalidArgumentNumber);

    case seL4_InvalidCapability:
        return setMR(thread, receiveIPCBuffer, 0,
                     current_syscall_error.invalidCapNumber);

    case seL4_IllegalOperation:
        return 0;

    case seL4_RangeError:
        setMR(thread, receiveIPCBuffer, 0,
              current_syscall_error.rangeErrorMin);
        return setMR(thread, receiveIPCBuffer, 1,
                     current_syscall_error.rangeErrorMax);

    case seL4_AlignmentError:
        return 0;

    case seL4_FailedLookup:
        setMR(thread, receiveIPCBuffer, 0,
              current_syscall_error.failedLookupWasSource ? 1 : 0);
        return setMRs_lookup_failure(thread, receiveIPCBuffer,
                                     current_lookup_fault, 1);

    case seL4_TruncatedMessage:
    case seL4_DeleteFirst:
    case seL4_RevokeFirst:
        return 0;
    case seL4_NotEnoughMemory:
        return setMR(thread, receiveIPCBuffer, 0,
                     current_syscall_error.memoryLeft);
    default:
        _fail("Invalid syscall error", "/home/sel4/work/work2/kernel/src/object/tcb.c", 1626, __func__);
    }
}
# 1 "/home/sel4/work/work2/kernel/src/object/untyped.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/failures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/api/syscall.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "./api/invocation.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

/* This header was generated by kernel/tools/invocation_header_gen.py.
 *
 * To add an invocation call number, edit libsel4/include/interfaces/sel4.xml.
 *
 */
# 16 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/untyped.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/objecttype.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/object/cnode.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/cspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 22 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/thread.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 23 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 24 "/home/sel4/work/work2/kernel/src/object/untyped.c" 2

static word_t
alignUp(word_t baseValue, word_t alignment)
{
    return (baseValue + ((1ul << (alignment)) - 1)) & ~((1ul << (alignment))-1ul);
}

exception_t
decodeUntypedInvocation(word_t invLabel, word_t length, cte_t *slot,
                        cap_t cap, extra_caps_t excaps,
                        bool_t call, word_t *buffer)
{
    word_t newType, userObjSize, nodeIndex;
    word_t nodeDepth, nodeOffset, nodeWindow;
    cte_t *rootSlot __attribute__((unused));
    exception_t status;
    cap_t nodeCap;
    lookupSlot_ret_t lu_ret;
    word_t nodeSize;
    word_t i;
    slot_range_t slots;
    word_t freeRef, alignedFreeRef, objectSize, untypedFreeBytes;
    word_t freeIndex;
    bool_t deviceMemory;
    bool_t reset;

    /* Ensure operation is valid. */
    if (invLabel != UntypedRetype) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 52, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped cap: Illegal operation attempted."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_IllegalOperation;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Ensure message length valid. */
    if (length < 6 || excaps.excaprefs[0] == ((void *)0)) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 59, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped invocation: Truncated message."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_TruncatedMessage;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Fetch arguments. */
    newType = getSyscallArg(0, buffer);
    userObjSize = getSyscallArg(1, buffer);
    nodeIndex = getSyscallArg(2, buffer);
    nodeDepth = getSyscallArg(3, buffer);
    nodeOffset = getSyscallArg(4, buffer);
    nodeWindow = getSyscallArg(5, buffer);

    rootSlot = excaps.excaprefs[0];

    /* Is the requested object type valid? */
    if (newType >= seL4_ObjectTypeCount) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 76, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Invalid object type."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 0;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Exclude impossibly large object sizes. This eliminates a
       possible shift-overflow problem. It looks like this check
       might be subsumed by the (objectSize >= word_bits) check below,
       however further changes will require re-verification and are
       considered low priority. */
    if (userObjSize > 29) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 88, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Invalid object size."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 0;
        current_syscall_error.rangeErrorMax = (1 << 5) - 3;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* If the target object is a CNode, is it at least size 1? */
    if (newType == seL4_CapTableObject && userObjSize == 0) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 97, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Requested CapTable size too small."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* If the target object is a Untyped, is it at least size 4? */
    if (newType == seL4_UntypedObject && userObjSize < 4) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 105, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Requested UntypedItem size too small."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Lookup the destination CNode (where our caps will be placed in). */
    if (nodeDepth == 0) {
        nodeCap = excaps.excaprefs[0]->cap;
    } else {
        cap_t rootCap = excaps.excaprefs[0]->cap;
        lu_ret = lookupTargetSlot(rootCap, nodeIndex, nodeDepth);
        if (lu_ret.status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 118, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Invalid destination address."); kprintf(">>" "\033[0m" "\n"); } while (0);
            return lu_ret.status;
        }
        nodeCap = lu_ret.slot->cap;
    }

    /* Is the destination actually a CNode? */
    if (cap_get_capType(nodeCap) != cap_cnode_cap) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 126, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Destination cap invalid or read-only."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_FailedLookup;
        current_syscall_error.failedLookupWasSource = 0;
        current_lookup_fault = lookup_fault_missing_capability_new(nodeDepth);
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Is the region where the user wants to put the caps valid? */
    nodeSize = 1 << cap_cnode_cap_get_capCNodeRadix(nodeCap);
    if (nodeOffset > nodeSize - 1) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 137, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Destination node offset #%d too large.", (int)nodeOffset); kprintf(">>" "\033[0m" "\n"); } while (0)
                                  ;
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 0;
        current_syscall_error.rangeErrorMax = nodeSize - 1;
        return EXCEPTION_SYSCALL_ERROR;
    }
    if (nodeWindow < 1 || nodeWindow > 256) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 145, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Number of requested objects (%d) too small or large.", (int)nodeWindow); kprintf(">>" "\033[0m" "\n"); } while (0)
                                  ;
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 1;
        current_syscall_error.rangeErrorMax = 256;
        return EXCEPTION_SYSCALL_ERROR;
    }
    if (nodeWindow > nodeSize - nodeOffset) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 152, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Requested destination window overruns size of node."); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_RangeError;
        current_syscall_error.rangeErrorMin = 1;
        current_syscall_error.rangeErrorMax = nodeSize - nodeOffset;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Ensure that the destination slots are all empty. */
    slots.cnode = ((cte_t *)(cap_cnode_cap_get_capCNodePtr(nodeCap)));
    slots.offset = nodeOffset;
    slots.length = nodeWindow;
    for (i = nodeOffset; i < nodeOffset + nodeWindow; i++) {
        status = ensureEmptySlot(slots.cnode + i);
        if (status != EXCEPTION_NONE) {
            do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 167, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Slot #%d in destination window non-empty.", (int)i); kprintf(">>" "\033[0m" "\n"); } while (0)
                             ;
            return status;
        }
    }

    /*
     * Determine where in the Untyped region we should start allocating new
     * objects.
     *
     * If we have no children, we can start allocating from the beginning of
     * our untyped, regardless of what the "free" value in the cap states.
     * (This may happen if all of the objects beneath us got deleted).
     *
     * If we have children, we just keep allocating from the "free" value
     * recorded in the cap.
     */
    status = ensureNoChildren(slot);
    if (status != EXCEPTION_NONE) {
        freeIndex = cap_untyped_cap_get_capFreeIndex(cap);
        reset = false;
    } else {
        freeIndex = 0;
        reset = true;
    }
    freeRef = ((word_t)(((word_t)(cap_untyped_cap_get_capPtr(cap))) + ((freeIndex)<<4)));

    /*
     * Determine the maximum number of objects we can create, and return an
     * error if we don't have enough space.
     *
     * We don't need to worry about alignment in this case, because if anything
     * fits, it will also fit aligned up (by packing it on the right hand side
     * of the untyped).
     */
    objectSize = getObjectSize(newType, userObjSize);
    untypedFreeBytes = (1ul << (cap_untyped_cap_get_capBlockSize(cap))) -
                       ((freeIndex)<<4);

    if (objectSize >= (1 << 5) || (untypedFreeBytes >> objectSize) < nodeWindow) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 210, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Insufficient memory " "(%lu * %lu bytes needed, %lu bytes available).", (word_t)nodeWindow, (objectSize >= (1 << 5) ? -1 : (1ul << objectSize)), (word_t)(untypedFreeBytes)); kprintf(">>" "\033[0m" "\n"); } while (0)



                                             ;
        current_syscall_error.type = seL4_NotEnoughMemory;
        current_syscall_error.memoryLeft = untypedFreeBytes;
        return EXCEPTION_SYSCALL_ERROR;
    }

    deviceMemory = cap_untyped_cap_get_capIsDevice(cap);
    if ((deviceMemory && !Arch_isFrameType(newType))
            && newType != seL4_UntypedObject) {
        do { kprintf("\033[0m" "\033[30;1m" "<<" "\033[0m" "\033[32m" "seL4(CPU %lu)" "\033[0m" "\033[30;1m" " [%s/%d T%p \"%s\" @%lx]: ", 0lu, __func__, 219, ksCurThread, ksCurThread->tcbName, (word_t)getRestartPC(ksCurThread)); kprintf("Untyped Retype: Creating kernel objects with device untyped"); kprintf(">>" "\033[0m" "\n"); } while (0);
        current_syscall_error.type = seL4_InvalidArgument;
        current_syscall_error.invalidArgumentNumber = 1;
        return EXCEPTION_SYSCALL_ERROR;
    }

    /* Align up the free region so that it is aligned to the target object's
     * size. */
    alignedFreeRef = alignUp(freeRef, objectSize);

    /* Perform the retype. */
    setThreadState(ksCurThread, ThreadState_Restart);
    return invokeUntyped_Retype(slot, reset,
                                (void*)alignedFreeRef, newType, userObjSize,
                                slots, deviceMemory);
}

static exception_t
resetUntypedCap(cte_t *srcSlot)
{
    cap_t prev_cap = srcSlot->cap;
    word_t block_size = cap_untyped_cap_get_capBlockSize(prev_cap);
    void *regionBase = ((word_t *)(cap_untyped_cap_get_capPtr(prev_cap)));
    int chunk = 8;
    word_t offset = ((cap_untyped_cap_get_capFreeIndex(prev_cap))<<4);
    exception_t status;
    bool_t deviceMemory = cap_untyped_cap_get_capIsDevice(prev_cap);

    if (offset == 0) {
        return EXCEPTION_NONE;
    }

    /** AUXUPD: "(True, typ_region_bytes (ptr_val \<acute>regionBase)
        (unat \<acute>block_size))" */
    /** GHOSTUPD: "(True, gs_clear_region (ptr_val \<acute>regionBase)
        (unat \<acute>block_size))" */

    if (deviceMemory || block_size < chunk) {
        if (! deviceMemory) {
            clearMemory(regionBase, block_size);
        }
        srcSlot->cap = cap_untyped_cap_set_capFreeIndex(prev_cap, 0);
    } else {
        for (offset = (((offset - 1) >> (chunk)) << (chunk));
                offset != - (1ul << (chunk)); offset -= (1ul << (chunk))) {
            clearMemory(((void *)(((word_t)(regionBase)) + (offset))), chunk);
            srcSlot->cap = cap_untyped_cap_set_capFreeIndex(prev_cap, ((offset)>>4));
            status = preemptionPoint();
            if (status != EXCEPTION_NONE) {
                return status;
            }
        }
    }
    return EXCEPTION_NONE;
}

exception_t
invokeUntyped_Retype(cte_t *srcSlot,
                     bool_t reset, void* retypeBase,
                     object_t newType, word_t userSize,
                     slot_range_t destSlots, bool_t deviceMemory)
{
    word_t freeRef;
    word_t totalObjectSize;
    void *regionBase = ((word_t *)(cap_untyped_cap_get_capPtr(srcSlot->cap)));
    exception_t status;

    freeRef = ((word_t)(((word_t)(regionBase)) + ((cap_untyped_cap_get_capFreeIndex(srcSlot->cap))<<4)));

    if (reset) {
        status = resetUntypedCap(srcSlot);
        if (status != EXCEPTION_NONE) {
            return status;
        }
    }

    /* Update the amount of free space left in this untyped cap. */
    totalObjectSize = destSlots.length << getObjectSize(newType, userSize);
    freeRef = (word_t)retypeBase + totalObjectSize;
    srcSlot->cap = cap_untyped_cap_set_capFreeIndex(srcSlot->cap,
                                                    (((word_t)(freeRef) - (word_t)(regionBase))>>4));

    /* Create new objects and caps. */
    createNewObjects(newType, srcSlot, destSlots, retypeBase, userSize,
                     deviceMemory);

    return EXCEPTION_NONE;
}
# 1 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/io.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/io.c" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/io.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/io.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/io.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/devices.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/io.c" 2
# 35 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/io.c"
/* UTRSTAT */





void
putDebugChar(unsigned char c)
{
    while ( (*((volatile uint32_t *)(0xfff01000 + (0x0010 /* TX/RX status */))) & (1ul << (1))) == 0 );
    *((volatile uint32_t *)(0xfff01000 + (0x0020 /* TX buffer */))) = (c & 0xff);
}



unsigned char
getDebugChar(void)
{
    if ( (*((volatile uint32_t *)(0xfff01000 + (0x0010 /* TX/RX status */))) & (1ul << (0)))) {
        return (unsigned char) * ((volatile uint32_t *)(0xfff01000 + (0x0024 /* RX buffer */)));
    } else {
        return -1;
    }
}
# 1 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/mct.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/mct.c" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/mct.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/mct.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/timer.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */




# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/timer.h" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/timer.h" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/timer.h" 2


/* convert to khz first to avoid overflow */

/* but multiply by timer tick ms */






/* ARM generic timer implementation */

/* Use Hypervisor Physical timer */
# 44 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/machine/timer.h"
static inline void
resetGenericTimer(void)
{
    do { word_t _v = ((24000000llu / 1000llu) * 10); __asm__ volatile("mcr  " " p15, 4,  %0, c14,  c2, 0" /* 32-bit RW PL2 Physical TimerValue register */ :: "r" (_v)); }while(0);
    do { word_t _v = (1ul << (0)); __asm__ volatile("mcr  " " p15, 4,  %0, c14,  c2, 1" /* 32-bit RW PL2 Physical Timer Control register */ :: "r" (_v)); }while(0);
}

__attribute__((__section__(".boot.text"))) static inline void
initGenericTimer(void)
{
    if (1) {
        /* check the frequency is correct */
        uint32_t gpt_cnt_tval;
        __asm__ volatile("mrc  " " p15, 0,  %0, c14,  c0, 0" /* 32-bit RW Counter Frequency register */ : "=r"(gpt_cnt_tval));
        if (gpt_cnt_tval != 0 && gpt_cnt_tval != 24000000llu) {
            kprintf("gpt_cnt_tval %u, expected %u\n", gpt_cnt_tval, (uint32_t) 24000000llu);
            /* it's ok to call halt here as it's a debug build */
            halt();
        }
    }

    resetGenericTimer();
}
# 15 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/mct.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/mct.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/mct.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/devices.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/mct.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/mct.c" 2

/*
 * Samsung Exynos multi-core timer implementation
 * Samsung has a habit of ripping out ARM IP and
 * replacing it with their own.
 */
# 69 "/home/sel4/work/work2/kernel/src/plat/exynos5/../exynos_common/mct.c"
struct mct_global_map {
    uint32_t reserved0[64];
    uint32_t cntl; /* 0x100 Low word of count */
    uint32_t cnth; /* 0x104 High word of count */
    uint32_t reserved1[1];
    uint32_t cnt_wstat; /* 0x110 Write status for cnt */
    uint32_t reserved2[60];

    uint32_t comp0l; /* 0x200 Low word of Compare value */
    uint32_t comp0h; /* 0x204 High word of Compare value*/
    uint32_t comp0_add_inc; /* 0x208 Low word of Automatic increment amount */
    uint32_t comp0_res;

    uint32_t comp1l; /* 0x210 Low word of Compare value */
    uint32_t comp1h; /* 0x214 High word of Compare value*/
    uint32_t comp1_add_inc; /* 0x218 Low word of Automatic increment amount */
    uint32_t comp1_res;

    uint32_t comp2l; /* 0x220 Low word of Compare value */
    uint32_t comp2h; /* 0x224 High word of Compare value*/
    uint32_t comp2_add_inc; /* 0x228 Low word of Automatic increment amount */
    uint32_t comp2_res;

    uint32_t comp3l; /* 0x230 Low word of Compare value */
    uint32_t comp3h; /* 0x234 High word of Compare value*/
    uint32_t comp3_add_inc; /* 0x238 Low word of Automatic increment amount */
    uint32_t comp3_res;

    uint32_t tcon; /* 0x240 Timer control */
    uint32_t int_stat; /* 0x244 Interrupt pending status */
    uint32_t int_en; /* 0x248 Interrupt enable */
    uint32_t wstat; /* 0x24C  write status */
    uint32_t reserved3[44];
};

struct mct_local_map {
    uint32_t tcompl; /* 0x00 */
    uint32_t tcntl; /* 0x04 */
    uint32_t tcomph; /* 0x08 */
    uint32_t tcnth; /* 0x0C */
    uint32_t reserved0[4];
    uint32_t tcon; /* 0x20 Timer control */
    uint32_t int_stat; /* 0x30 Interrupt status */
    uint32_t int_en; /* 0x34 Interrupt enable */
    uint32_t reserved1[2];
    uint32_t wstat; /* 0x40 Write status */
    uint32_t reserved2[50];
};

struct mct_map {
    struct mct_global_map global;
    struct mct_local_map local[4];
};

static volatile struct mct_map* mct = (volatile struct mct_map*) 0xfff02000;

void
resetTimer(void)
{
    if (1) {
        resetGenericTimer();
    } else {
        mct->global.int_stat = (1U << 0);
    }
}

typedef int __assert_failed_mct_reload_32_bit[(((24000000llu / 1000llu) * 10) <= 0xffffffff) ? 1 : -1];;

__attribute__((__section__(".boot.text"))) void
initTimer(void)
{
    /* Clear write status */
    mct->global.wstat = mct->global.wstat;
    mct->global.cnt_wstat = mct->global.cnt_wstat;

    if (1) {
        /* use the arm generic timer, backed by the mct */
        /* enable the timer */
        mct->global.tcon = (1U << 8);
        while (mct->global.wstat != (1U << 16));
        mct->global.wstat = (1U << 16);

        initGenericTimer();
    } else {
        /* Use the MCT directly */
        /* Configure the comparator */
        mct->global.comp0_add_inc = ((24000000llu / 1000llu) * 10);

        uint64_t comparator_value = ((((uint64_t) mct->global.cnth) << 32llu)
                                      | mct->global.cntl) + ((24000000llu / 1000llu) * 10);
        mct->global.comp0h = (uint32_t) (comparator_value >> 32u);
        mct->global.comp0l = (uint32_t) comparator_value;
        /* Enable interrupts */
        mct->global.int_en = (1U << 0);

        /* Wait for update */
        while (mct->global.wstat != ((1U << 1) | (1U << 0) | (1U << 2)));
        mct->global.wstat = ((1U << 1) | (1U << 0) | (1U << 2));

        /* enable interrupts */
        mct->global.tcon = (1U << 8) | (1U << 0) | (1U << 1);
        while (mct->global.wstat != (1U << 16));
        mct->global.wstat = (1U << 16);
    }
}
# 1 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/types.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/machine/io.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/kernel/vspace.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 18 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/linker.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 19 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/devices.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 20 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c" 2
# 1 "/home/sel4/work/work2/kernel/include/plat/exynos5/plat/machine/hardware.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 21 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/hardware.c" 2

void plat_cleanL2Range(paddr_t start, paddr_t end) {}
void plat_invalidateL2Range(paddr_t start, paddr_t end) {}
void plat_cleanInvalidateL2Range(paddr_t start, paddr_t end) {}
# 1 "/home/sel4/work/work2/kernel/src/plat/exynos5/machine/l2cache.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

void initL2Cache(void)
{
}

void plat_cleanInvalidateCache(void)
{
}
# 1 "/home/sel4/work/work2/kernel/src/smp/ipi.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/smp/ipi.c" 2
# 1 "/home/sel4/work/work2/kernel/include/arch/arm/arch/32/mode/smp/ipi.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/smp/ipi.c" 2
# 1 "/home/sel4/work/work2/kernel/include/smp/ipi.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 16 "/home/sel4/work/work2/kernel/src/smp/ipi.c" 2
# 1 "/home/sel4/work/work2/kernel/include/smp/lock.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 17 "/home/sel4/work/work2/kernel/src/smp/ipi.c" 2
# 1 "/home/sel4/work/work2/kernel/src/smp/lock.c"
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/smp/lock.c" 2
# 1 "/home/sel4/work/work2/kernel/include/smp/lock.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 15 "/home/sel4/work/work2/kernel/src/smp/lock.c" 2
# 1 "/home/sel4/work/work2/kernel/src/string.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/config.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/string.c" 2
# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/string.c" 2
# 1 "/home/sel4/work/work2/kernel/include/string.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/string.c" 2



word_t strnlen(const char *s, word_t maxlen)
{
    word_t len;
    for (len = 0; len < maxlen && s[len]; len++);
    return len;
}

word_t strlcpy(char *dest, const char *src, word_t size)
{
    word_t len;
    for (len = 0; len + 1 < size && src[len]; len++) {
        dest[len] = src[len];
    }
    dest[len] = '\0';
    return len;
}

word_t strlcat(char *dest, const char *src, word_t size)
{
    word_t len;
    /* get to the end of dest */
    for (len = 0; len < size && dest[len]; len++);
    /* check that dest was at least 'size' length to prevent inserting
     * a null byte when we shouldn't */
    if (len < size) {
        for (; len + 1 < size && *src; len++, src++) {
            dest[len] = *src;
        }
        dest[len] = '\0';
    }
    return len;
}
# 1 "/home/sel4/work/work2/kernel/src/util.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/assert.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/util.c" 2
# 1 "/home/sel4/work/work2/kernel/include/stdint.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/util.c" 2
# 1 "/home/sel4/work/work2/kernel/include/util.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 14 "/home/sel4/work/work2/kernel/src/util.c" 2

/*
 * memzero needs a custom type that allows us to use a word
 * that has the aliasing properties of a char.
 */
typedef unsigned long __attribute__((__may_alias__)) ulong_alias;

/*
 * Zero 'n' bytes of memory starting from 's'.
 *
 * 'n' and 's' must be word aligned.
 */
void
memzero(void *s, unsigned long n)
{
    uint8_t *p = s;

    /* Ensure alignment constraints are met. */
    if(!((unsigned long)s % sizeof(unsigned long) == 0)) _assert_fail("(unsigned long)s % sizeof(unsigned long) == 0", "/home/sel4/work/work2/kernel/src/util.c", 32, __FUNCTION__);
    if(!(n % sizeof(unsigned long) == 0)) _assert_fail("n % sizeof(unsigned long) == 0", "/home/sel4/work/work2/kernel/src/util.c", 33, __FUNCTION__);

    /* We will never memzero an area larger than the largest current
       live object */
    /** GHOSTUPD: "(gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state = 0
        \<or> \<acute>n <= gs_get_assn cap_get_capSizeBits_'proc \<acute>ghost'state, id)" */

    /* Write out words. */
    while (n != 0) {
        *(ulong_alias *)p = 0;
        p += sizeof(ulong_alias);
        n -= sizeof(ulong_alias);
    }
}

void* __attribute__((externally_visible))
memset(void *s, unsigned long c, unsigned long n)
{
    uint8_t *p;

    /*
     * If we are only writing zeros and we are word aligned, we can
     * use the optimized 'memzero' function.
     */
    if (__builtin_expect(!!(c == 0 && ((unsigned long)s % sizeof(unsigned long)) == 0 && (n % sizeof(unsigned long)) == 0), 1)) {
        memzero(s, n);
    } else {
        /* Otherwise, we use a slower, simple memset. */
        for (p = (uint8_t *)s; n > 0; n--, p++) {
            *p = (uint8_t)c;
        }
    }

    return s;
}

void* __attribute__((externally_visible))
memcpy(void* ptr_dst, const void* ptr_src, unsigned long n)
{
    uint8_t *p;
    const uint8_t *q;

    for (p = (uint8_t *)ptr_dst, q = (const uint8_t *)ptr_src; n; n--, p++, q++) {
        *p = *q;
    }

    return ptr_dst;
}

int __attribute__((__pure__))
strncmp(const char* s1, const char* s2, int n)
{
    word_t i;
    int diff;

    for (i = 0; i < n; i++) {
        diff = ((unsigned char*)s1)[i] - ((unsigned char*)s2)[i];
        if (diff != 0 || s1[i] == '\0') {
            return diff;
        }
    }

    return 0;
}

long __attribute__((__const__))
char_to_long(char c)
{
    if (c >= '0' && c <= '9') {
        return c - '0';
    } else if (c >= 'A' && c <= 'F') {
        return c - 'A' + 10;
    } else if (c >= 'a' && c <= 'f') {
        return c - 'a' + 10;
    }
    return -1;
}

long __attribute__((__pure__))
str_to_long(const char* str)
{
    unsigned int base;
    long res;
    long val = 0;
    char c;

    /*check for "0x" */
    if (*str == '0' && (*(str + 1) == 'x' || *(str + 1) == 'X')) {
        base = 16;
        str += 2;
    } else {
        base = 10;
    }

    if (!*str) {
        return -1;
    }

    c = *str;
    while (c != '\0') {
        res = char_to_long(c);
        if (res == -1 || res >= base) {
            return -1;
        }
        val = val * base + res;
        str++;
        c = *str;
    }

    return val;
}
# 1 "/home/sel4/work/work2/kernel/src/config/default_domain.c"
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */

# 1 "/home/sel4/work/work2/kernel/include/object/structures.h" 1
/*
 * Copyright 2014, General Dynamics C4 Systems
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(GD_GPL)
 */
# 12 "/home/sel4/work/work2/kernel/src/config/default_domain.c" 2
# 1 "/home/sel4/work/work2/kernel/include/model/statedata.h" 1
/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the GNU General Public License version 2. Note that NO WARRANTY is provided.
 * See "LICENSE_GPLv2.txt" for details.
 *
 * @TAG(DATA61_GPL)
 */
# 13 "/home/sel4/work/work2/kernel/src/config/default_domain.c" 2

/* Default schedule. */
const dschedule_t ksDomSchedule[] = {
    { .domain = 0, .length = 1 },
};

const word_t ksDomScheduleLength = sizeof(ksDomSchedule) / sizeof(dschedule_t);
